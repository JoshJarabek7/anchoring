"""ChromaDB implementation for vector database operations."""
from __future__ import annotations
import logging
from typing import Any, Dict, List, Optional, TypedDict, Union, Literal
from enum import Enum
import os
from dotenv import load_dotenv

from chromadb import AsyncHttpClient

logger = logging.getLogger(__name__)

class DocumentCategory(str, Enum):
    """Document categories matching TypeScript implementation."""
    DOCUMENTATION = "documentation"
    CODE = "code"
    CONVERSATION = "conversation"
    GENERAL = "general"

class DocumentMetadata(TypedDict, total=False):
    """Document metadata matching TypeScript implementation."""
    category: DocumentCategory
    language: Optional[str]
    language_version: Optional[str]
    framework: Optional[str]
    framework_version: Optional[str]
    library: Optional[str]
    library_version: Optional[str]
    title: str
    description: str
    source_url: str
    concepts: List[str]
    status: Optional[str]

class UniversalDocument(TypedDict):
    """Universal document format matching TypeScript implementation."""
    id: str
    content: str
    metadata: DocumentMetadata

class ChromaDocument(TypedDict):
    """ChromaDB specific document format."""
    id: str
    embedding: List[float]
    metadata: DocumentMetadata
    content: str

class ChromaConfig(TypedDict):
    """ChromaDB configuration matching TypeScript implementation."""
    host: str
    port: int
    collection_name: str

DocumentFilter = Dict[str, Any]  # Matches TypeScript DocumentFilter type

class ChromaDBProvider:
    """ChromaDB implementation for vector database operations."""
    
    def __init__(self):
        """Initialize ChromaDB provider."""
        self.client: Optional[AsyncHttpClient] = None
        self.collection: Optional[Any] = None
        
    async def initialize(self) -> None:
        """Initialize connection to ChromaDB using environment variables."""
        load_dotenv()  # Load environment variables from .env file
        
        host = os.getenv('CHROMADB_HOST', 'localhost')
        port = int(os.getenv('CHROMADB_PORT', '8001'))
            
        try:
            self.client = await AsyncHttpClient(
                host=host,
                port=port
            )
            logger.info(f"Initialized ChromaDB client at {host}:{port}")
        except Exception as e:
            logger.error(f"Failed to initialize ChromaDB client: {str(e)}")
            raise
            
    async def get_or_create_collection(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> None:
        """Get or create a ChromaDB collection."""
        if not self.client:
            raise RuntimeError("ChromaDB client not initialized")
            
        try:
            # Use the same high-performance settings as before
            default_metadata = {
                "hnsw:space": "cosine",
                "hnsw:construction_ef": 1000,
                "hnsw:M": 128,
                "hnsw:search_ef": 500,
                "hnsw:num_threads": 16,
                "hnsw:resize_factor": 1.2,
                "hnsw:batch_size": 500,
                "hnsw:sync_threshold": 2000
            }
            
            # Merge with provided metadata if any
            if metadata:
                default_metadata.update(metadata)
                
            self.collection = await self.client.get_or_create_collection(
                name=name,
                metadata=default_metadata
            )
            logger.info(f"Successfully got/created collection '{name}'")
        except Exception as e:
            logger.error(f"Failed to get/create collection: {str(e)}")
            raise
            
    async def add_documents(self, documents: List[UniversalDocument]) -> None:
        """Add documents to the current collection."""
        if not self.collection:
            raise RuntimeError("No collection selected")
            
        try:
            # Convert UniversalDocuments to ChromaDocuments
            chroma_docs: List[ChromaDocument] = []
            for doc in documents:
                chroma_doc: ChromaDocument = {
                    'id': doc['id'],
                    'embedding': [],  # Will be generated by ChromaDB
                    'metadata': doc['metadata'],
                    'content': doc['content']
                }
                chroma_docs.append(chroma_doc)
            
            # Split documents into components for ChromaDB
            ids = [doc['id'] for doc in chroma_docs]
            metadatas = [doc['metadata'] for doc in chroma_docs]
            contents = [doc['content'] for doc in chroma_docs]
            
            await self.collection.add(
                ids=ids,
                metadatas=metadatas,
                documents=contents
            )
            logger.info(f"Added {len(documents)} documents to collection")
        except Exception as e:
            logger.error(f"Failed to add documents: {str(e)}")
            raise
            
    async def search_documents(
        self,
        query_embedding: List[float],
        filter_dict: Optional[DocumentFilter] = None,
        limit: int = 5
    ) -> List[UniversalDocument]:
        """Search for documents using the query embedding and optional filters."""
        if not self.collection:
            raise RuntimeError("No collection selected")
            
        try:
            results = await self.collection.query(
                query_embeddings=[query_embedding],
                where=filter_dict,
                n_results=limit
            )
            
            # Convert ChromaDB results to UniversalDocument format
            documents: List[UniversalDocument] = []
            for i in range(len(results['ids'][0])):
                doc: UniversalDocument = {
                    'id': results['ids'][0][i],
                    'content': results['documents'][0][i],
                    'metadata': results['metadatas'][0][i]
                }
                documents.append(doc)
                
            return documents
        except Exception as e:
            logger.error(f"Failed to search documents: {str(e)}")
            raise
            
    def is_available(self) -> bool:
        """Check if the database is available for use."""
        return self.collection is not None

    async def get_context_type(self) -> Literal["local", "shared"]:
        """Get the current context type."""
        return "local" 