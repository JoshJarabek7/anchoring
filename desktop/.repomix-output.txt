This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-11T20:02:41.015Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  tauri.svg
  vite.svg
src/
  components/
    crawler/
      AiProcessing.tsx
      CrawlerForm.tsx
      DocumentationSnippet.tsx
      KnowledgeBase.tsx
      ProcessingOptions.tsx
      ProcessingPipeline.tsx
      SnippetViewer.tsx
      TechDetailsForm.tsx
      URLDetailModal.tsx
      UrlInput.tsx
      URLList.tsx
    knowledge/
      KnowledgeBase.tsx
    sessions/
      CreateSessionForm.tsx
      SessionList.tsx
      SessionsPage.tsx
    settings/
      ApiSettings.tsx
      ProxySettings.tsx
      SettingsPage.tsx
      theme-provider-wrapper.tsx
      theme-provider.tsx
      VectorDBSettings.tsx
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      aspect-ratio.tsx
      avatar.tsx
      badge.tsx
      breadcrumb.tsx
      button.tsx
      calendar.tsx
      card.tsx
      carousel.tsx
      chart.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      context-menu.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      hover-card.tsx
      input-otp.tsx
      input.tsx
      label.tsx
      menubar.tsx
      navigation-menu.tsx
      pagination.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      responsive-grid.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      slider.tsx
      sonner.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
  docs/
    structured-output.md
  hooks/
    use-mobile.ts
    useKnowledgeBase.ts
    useProcessedUrls.ts
    useSnippets.ts
    useVectorDB.ts
  lib/
    vector-db/
      providers/
        chroma.ts
        pinecone.ts
      index.ts
      README.md
      service.ts
      types.ts
    crawler.ts
    db.ts
    migrations.ts
    openai.ts
    pipeline.ts
    processor.ts
    utils.ts
  types/
    forms.ts
  App.css
  App.tsx
  main.tsx
  vite-env.d.ts
src-tauri/
  capabilities/
    default.json
  src/
    lib.rs
    main.rs
    pinecone.rs
  .gitignore
  build.rs
  Cargo.toml
  tauri.conf.json
.gitignore
components.json
index.html
package.json
README.md
tailwind.config.js
TODO.md
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/components/crawler/AiProcessing.tsx">
import { useState, useEffect } from "react";
import { toast } from "sonner";
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardHeader, 
  CardTitle 
} from "../ui/card";
import { Button } from "../ui/button";
import { Checkbox } from "../ui/checkbox";
import { Input } from "../ui/input";
import { ScrollArea } from "../ui/scroll-area";
import { Label } from "../ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";
import { Switch } from "../ui/switch";
import { getURLs, CrawlURL, getProcessingSettings, saveProcessingSettings } from "../../lib/db";
import ProcessingPipeline from "./ProcessingPipeline";
import { DocumentationCategory } from "../../lib/db";
import { Badge } from "../ui/badge";
import { useProcessedUrls } from "../../hooks/useProcessedUrls";
import { useSnippets } from "../../hooks/useSnippets";
import SnippetViewer from "./SnippetViewer";
interface AiProcessingProps {
  sessionId: number;
  apiKey: string;
}
// Update the PreviewSnippets component to be clickable and show snippet count
const PreviewSnippets = ({ 
  url, 
  onClick,
  snippetCount = null 
}: { 
  url: string; 
  onClick: (url: string) => void; 
  snippetCount?: number | null;
}) => {
  return (
    <div 
      className="p-3 border rounded-md bg-muted/20 hover:bg-muted/40 cursor-pointer transition-colors"
      onClick={() => onClick(url)}
    >
      <div className="flex justify-between items-start">
        <h4 className="font-medium">{url}</h4>
        {snippetCount !== null && (
          <Badge variant="outline" className="ml-2">
            {snippetCount} {snippetCount === 1 ? 'snippet' : 'snippets'}
          </Badge>
        )}
      </div>
      <p className="text-sm text-muted-foreground mt-1">
        Click to view snippets
      </p>
    </div>
  );
};
export default function AiProcessing({ sessionId, apiKey }: AiProcessingProps) {
  const [loading, setLoading] = useState<boolean>(false);
  const [processing, setProcessing] = useState<boolean>(false);
  const [processedCount, setProcessedCount] = useState<number>(0);
  const [totalToProcess, setTotalToProcess] = useState<number>(0);
  const [settings, setSettings] = useState<{
    language?: string | undefined;
    languageVersion?: string | undefined;
    framework?: string | undefined;
    frameworkVersion?: string | undefined;
    library?: string | undefined;
    libraryVersion?: string | undefined;
  }>({});
  const [urls, setUrls] = useState<CrawlURL[]>([]);
  const [filteredUrls, setFilteredUrls] = useState<CrawlURL[]>([]);
  const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
  const [selectAll, setSelectAll] = useState<boolean>(false);
  const [processedUrls, setProcessedUrls] = useState<string[]>([]);
  const [snippetsVisible, setSnippetsVisible] = useState<{ [key: string]: boolean }>({});
  const [filter, setFilter] = useState<string>("");
  const [includeProcessed, setIncludeProcessed] = useState<boolean>(true); // Default to showing all URLs
  const [aiSystem, setAiSystem] = useState<string>("You are a documentation expert...");
  const [prompt, setPrompt] = useState<string>("Extract documentation snippets...");
  const [processingStopped, setProcessingStopped] = useState<boolean>(false);
  // Check API key on component mount
  useEffect(() => {
    console.log("AiProcessing component mounted with API key:", apiKey ? `${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}` : "No API key provided");
    if (!apiKey) {
      toast.error("OpenAI API key is missing. Please add your API key in Settings.", {
        id: "api-key-missing-init",
        duration: 5000,
      });
    }
  }, [apiKey]);
  // Pagination state
  const [allUrls, setAllUrls] = useState<CrawlURL[]>([]);
  const [page, setPage] = useState<number>(1);
  const [loadingMore, setLoadingMore] = useState<boolean>(false);
  const [hasMore, setHasMore] = useState<boolean>(true);
  const URLS_PER_PAGE = 50; // Number of URLs to display per page
  // Use our custom hook to manage processed URLs
  const {
    processedUrls: customProcessedUrls,
    getSnippetCount,
    markUrlsAsProcessed
  } = useProcessedUrls(sessionId);
  // Add the snippets hook for viewing snippets
  const {
    snippets,
    loading: loadingSnippets,
    error: snippetsError,
    selectedUrl,
    fetchSnippets,
    clearSnippets
  } = useSnippets(sessionId);
  // Add new state for category selection
  const [selectedCategories, setSelectedCategories] = useState<{
    language: boolean;
    framework: boolean;
    library: boolean;
  }>({
    language: false,
    framework: false,
    library: false
  });
  // No cleanup needed - toasts auto-dismiss
  // Helper function to handle input changes properly
  const handleInputChange = (field: string, value: string) => {
    setSettings(prev => {
      // Just update with the new value
      return { ...prev, [field]: value };
    });
  };
  // Load AI processing settings for the current session
  const loadAiProcessingSettings = async () => {
    if (!sessionId) return;
    try {
      console.log(`Loading processing settings for session ${sessionId}`);
      // Get session-specific settings from the database
      const sessionSettings = await getProcessingSettings(sessionId);
      console.log("Retrieved session settings:", sessionSettings);
      if (sessionSettings) {
        // Create a new settings object to replace the current one
        const newSettings = {
          language: sessionSettings.language || undefined,
          languageVersion: sessionSettings.language_version || undefined,
          framework: sessionSettings.framework || undefined,
          frameworkVersion: sessionSettings.framework_version || undefined,
          library: sessionSettings.library || undefined,
          libraryVersion: sessionSettings.library_version || undefined
        };
        // Set all settings at once to avoid controlled/uncontrolled input warnings
        setSettings(newSettings);
        // Update the category checkboxes based on the category field
        // If category is set, use it to determine which checkbox should be selected
        if (sessionSettings.category) {
          setSelectedCategories({
            language: sessionSettings.category === DocumentationCategory.LANGUAGE,
            framework: sessionSettings.category === DocumentationCategory.FRAMEWORK,
            library: sessionSettings.category === DocumentationCategory.LIBRARY
          });
        } else {
          // For backward compatibility: set based on presence of values
          setSelectedCategories({
            language: !!sessionSettings.language,
            framework: !!sessionSettings.framework,
            library: !!sessionSettings.library
          });
        }
      } else {
        // If no settings found, use empty settings
        setSettings({
          language: undefined,
          languageVersion: undefined,
          framework: undefined,
          frameworkVersion: undefined,
          library: undefined,
          libraryVersion: undefined
        });
        setSelectedCategories({
          language: false,
          framework: false,
          library: false
        });
      }
    } catch (error) {
      console.error("Failed to load AI processing settings:", error);
      toast.error("Failed to load processing settings for this session");
    }
  };
  // Save AI processing settings when they change
  const saveAiProcessingSettings = async () => {
    if (!sessionId) {
      toast.error("No session selected");
      return;
    }
    try {
      setLoading(true);
      // Validate based on selected category
      let isValid = true;
      let missingFields: string[] = [];
      // Updated validation logic: Only validate fields for selected categories
      if (selectedCategories.language) {
        if (!settings.language) {
          isValid = false;
          missingFields.push("Language Name");
        }
        if (!settings.languageVersion) {
          isValid = false;
          missingFields.push("Language Version");
        }
      }
      if (selectedCategories.framework) {
        if (!settings.framework) {
          isValid = false;
          missingFields.push("Framework Name");
        }
        if (!settings.frameworkVersion) {
          isValid = false;
          missingFields.push("Framework Version");
        }
      }
      if (selectedCategories.library) {
        if (!settings.library) {
          isValid = false;
          missingFields.push("Library Name");
        }
        if (!settings.libraryVersion) {
          isValid = false;
          missingFields.push("Library Version");
        }
      }
      // Ensure at least one category is selected
      if (!selectedCategories.language && !selectedCategories.framework && !selectedCategories.library) {
        isValid = false;
        missingFields.push("At least one Documentation Category");
      }
      if (!isValid) {
        toast.error(`Missing required fields: ${missingFields.join(", ")}`);
        return;
      }
      // Save settings to the database for this specific session
      // Save all field values but mark the category
      await saveProcessingSettings({
        session_id: sessionId,
        language: settings.language,
        language_version: settings.languageVersion,
        framework: settings.framework,
        framework_version: settings.frameworkVersion,
        library: settings.library,
        library_version: settings.libraryVersion,
        // Add a metadata field to indicate which is the category
        category: selectedCategories.language 
          ? DocumentationCategory.LANGUAGE 
          : selectedCategories.framework 
            ? DocumentationCategory.FRAMEWORK 
            : DocumentationCategory.LIBRARY
      });
      toast.success("AI processing settings saved successfully");
    } catch (error) {
      console.error("Failed to save AI processing settings:", error);
      toast.error("Failed to save AI processing settings");
    } finally {
      setLoading(false);
    }
  };
  const loadURLs = async () => {
    try {
      setLoading(true);
      // Always include content, but we'll only be using the markdown field
      const data = await getURLs(sessionId, true);
      // Filter URLs based on the includeProcessed setting
      let availableUrls = data.filter(url => {
        // Only include URLs that have markdown content
        if (!url.markdown) return false;
        // If includeProcessed is true, show both crawled AND processed URLs
        if (includeProcessed) {
          return url.status === "crawled" || url.status === "processed" || url.status === "pending";
        }
        // Otherwise, only show crawled URLs that have not been processed
        return (url.status === "crawled" || url.status === "pending") && !customProcessedUrls.includes(url.url);
      });
      // Keep all filtered URLs in state
      setAllUrls(availableUrls);
      // Apply pagination to the filtered URLs
      const paginatedUrls = availableUrls.slice(0, URLS_PER_PAGE);
      setUrls(paginatedUrls);
      setFilteredUrls(paginatedUrls);
      // Set hasMore flag if we have more URLs than the current page shows
      setHasMore(availableUrls.length > URLS_PER_PAGE);
      // Reset page number
      setPage(1);
      // Load AI processing settings for this session
      await loadAiProcessingSettings();
    } catch (error) {
      console.error("Failed to load URLs:", error);
      toast.error("Failed to load crawled URLs");
    } finally {
      setLoading(false);
    }
  };
  // Handle loading more URLs when the "Load More" button is clicked
  const loadMoreUrls = () => {
    setLoadingMore(true);
    // Calculate next page of URLs
    const nextPage = page + 1;
    const startIdx = (nextPage - 1) * URLS_PER_PAGE;
    const endIdx = nextPage * URLS_PER_PAGE;
    // Filter all URLs based on the current filter
    const filteredAllUrls = filter ? 
      allUrls.filter(url => url.url.toLowerCase().includes(filter.toLowerCase())) : 
      allUrls;
    // Get the next page of URLs
    const nextPageUrls = filteredAllUrls.slice(startIdx, endIdx);
    // Update state
    setUrls(prevUrls => [...prevUrls, ...nextPageUrls]);
    setFilteredUrls(prevFilteredUrls => [...prevFilteredUrls, ...nextPageUrls]);
    setPage(nextPage);
    setHasMore(endIdx < filteredAllUrls.length);
    setLoadingMore(false);
  };
  useEffect(() => {
    if (sessionId) {
      // Load URLs for the new session (which will also load settings)
      loadURLs();
    }
  }, [sessionId]); // Only respond to sessionId changes
  useEffect(() => {
    if (sessionId) {
      // Reload URLs when these dependencies change
      loadURLs();
    }
  }, [customProcessedUrls, includeProcessed]); // Re-run when these change
  const handleFilterChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.toLowerCase();
    setFilter(value);
    if (!value) {
      // Reset to first page of all URLs
      setFilteredUrls(allUrls.slice(0, URLS_PER_PAGE));
      setPage(1);
      setHasMore(allUrls.length > URLS_PER_PAGE);
    } else {
      // Filter all URLs and apply pagination
      const filtered = allUrls.filter(url => 
        url.url.toLowerCase().includes(value)
      );
      setFilteredUrls(filtered.slice(0, URLS_PER_PAGE));
      setPage(1);
      setHasMore(filtered.length > URLS_PER_PAGE);
    }
  };
  const handleSelectAll = () => {
    if (selectAll) {
      setSelectedUrls([]);
    } else {
      setSelectedUrls(filteredUrls.map(url => url.url));
    }
    setSelectAll(!selectAll);
  };
  // Toggle includeProcessed setting
  const handleToggleIncludeProcessed = () => {
    // Toggle the setting - the useEffect hook will handle the data fetching
    setIncludeProcessed(prev => !prev);
    // Clear selections when the filter changes
    setSelectedUrls([]);
    setSelectAll(false);
    // No need to manually reload URLs here - it happens in the useEffect
    // that depends on includeProcessed
  };
  const handleSelectURL = (url: string, checked: boolean) => {
    if (checked) {
      setSelectedUrls(prev => [...prev, url]);
    } else {
      setSelectedUrls(prev => prev.filter(u => u !== url));
    }
  };
  const handleStartProcessing = () => {
    if (!apiKey) {
      toast.error("Please add your OpenAI API key in Settings", {
        id: "api-key-missing", // Use unique ID to prevent duplicates
      });
      return;
    }
    // This check should not be needed since the button is disabled in this case,
    // but we'll keep it as a safeguard without showing duplicated toasts
    if (selectedUrls.length === 0) {
      // Only show toast if URLs exist but none are selected
      if (filteredUrls.length > 0) {
        toast.error("Please select at least one URL to process", {
          id: "no-urls-selected", // Use unique ID to prevent duplicates
        });
      }
      return;
    }
    setProcessing(true);
  };
  const handleProcessingComplete = async (results: any) => {
    // Get the URLs that were successfully processed
    const newProcessedUrls = results
      .filter((result: any) => result.success)
      .map((result: any) => result.url);
    // Mark them as processed in the database and update our state
    await markUrlsAsProcessed(newProcessedUrls);
    // Only show toast for small batches to reduce notification overload
    if (newProcessedUrls.length <= 3) {
      toast.success(`Processed ${newProcessedUrls.length} URLs successfully`, { 
        duration: 2000,
        id: "processing-success" // Use unique ID to prevent duplicates
      });
    }
    // Instead of reloading all URLs, just update our state to avoid a full refresh
    // This makes the UI more reactive without losing position
    setUrls(prev => prev.filter(url => !newProcessedUrls.includes(url.url)));
    setFilteredUrls(prev => prev.filter(url => !newProcessedUrls.includes(url.url)));
    setProcessing(false);
    setSelectedUrls([]);
  };
  const handleProcessingCancel = () => {
    setProcessing(false);
  };
  // Calculate the selected URLs with their markdown content
  const selectedUrlsWithContent = urls
    .filter(url => selectedUrls.includes(url.url) && url.markdown)
    .map(url => ({
      // Make sure id is always a number to match the required type
      id: url.id || 0, 
      url: url.url,
      markdown: url.markdown || ""
    }));
  useEffect(() => {
    // Update selectAll state when selectedUrls or filteredUrls change
    setSelectAll(
      filteredUrls.length > 0 && 
      selectedUrls.length === filteredUrls.length
    );
  }, [selectedUrls, filteredUrls]);
  // Render URL list with processing status indicators
  const renderURLList = () => {
    if (loading) {
      return <div className="text-center py-4">Loading URLs...</div>;
    }
    if (filteredUrls.length === 0) {
      return <div className="text-center py-4">No crawled URLs found for this session</div>;
    }
    return (
      <div className="space-y-4">
        <div className="space-y-2">
          <div className="flex flex-wrap justify-between items-center gap-2">
            <div className="flex items-center space-x-2">
              <Switch 
                id="include-processed" 
                checked={includeProcessed}
                onCheckedChange={handleToggleIncludeProcessed}
              />
              <Label htmlFor="include-processed">Include already processed URLs</Label>
            </div>
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={handleSelectAll}
              disabled={filteredUrls.length === 0}
            >
              {selectAll ? "Deselect All" : "Select All"}
            </Button>
          </div>
          <Input
            placeholder="Filter URLs..."
            value={filter}
            onChange={handleFilterChange}
            className="mb-2"
          />
          <div className="flex flex-wrap justify-between text-sm text-muted-foreground mb-2 gap-2">
            <div className="flex gap-3">
              <span>Total: {filteredUrls.length} URLs</span>
              {includeProcessed && (
                <span>
                  Processed: {filteredUrls.filter(url => url.status === "processed" || customProcessedUrls.includes(url.url)).length}
                </span>
              )}
            </div>
            <span>Selected: {selectedUrls.length}</span>
          </div>
          <ScrollArea className="h-[600px] border rounded-md">
            {filteredUrls.map(url => {
              // URL is processed if its status is 'processed' OR it's in the processedUrls list
              const isProcessed = url.status === "processed" || customProcessedUrls.includes(url.url);
              return (
                <div 
                  key={url.url} 
                  className={`flex items-center space-x-2 p-2 border rounded ${
                    isProcessed ? 'bg-green-50 dark:bg-green-950 border-green-200' : 'hover:bg-muted/30'
                  }`}
                >
                  <Checkbox
                    id={`url-${url.url}`}
                    checked={selectedUrls.includes(url.url)}
                    onCheckedChange={(checked) => handleSelectURL(url.url, checked === true)}
                  />
                  <label 
                    htmlFor={`url-${url.url}`}
                    className="flex-1 text-sm cursor-pointer truncate"
                    title={url.url}
                  >
                    <div className="flex items-center">
                      <span className="truncate">{url.url}</span>
                      {isProcessed && (
                        <Badge 
                          variant="outline" 
                          className="ml-2 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100 text-xs"
                        >
                          {includeProcessed ? "Reprocess" : "Processed"}
                        </Badge>
                      )}
                    </div>
                  </label>
                </div>
              );
            })}
          </ScrollArea>
          <div className="flex justify-end">
            <Button 
              onClick={handleStartProcessing}
              disabled={selectedUrls.length === 0 || loading}
            >
              Process Selected URLs
            </Button>
          </div>
        </div>
        {/* Load More Button */}
        {hasMore && (
          <div className="flex justify-center mt-4">
            <Button
              variant="outline"
              onClick={loadMoreUrls}
              disabled={loadingMore}
              className="w-full max-w-[300px]"
            >
              {loadingMore ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent mr-2"></div>
                  Loading...
                </>
              ) : (
                `Load More URLs (${filteredUrls.length} of ${filter ? allUrls.filter(url => url.url.toLowerCase().includes(filter.toLowerCase())).length : allUrls.length})`
              )}
            </Button>
          </div>
        )}
      </div>
    );
  };
  if (!sessionId) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>AI Processing</CardTitle>
          <CardDescription>
            Process crawled content with AI
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-center py-4">Please select a session first</p>
        </CardContent>
      </Card>
    );
  }
  // Use the real ProcessingPipeline component
  if (processing) {
    return (
      <ProcessingPipeline
        urls={selectedUrlsWithContent}
        apiKey={apiKey}
        sessionId={sessionId}
        category={
          selectedCategories.language 
            ? DocumentationCategory.LANGUAGE 
            : selectedCategories.framework 
              ? DocumentationCategory.FRAMEWORK 
              : DocumentationCategory.LIBRARY
        }
        language={settings.language}
        languageVersion={settings.languageVersion}
        framework={settings.framework}
        frameworkVersion={settings.frameworkVersion}
        library={settings.library}
        libraryVersion={settings.libraryVersion}
        onComplete={handleProcessingComplete}
        onCancel={handleProcessingCancel}
      />
    );
  }
  // In the non-processing UI return, replace with the tabbed interface
  if (!processing) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>AI Processing</CardTitle>
          <CardDescription>
            Process crawled content into documentation snippets
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Category Selection */}
          <div className="space-y-4">
            <div className="space-y-2">
              <Label>Documentation Category</Label>
              <div className="flex items-center space-x-4">
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-language"
                    checked={selectedCategories.language}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: true,
                          framework: false,
                          library: false
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, language: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-language">Language</label>
                </div>
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-framework"
                    checked={selectedCategories.framework}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: false,
                          framework: true,
                          library: false
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, framework: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-framework">Framework</label>
                </div>
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-library"
                    checked={selectedCategories.library}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: false,
                          framework: false,
                          library: true
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, library: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-library">Library</label>
                </div>
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="language">Language</Label>
                <Input 
                  id="language" 
                  value={settings.language}
                  onChange={(e) => setSettings(prev => ({ ...prev, language: e.target.value }))}
                  placeholder="Enter programming language"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="languageVersion">Language Version</Label>
                <Input 
                  id="languageVersion" 
                  value={settings.languageVersion}
                  onChange={(e) => setSettings(prev => ({ ...prev, languageVersion: e.target.value }))}
                  placeholder="Enter language version"
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="framework">Framework</Label>
                <Input 
                  id="framework" 
                  value={settings.framework}
                  onChange={(e) => setSettings(prev => ({ ...prev, framework: e.target.value }))}
                  placeholder="Enter framework name"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="frameworkVersion">Framework Version</Label>
                <Input 
                  id="frameworkVersion" 
                  value={settings.frameworkVersion}
                  onChange={(e) => setSettings(prev => ({ ...prev, frameworkVersion: e.target.value }))}
                  placeholder="Enter framework version"
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="library">Library</Label>
                <Input 
                  id="library" 
                  value={settings.library || ""}
                  onChange={(e) => handleInputChange('library', e.target.value)}
                  placeholder="Enter library name"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="libraryVersion">Library Version</Label>
                <Input 
                  id="libraryVersion" 
                  value={settings.libraryVersion || ""}
                  onChange={(e) => handleInputChange('libraryVersion', e.target.value)}
                  placeholder="Enter library version"
                />
              </div>
            </div>
            <div className="flex justify-end">
              <Button 
                onClick={saveAiProcessingSettings}
                disabled={loading}
              >
                {loading ? "Saving..." : "Save Settings"}
              </Button>
            </div>
          </div>
          {/* Tabbed Interface for URLs */}
          <Tabs defaultValue="to-process" className="w-full">
            <TabsList className="grid grid-cols-2 mb-4">
              <TabsTrigger value="to-process">URLs to Process</TabsTrigger>
              <TabsTrigger value="processed" className="relative">
                Processed URLs
                {customProcessedUrls.length > 0 && (
                  <Badge variant="secondary" className="ml-2">
                    {customProcessedUrls.length}
                  </Badge>
                )}
              </TabsTrigger>
            </TabsList>
            <TabsContent value="to-process" className="space-y-4">
              {renderURLList()}
            </TabsContent>
            <TabsContent value="processed" className="space-y-4">
              {selectedUrl ? (
                <SnippetViewer
                  url={selectedUrl}
                  snippets={snippets}
                  loading={loadingSnippets}
                  error={snippetsError}
                  onBack={clearSnippets}
                />
              ) : (
                <>
                  {customProcessedUrls.length === 0 ? (
                    <div className="text-center py-8 text-muted-foreground">
                      No URLs have been processed yet
                    </div>
                  ) : (
                    <div className="space-y-4">
                      <p className="text-sm text-muted-foreground">
                        These URLs have been processed and their snippets are now stored in ChromaDB.
                        Click on a URL to view its snippets.
                      </p>
                      <ScrollArea className="h-[500px] border rounded-md p-3">
                        <div className="space-y-3">
                          {customProcessedUrls.map((url) => (
                            <PreviewSnippets 
                              key={url} 
                              url={url} 
                              onClick={fetchSnippets} 
                              snippetCount={getSnippetCount(url)}
                            />
                          ))}
                        </div>
                      </ScrollArea>
                    </div>
                  )}
                </>
              )}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    );
  }
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>AI Processing</CardTitle>
          <CardDescription>
            Process crawled content into documentation snippets
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <Label>Documentation Category</Label>
              <div className="flex items-center space-x-4">
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-language"
                    checked={selectedCategories.language}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: true,
                          framework: false,
                          library: false
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, language: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-language">Language</label>
                </div>
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-framework"
                    checked={selectedCategories.framework}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: false,
                          framework: true,
                          library: false
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, framework: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-framework">Framework</label>
                </div>
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="category-library"
                    checked={selectedCategories.library}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        // Radio button behavior - only one can be selected
                        setSelectedCategories({
                          language: false,
                          framework: false,
                          library: true
                        });
                      } else {
                        // Allow unchecking
                        setSelectedCategories(prev => ({ ...prev, library: false }));
                      }
                    }}
                  />
                  <label htmlFor="category-library">Library</label>
                </div>
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="language">Language</Label>
                <Input 
                  id="language" 
                  value={settings.language}
                  onChange={(e) => setSettings(prev => ({ ...prev, language: e.target.value }))}
                  placeholder="Enter programming language"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="languageVersion">Language Version</Label>
                <Input 
                  id="languageVersion" 
                  value={settings.languageVersion}
                  onChange={(e) => setSettings(prev => ({ ...prev, languageVersion: e.target.value }))}
                  placeholder="Enter language version"
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="framework">Framework</Label>
                <Input 
                  id="framework" 
                  value={settings.framework}
                  onChange={(e) => setSettings(prev => ({ ...prev, framework: e.target.value }))}
                  placeholder="Enter framework name"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="frameworkVersion">Framework Version</Label>
                <Input 
                  id="frameworkVersion" 
                  value={settings.frameworkVersion}
                  onChange={(e) => setSettings(prev => ({ ...prev, frameworkVersion: e.target.value }))}
                  placeholder="Enter framework version"
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="library">Library</Label>
                <Input 
                  id="library" 
                  value={settings.library || ""}
                  onChange={(e) => handleInputChange('library', e.target.value)}
                  placeholder="Enter library name"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="libraryVersion">Library Version</Label>
                <Input 
                  id="libraryVersion" 
                  value={settings.libraryVersion || ""}
                  onChange={(e) => handleInputChange('libraryVersion', e.target.value)}
                  placeholder="Enter library version"
                />
              </div>
            </div>
            <div className="flex justify-end">
              <Button 
                onClick={saveAiProcessingSettings}
                disabled={loading}
              >
                {loading ? "Saving..." : "Save Settings"}
              </Button>
            </div>
          </div>
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <Label>Select URLs to Process</Label>
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={handleSelectAll}
              >
                {selectAll ? "Deselect All" : "Select All"}
              </Button>
            </div>
            <Input
              placeholder="Filter URLs..."
              value={filter}
              onChange={handleFilterChange}
              className="mb-2"
            />
            <div className="flex justify-between text-sm text-muted-foreground mb-2">
              <span>Total: {filteredUrls.length} URLs</span>
              <span>Selected: {selectedUrls.length}</span>
              <span>Already Processed: {customProcessedUrls.length}</span>
            </div>
            <ScrollArea className="h-[600px] border rounded-md">
              {renderURLList()}
            </ScrollArea>
          </div>
          <div className="flex justify-end">
            <Button 
              onClick={handleStartProcessing}
              disabled={selectedUrls.length === 0 || loading}
            >
              Process Selected URLs
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/crawler/CrawlerForm.tsx">
import { useState, useEffect } from "react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Textarea } from "../ui/textarea";
import { Label } from "../ui/label";
import { Checkbox } from "../ui/checkbox";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../ui/card";
import { saveCrawlSettings, CrawlSettings } from "../../lib/db";
interface CrawlerFormProps {
  sessionId: number;
  existingSettings?: CrawlSettings;
  onSettingsSaved: (settings: CrawlSettings) => void;
}
const formSchema = z.object({
  prefix_path: z.string().min(1, "Prefix path is required"),
  anti_paths: z.string(),
  anti_keywords: z.string(),
  max_concurrent_requests: z.number().int().min(1).max(16).optional(),
  unlimited_parallelism: z.boolean().optional(),
});
type FormData = z.infer<typeof formSchema>;
export default function CrawlerForm({ 
  sessionId, 
  existingSettings,
  onSettingsSaved
}: CrawlerFormProps) {
  const [saving, setSaving] = useState(false);
  const [prefixPath, setPrefixPath] = useState(existingSettings?.prefix_path || "");
  const [antiPaths, setAntiPaths] = useState(existingSettings?.anti_paths || "");
  const [antiKeywords, setAntiKeywords] = useState(existingSettings?.anti_keywords || "");
  const [maxConcurrentRequests, setMaxConcurrentRequests] = useState(existingSettings?.max_concurrent_requests || 4);
  const [unlimitedParallelism, setUnlimitedParallelism] = useState(existingSettings?.unlimited_parallelism || false);
  // Update local state when existingSettings changes
  useEffect(() => {
    console.log("Updating CrawlerForm with settings:", existingSettings);
    if (existingSettings) {
      setPrefixPath(existingSettings.prefix_path || "");
      setAntiPaths(existingSettings.anti_paths || "");
      setAntiKeywords(existingSettings.anti_keywords || "");
      setMaxConcurrentRequests(existingSettings.max_concurrent_requests || 4);
      setUnlimitedParallelism(existingSettings.unlimited_parallelism || false);
      // Also update the form state
      form.reset({
        prefix_path: existingSettings.prefix_path || "",
        anti_paths: existingSettings.anti_paths || "",
        anti_keywords: existingSettings.anti_keywords || "",
        max_concurrent_requests: existingSettings.max_concurrent_requests || 4,
        unlimited_parallelism: existingSettings.unlimited_parallelism || false,
      });
    }
  }, [existingSettings]);
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      prefix_path: existingSettings?.prefix_path || "",
      anti_paths: existingSettings?.anti_paths || "",
      anti_keywords: existingSettings?.anti_keywords || "",
      max_concurrent_requests: existingSettings?.max_concurrent_requests || 4,
      unlimited_parallelism: existingSettings?.unlimited_parallelism || false,
    },
    mode: "all",
  });
  const onSubmit = async () => {
    try {
      setSaving(true);
      // Prepare data using state values
      const settings = await saveCrawlSettings({
        session_id: sessionId,
        prefix_path: prefixPath.trim(),
        anti_paths: antiPaths.trim(),
        anti_keywords: antiKeywords.trim(),
        max_concurrent_requests: unlimitedParallelism ? 1000 : maxConcurrentRequests,
        unlimited_parallelism: unlimitedParallelism,
      });
      onSettingsSaved(settings);
    } catch (error) {
      console.error("Failed to save crawler settings:", error);
      alert("Failed to save crawler settings. Please try again.");
    } finally {
      setSaving(false);
    }
  };
  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Crawler Configuration</CardTitle>
        <CardDescription>Configure the web crawler settings.</CardDescription>
      </CardHeader>
      <form onSubmit={(e) => {
        e.preventDefault();
        if (!prefixPath.trim()) {
          alert("URL Prefix Path is required");
          return;
        }
        onSubmit();
      }}>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="prefix_path">URL Prefix Path <span className="text-red-500">*</span></Label>
            <div className="relative">
              <Input
                id="prefix_path"
                placeholder="e.g., https://v2.tauri.app"
                value={prefixPath}
                onChange={(e) => {
                  const value = e.target.value;
                  setPrefixPath(value);
                  form.setValue("prefix_path", value);
                }}
                className={`${!prefixPath.startsWith('http') && prefixPath ? 'border-amber-500 focus:ring-amber-500' : ''}`}
              />
              {!prefixPath.startsWith('http') && prefixPath && (
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  <span className="text-amber-500 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                      <line x1="12" y1="9" x2="12" y2="13"></line>
                      <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                  </span>
                </div>
              )}
            </div>
            {form.formState.errors.prefix_path && (
              <p className="text-sm text-red-500">
                {form.formState.errors.prefix_path.message}
              </p>
            )}
            {!prefixPath.startsWith('http') && prefixPath && (
              <p className="text-sm text-amber-500 font-medium">
                URL must start with http:// or https://
              </p>
            )}
            <p className="text-xs text-gray-500">
              Only URLs that start with this prefix will be crawled. Must be a complete URL including protocol.
            </p>
          </div>
          <div className="space-y-2">
            <Label htmlFor="anti_paths">Anti-Paths</Label>
            <Textarea
              id="anti_paths"
              placeholder="e.g., /releases,/blog"
              value={antiPaths}
              onChange={(e) => {
                const value = e.target.value;
                setAntiPaths(value);
                form.setValue("anti_paths", value);
              }}
            />
            <p className="text-xs text-gray-500">
              Comma-separated list of URL paths to exclude from crawling.
            </p>
          </div>
          <div className="space-y-2">
            <Label htmlFor="anti_keywords">Anti-Keywords</Label>
            <Textarea
              id="anti_keywords"
              placeholder="e.g., release,blog,archive"
              value={antiKeywords}
              onChange={(e) => {
                const value = e.target.value;
                setAntiKeywords(value);
                form.setValue("anti_keywords", value);
              }}
            />
            <p className="text-xs text-gray-500">
              Comma-separated list of keywords to exclude from crawling.
            </p>
          </div>
          <div className="border-t pt-6 space-y-5">
            <h3 className="font-medium text-base">Parallelism Settings</h3>
            <div className="p-4 border rounded-md bg-muted/10">
              <div className="flex items-center space-x-3 mb-4">
                <div className="relative flex items-center justify-center h-5 w-5">
                  <Checkbox
                    id="unlimited-parallelism"
                    checked={unlimitedParallelism}
                    onCheckedChange={(checked) => {
                      setUnlimitedParallelism(checked === true);
                      form.setValue("unlimited_parallelism", checked === true);
                    }}
                    className="h-5 w-5"
                  />
                  {unlimitedParallelism && (
                    <div className="absolute inset-0 flex items-center justify-center text-primary-foreground pointer-events-none">
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                    </div>
                  )}
                </div>
                <label
                  htmlFor="unlimited-parallelism"
                  className="text-sm font-medium leading-none cursor-pointer"
                >
                  Unlimited parallelism (Crawl all URLs simultaneously)
                </label>
              </div>
              {!unlimitedParallelism && (
                <div className="pl-8 space-y-3">
                  <Label htmlFor="max_concurrent_requests">
                    Parallel Crawling: <span className="font-medium text-primary">{maxConcurrentRequests} URLs</span>
                  </Label>
                  <div className="flex items-center space-x-4">
                    <Input
                      id="max_concurrent_requests"
                      type="number"
                      min={1}
                      value={maxConcurrentRequests}
                      onChange={(e) => {
                        const value = parseInt(e.target.value) || 4;
                        setMaxConcurrentRequests(value);
                        form.setValue("max_concurrent_requests", value);
                      }}
                      className="w-24"
                    />
                  </div>
                  <p className="text-xs text-muted-foreground">
                    Higher values crawl faster but use more system resources
                  </p>
                </div>
              )}
            </div>
          </div>
        </CardContent>
        <CardFooter className="pt-6">
          <Button 
            type="submit"
            disabled={saving || !prefixPath.trim() || !prefixPath.startsWith('http')}
            className="min-w-40 bg-primary"
          >
            {saving ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent mr-2"></div>
                <span>Saving...</span>
              </>
            ) : (
              <>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2">
                  <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                  <polyline points="17 21 17 13 7 13 7 21"></polyline>
                  <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                <span>Save Configuration</span>
              </>
            )}
          </Button>
        </CardFooter>
      </form>
    </Card>
  );
}
</file>

<file path="src/components/crawler/DocumentationSnippet.tsx">
import { FullDocumentationSnippet } from '@/lib/db';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { ExternalLink } from 'lucide-react';
interface DocumentationSnippetProps {
  snippet: FullDocumentationSnippet;
  onViewSource?: (url: string) => void;
}
export default function DocumentationSnippetCard({ snippet, onViewSource }: DocumentationSnippetProps) {
  return (
    <Card className="mb-4 overflow-hidden">
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start gap-2">
          <div>
            <CardTitle className="text-lg">{snippet.title}</CardTitle>
            {snippet.source_url && (
              <CardDescription className="text-xs truncate max-w-[300px]">
                Source: {snippet.source_url}
              </CardDescription>
            )}
          </div>
          {snippet.source_url && onViewSource && (
            <Button 
              variant="ghost" 
              size="icon" 
              onClick={() => onViewSource(snippet.source_url || '')}
              className="h-8 w-8"
            >
              <ExternalLink className="h-4 w-4" />
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent className="pb-2">
        <div className="mb-3 text-sm text-muted-foreground">{snippet.description}</div>
        {/* Render the markdown content with the prose classes */}
        <div 
          className="prose prose-sm dark:prose-invert max-w-none
          prose-headings:text-foreground prose-headings:font-medium 
          prose-p:text-muted-foreground prose-p:leading-7
          prose-a:text-primary hover:prose-a:underline
          prose-strong:text-foreground prose-strong:font-medium
          prose-code:text-foreground prose-code:bg-muted prose-code:rounded prose-code:px-1 prose-code:py-0.5 prose-code:text-sm prose-code:font-mono
          prose-pre:bg-muted prose-pre:text-foreground prose-pre:rounded-md prose-pre:p-4 prose-pre:overflow-x-auto
          prose-img:rounded-md
          prose-hr:border-border
          prose-blockquote:border-l-primary prose-blockquote:text-muted-foreground
          prose-table:text-foreground prose-th:bg-muted prose-th:text-foreground prose-td:border-border"
          dangerouslySetInnerHTML={{ __html: markdownToHtml(snippet.content) }}
        />
      </CardContent>
      <CardFooter className="flex flex-wrap gap-2 pt-1 pb-3">
        {/* Display metadata as badges */}
        {snippet.category && (
          <Badge variant="outline" className="text-xs">
            {snippet.category}
          </Badge>
        )}
        {snippet.language && (
          <Badge variant="outline" className="text-xs bg-blue-50 dark:bg-blue-950">
            {snippet.language} {snippet.language_version}
          </Badge>
        )}
        {snippet.framework && (
          <Badge variant="outline" className="text-xs bg-purple-50 dark:bg-purple-950">
            {snippet.framework} {snippet.framework_version}
          </Badge>
        )}
        {snippet.library && (
          <Badge variant="outline" className="text-xs bg-amber-50 dark:bg-amber-950">
            {snippet.library} {snippet.library_version}
          </Badge>
        )}
        {/* Display concepts if available */}
        {snippet.concepts && snippet.concepts.length > 0 && (
          <div className="w-full mt-2 flex flex-wrap gap-1">
            {snippet.concepts.map((concept, i) => (
              <Badge key={i} variant="secondary" className="text-xs">
                {concept}
              </Badge>
            ))}
          </div>
        )}
      </CardFooter>
    </Card>
  );
}
// Markdown to HTML conversion function
function markdownToHtml(markdown: string): string {
  // Simple markdown to HTML conversion
  let html = markdown
    // Handle code blocks with proper syntax
    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
    // Handle inline code
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Handle headings
    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
    // Handle bold and italic
    .replace(/\*\*(.*)\*\*/gm, '<strong>$1</strong>')
    .replace(/\*(.*)\*/gm, '<em>$1</em>')
    // Handle links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/gm, '<a href="$2">$1</a>')
    // Handle lists
    .replace(/^\s*\n\* (.*)/gm, '<ul>\n<li>$1</li>')
    .replace(/^(\* (.+)\n)+/gm, '<ul>$&</ul>')
    .replace(/^\s*\n\d+\. (.*)/gm, '<ol>\n<li>$1</li>')
    .replace(/^(\d+\. (.+)\n)+/gm, '<ol>$&</ol>')
    // Handle blockquotes
    .replace(/^\> (.*$)/gm, '<blockquote>$1</blockquote>')
    // Handle horizontal rules
    .replace(/^\-\-\-$/gm, '<hr>')
    // Handle tables (basic support)
    .replace(/^\|(.+)\|$/gm, '<table><tr>$1</tr></table>')
    .replace(/\|/g, '</td><td>')
    // Handle paragraphs
    .replace(/^(?!<[uo]l|<h|<pre|<p|<blockquote|<table)(.+)\n/gm, '<p>$1</p>');
  // Clean up any artifacts from replacements
  html = html
    .replace(/<\/td><td>([^<]*)<\/tr><\/table>/g, '</td><td>$1</td></tr></table>')
    .replace(/<table><tr><\/td><td>/g, '<table><tr><td>');
  return html;
}
</file>

<file path="src/components/crawler/KnowledgeBase.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { useKnowledgeBase } from '@/hooks/useKnowledgeBase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import DocumentationSnippetCard from './DocumentationSnippet';
import { Search, FilterX, Settings } from 'lucide-react';
import { toast } from 'sonner';
import { DocumentationCategory } from '@/lib/db';
import { useVectorDB } from '@/hooks/useVectorDB';
interface KnowledgeBaseProps {
  sessionId: number;
}
export default function KnowledgeBase({ sessionId }: KnowledgeBaseProps) {
  const [searchInput, setSearchInput] = useState('');
  const isSearching = useRef(false);
  // Use the vectorDB hook directly with the isInitialized state
  const { isInitialized, loading: vectorDBLoading } = useVectorDB(sessionId);
  // Add debug logging
  useEffect(() => {
    console.log(`KnowledgeBase (crawler dir): sessionId=${sessionId}, isInitialized=${isInitialized}, loading=${vectorDBLoading}`);
  }, [sessionId, isInitialized, vectorDBLoading]);
  const {
    searchQuery,
    searchResults,
    filters,
    loading,
    error,
    availableComponents,
    searchSnippets,
    updateFilters
  } = useKnowledgeBase(sessionId);
  // Execute search on enter key or submit
  const handleSearch = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    if (!searchInput.trim()) {
      toast.error('Please enter a search query');
      return;
    }
    if (!isInitialized) {
      toast.error('Vector database is not initialized. Please configure it in settings.');
      return;
    }
    // Prevent recursive searches
    if (isSearching.current) return;
    isSearching.current = true;
    await searchSnippets(searchInput);
    isSearching.current = false;
  };
  // Safe search function that prevents infinite loops
  const safeSearch = (query: string) => {
    if (!query || isSearching.current) return;
    isSearching.current = true;
    searchSnippets(query).finally(() => {
      isSearching.current = false;
    });
  };
  // Reset all filters
  const resetFilters = () => {
    updateFilters({
      category: 'all',
      language: undefined,
      language_version: undefined,
      framework: undefined,
      framework_version: undefined,
      library: undefined,
      library_version: undefined
    });
    // If there's an active search, rerun it with the cleared filters
    if (searchQuery) {
      safeSearch(searchQuery);
    }
  };
  // Handle filter changes with protection against infinite loops
  const handleFilterChange = (filterUpdate: Partial<typeof filters>) => {
    updateFilters(filterUpdate);
    // Only trigger a new search if we have an active query
    if (searchQuery) {
      safeSearch(searchQuery);
    }
  };
  // View source in a new tab
  const handleViewSource = (url: string) => {
    if (!url) return;
    // For Tauri app, we'll use the window.open or an API to open external links
    window.open(url, '_blank');
  };
  // If error occurs, show a toast
  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);
  // Render category-specific filters based on selected category
  const renderCategoryFilters = () => {
    switch (filters.category) {
      case DocumentationCategory.LANGUAGE:
        return (
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="language">Language</Label>
              <Select
                value={filters.language || ''}
                onValueChange={(value) => handleFilterChange({ language: value })}
              >
                <SelectTrigger id="language">
                  <SelectValue placeholder="Select language" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">Any Language</SelectItem>
                  {availableComponents.languages.map((lang) => (
                    <SelectItem key={lang} value={lang}>{lang}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label htmlFor="language_version">Version</Label>
              <Input
                id="language_version"
                value={filters.language_version || ''}
                onChange={(e) => handleFilterChange({ language_version: e.target.value })}
                placeholder="e.g. ES2020, Python 3.9"
              />
            </div>
          </div>
        );
      case DocumentationCategory.FRAMEWORK:
        return (
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="framework">Framework</Label>
              <Select
                value={filters.framework || ''}
                onValueChange={(value) => handleFilterChange({ framework: value })}
              >
                <SelectTrigger id="framework">
                  <SelectValue placeholder="Select framework" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">Any Framework</SelectItem>
                  {availableComponents.frameworks.map((fw) => (
                    <SelectItem key={fw} value={fw}>{fw}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label htmlFor="framework_version">Version</Label>
              <Input
                id="framework_version"
                value={filters.framework_version || ''}
                onChange={(e) => handleFilterChange({ framework_version: e.target.value })}
                placeholder="e.g. 2.3.1, 18.2.0"
              />
            </div>
          </div>
        );
      case DocumentationCategory.LIBRARY:
        return (
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="library">Library</Label>
              <Select
                value={filters.library || ''}
                onValueChange={(value) => handleFilterChange({ library: value })}
              >
                <SelectTrigger id="library">
                  <SelectValue placeholder="Select library" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">Any Library</SelectItem>
                  {availableComponents.libraries.map((lib) => (
                    <SelectItem key={lib} value={lib}>{lib}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label htmlFor="library_version">Version</Label>
              <Input
                id="library_version"
                value={filters.library_version || ''}
                onChange={(e) => handleFilterChange({ library_version: e.target.value })}
                placeholder="e.g. 1.0.0, 4.2.1"
              />
            </div>
          </div>
        );
      default:
        return null;
    }
  };
  // If vector DB is loading, show loading state
  if (vectorDBLoading) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Knowledge Base</CardTitle>
          <CardDescription>
            Search your documentation snippets using semantic search
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[300px] w-full" />
        </CardContent>
      </Card>
    );
  }
  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Knowledge Base</CardTitle>
        <CardDescription>
          Search your documentation snippets using semantic search
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Search form */}
        <form onSubmit={handleSearch} className="space-y-4">
          <div className="flex space-x-2">
            <div className="flex-1">
              <Input
                placeholder="Search documentation snippets..."
                value={searchInput}
                onChange={(e) => setSearchInput(e.target.value)}
                disabled={loading}
              />
            </div>
            <Button type="submit" disabled={loading}>
              <Search className="h-4 w-4 mr-2" />
              Search
            </Button>
          </div>
          {/* Filter section */}
          <div className="border rounded-md p-4 space-y-4">
            <div className="flex justify-between items-center">
              <Label className="text-base font-medium">Filters</Label>
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={resetFilters}
                className="h-8 px-2 text-xs"
              >
                <FilterX className="h-3 w-3 mr-1" />
                Reset Filters
              </Button>
            </div>
            <div className="grid grid-cols-1 gap-4">
              <div>
                <Label htmlFor="category">Category</Label>
                <Select
                  value={filters.category}
                  onValueChange={(value: DocumentationCategory | 'all') => 
                    handleFilterChange({ category: value })}
                >
                  <SelectTrigger id="category">
                    <SelectValue placeholder="Select category" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Categories</SelectItem>
                    <SelectItem value={DocumentationCategory.LANGUAGE}>Language</SelectItem>
                    <SelectItem value={DocumentationCategory.FRAMEWORK}>Framework</SelectItem>
                    <SelectItem value={DocumentationCategory.LIBRARY}>Library</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              {/* Render category-specific filters */}
              {filters.category !== 'all' && renderCategoryFilters()}
            </div>
          </div>
        </form>
        {/* Search results */}
        <div className="min-h-[300px]">
          {loading ? (
            <div className="space-y-4">
              <Skeleton className="h-[160px] w-full" />
              <Skeleton className="h-[160px] w-full" />
            </div>
          ) : searchResults.length > 0 ? (
            <div className="space-y-1">
              <h3 className="text-sm font-medium mb-2">
                Found {searchResults.length} results for "{searchQuery}"
              </h3>
              <ScrollArea className="h-[500px]">
                <div className="space-y-2 pr-4">
                  {searchResults.map((snippet) => (
                    <DocumentationSnippetCard 
                      key={snippet.snippet_id} 
                      snippet={snippet} 
                      onViewSource={handleViewSource}
                    />
                  ))}
                </div>
              </ScrollArea>
            </div>
          ) : searchQuery ? (
            <div className="text-center py-10 text-muted-foreground">
              No results found for "{searchQuery}"
            </div>
          ) : (
            <div className="text-center py-10 text-muted-foreground">
              Enter a search query to find documentation snippets
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/crawler/ProcessingOptions.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Slider } from "@/components/ui/slider";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { markdownCleanupFormSchema, type MarkdownCleanupValues } from "@/types/forms";
interface ProcessingOptionsProps {
  onSubmit: (values: MarkdownCleanupValues & { parallelProcessing: number, unlimitedParallelism: boolean }) => void;
  onCancel: () => void;
  disabled?: boolean;
}
export default function ProcessingOptions({
  onSubmit,
  onCancel,
  disabled = false,
}: ProcessingOptionsProps) {
  const [temperature, setTemperature] = useState(0.2);
  const [parallelProcessing, setParallelProcessing] = useState(4); // Default to 4 concurrent
  const [unlimitedParallelism, setUnlimitedParallelism] = useState(false);
  const form = useForm<MarkdownCleanupValues>({
    resolver: zodResolver(markdownCleanupFormSchema),
    defaultValues: {
      model: "gpt-4o-mini",
      temperature: 0.2,
      maxTokens: 120000,
    },
  });
  const handleSubmit = (values: MarkdownCleanupValues) => {
    onSubmit({
      ...values,
      parallelProcessing,
      unlimitedParallelism
    });
  };
  return (
    <Card>
      <CardHeader>
        <CardTitle>Processing Options</CardTitle>
        <CardDescription>
          Configure options for markdown processing and AI cleanup
        </CardDescription>
      </CardHeader>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)}>
          <CardContent className="space-y-6">
            <FormField
              control={form.control}
              name="model"
              render={() => (
                <FormItem>
                  <FormLabel>Model</FormLabel>
                  <div className="p-2 border rounded-md bg-muted/20">
                    <div className="text-sm">GPT-4o-mini (Default)</div>
                  </div>
                  <FormDescription>
                    Model used for cleaning up and processing markdown
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="temperature"
              render={({ field }) => ( // field is used for onChange
                <FormItem>
                  <FormLabel>Temperature: {temperature.toFixed(1)}</FormLabel>
                  <FormControl>
                    <Slider
                      disabled={disabled}
                      min={0}
                      max={1}
                      step={0.1}
                      defaultValue={[temperature]}
                      onValueChange={(values) => {
                        const temp = values[0];
                        setTemperature(temp);
                        field.onChange(temp);
                      }}
                    />
                  </FormControl>
                  <FormDescription>
                    Lower values are more deterministic, higher values more creative
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <div className="space-y-6">
              <div className="p-4 border rounded-md bg-muted/10">
                <div className="flex items-center space-x-3 mb-5">
                  <div className="relative flex items-center justify-center h-5 w-5">
                    <Checkbox
                      id="unlimited-parallelism"
                      checked={unlimitedParallelism}
                      onCheckedChange={(checked) => {
                        setUnlimitedParallelism(checked === true);
                      }}
                      className="h-5 w-5"
                    />
                    {unlimitedParallelism && (
                      <div className="absolute inset-0 flex items-center justify-center text-primary-foreground pointer-events-none">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                          <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                      </div>
                    )}
                  </div>
                  <label
                    htmlFor="unlimited-parallelism"
                    className="text-sm font-medium leading-none cursor-pointer"
                  >
                    Unlimited parallelism (Process all URLs simultaneously)
                  </label>
                </div>
                {!unlimitedParallelism && (
                  <div className="pl-8"> {/* Indented under checkbox */}
                    <Label htmlFor="parallel-processing" className="block mb-2">
                      Parallel Processing: <span className="font-medium text-primary">{parallelProcessing} URLs</span>
                    </Label>
                    <div className="flex items-center space-x-4 mb-3">
                      <Slider
                        id="parallel-processing"
                        disabled={disabled}
                        min={1}
                        max={16}
                        step={1}
                        defaultValue={[parallelProcessing]}
                        value={[parallelProcessing]}
                        onValueChange={(values) => {
                          setParallelProcessing(values[0]);
                        }}
                        className="flex-grow"
                      />
                    </div>
                    <FormDescription className="text-xs mt-2">
                      Higher values process more URLs in parallel but use more system resources
                    </FormDescription>
                  </div>
                )}
              </div>
            </div>
            <div className="rounded-lg border p-4 bg-muted/20 mb-6">
              <div className="text-sm text-muted-foreground">
                Using maximum token context (120,000 tokens) for large document processing
              </div>
            </div>
          </CardContent>
          <CardFooter className="flex justify-between pt-6 space-x-4">
            <Button
              type="button"
              variant="outline"
              onClick={onCancel}
              disabled={disabled}
              className="min-w-24"
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={disabled}
              className="min-w-40 bg-primary"
            >
              Start Processing
            </Button>
          </CardFooter>
        </form>
      </Form>
    </Card>
  );
}
</file>

<file path="src/components/crawler/ProcessingPipeline.tsx">
import { useState, useRef, useEffect } from "react";
import { toast } from "sonner";
import { useVectorDB } from '../../hooks/useVectorDB';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { ProcessingStatus, DocumentSource, processBatch, TechDetails } from "@/lib/pipeline";
import { MarkdownCleanupValues } from "@/types/forms";
import { DocumentationCategory, FullDocumentationSnippet, getSession } from "@/lib/db";
import ProcessingOptions from "./ProcessingOptions";
interface ProcessingPipelineProps {
  urls: { id: number; url: string; html?: string; markdown?: string }[];
  apiKey: string;
  sessionId: number;
  category: DocumentationCategory;
  language?: string;
  languageVersion?: string;
  framework?: string;
  frameworkVersion?: string;
  library?: string;
  libraryVersion?: string;
  onComplete: (results: { url: string; snippets: FullDocumentationSnippet[] }[]) => void;
  onCancel: () => void;
}
export default function ProcessingPipeline({
  urls,
  apiKey,
  sessionId,
  category,
  language,
  languageVersion,
  framework,
  frameworkVersion,
  library,
  libraryVersion,
  onComplete,
  onCancel
}: ProcessingPipelineProps) {
  const [showOptions, setShowOptions] = useState(true);
  const [processing, setProcessing] = useState(false);
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [currentStatus, setCurrentStatus] = useState<ProcessingStatus>(ProcessingStatus.IDLE);
  const [progress, setProgress] = useState(0);
  const [processedCount, setProcessedCount] = useState(0);
  const processedUrlsRef = useRef(new Set<string>());
  const [results, setResults] = useState<{ url: string; snippets: FullDocumentationSnippet[] }[]>([]);
  // Check API key on component mount
  useEffect(() => {
    console.log("ProcessingPipeline component mounted with API key:", apiKey ? `${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}` : "No API key provided");
    if (!apiKey) {
      toast.error("OpenAI API key is missing. Please add your API key in Settings.", {
        id: "api-key-missing-pipeline",
        duration: 5000,
      });
      // Cancel processing if no API key is provided
      onCancel();
    }
  }, [apiKey, onCancel]);
  // Use the hook with sessionId
  const { 
    vectorDB, 
    loading: vectorDBLoading, 
    error: vectorDBError,
    addDocuments,
    isInitialized
  } = useVectorDB(sessionId);
  // Update the VectorDB with the API key when it changes
  useEffect(() => {
    if (vectorDB && apiKey) {
      // Check if the vectorDB has an updateApiKey method
      if (typeof vectorDB.updateApiKey === 'function') {
        try {
          console.log(`Updating VectorDB API key: ${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}`);
          vectorDB.updateApiKey(apiKey);
        } catch (error) {
          console.error("Error updating VectorDB API key:", error);
        }
      } else {
        console.log("VectorDB instance does not have an updateApiKey method");
      }
    }
  }, [vectorDB, apiKey]);
  // Cleanup effect is no longer needed since toasts have proper durations
  useEffect(() => {
    return () => {
      // No cleanup needed - toasts auto-dismiss
    };
  }, []);
  // Log the tech details when component mounts or props change
  useEffect(() => {
    console.log("ProcessingPipeline - Tech Details:");
    console.log(`Category: ${category}`);
    console.log(`Language: ${language}, Version: ${languageVersion}`);
    console.log(`Framework: ${framework}, Version: ${frameworkVersion}`);
    console.log(`Library: ${library}, Version: ${libraryVersion}`);
  }, [category, language, languageVersion, framework, frameworkVersion, library, libraryVersion]);
  const getStatusText = (status: ProcessingStatus) => {
    switch (status) {
      case ProcessingStatus.CONVERTING:
        return "Converting HTML to Markdown";
      case ProcessingStatus.CLEANING:
        return "Cleaning up Markdown with AI";
      case ProcessingStatus.CHUNKING:
        return "Processing into document snippets";
      case ProcessingStatus.EMBEDDING:
        return "Embedding and storing in Vector Database";
      case ProcessingStatus.COMPLETE:
        return "Processing complete";
      case ProcessingStatus.ERROR:
        return "Error during processing";
      default:
        return "Waiting to start";
    }
  };
  const handleStartProcessing = async (options: MarkdownCleanupValues & { parallelProcessing: number, unlimitedParallelism: boolean }) => {
    if (!apiKey || apiKey.trim() === "") {
      toast.error("OpenAI API key is missing. Please add your API key in Settings.", {
        id: "api-key-missing-start-processing",
        duration: 5000,
      });
      onCancel(); // Cancel processing if no API key is provided
      return;
    }
    // Log the API key (first and last few characters) for debugging
    console.log(`Starting processing with API key: ${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}`);
    if (vectorDBLoading) {
      toast.error("Vector database is still loading");
      return;
    }
    if (vectorDBError) {
      toast.error(`Vector database error: ${vectorDBError.message}`);
      return;
    }
    if (!vectorDB) {
      toast.error("Vector database is not initialized");
      return;
    }
    if (!isInitialized) {
      toast.error("Vector database is not available");
      return;
    }
    setShowOptions(false);
    setProcessing(true);
    setProgress(0);
    setProcessedCount(0);
    processedUrlsRef.current = new Set<string>();
    setResults([]);
    // Filter URLs that have markdown content
    const sourcesToProcess: DocumentSource[] = urls
      .filter(url => url.markdown)
      .map(url => ({
        url: url.url,
        markdown: url.markdown!,
        id: url.id
      }));
    console.log(`Found ${sourcesToProcess.length} URLs with markdown content to process`);
    console.log("URLs to process:", sourcesToProcess.map(s => s.url));
    if (sourcesToProcess.length === 0) {
      console.error("ERROR: No URLs with markdown content to process");
      toast.error("No URLs with markdown content to process");
      return;
    }
    try {
      console.log("Hiding options and starting processing");
      setShowOptions(false);
      setProcessing(true);
      // Get the session configuration
      const session = await getSession(sessionId);
      if (!session) {
        throw new Error("Session not found");
      }
      // Get tech details from props - this ensures we use the saved values
      const techDetails: TechDetails = {
        category,
        language,
        languageVersion,
        framework,
        frameworkVersion,
        library,
        libraryVersion
      };
      console.log("Tech details for processing:", techDetails);
      // Determine max concurrency based on user selection
      const maxConcurrency = options.unlimitedParallelism ? 
        sourcesToProcess.length : // Use all URLs if unlimited
        options.parallelProcessing; // Otherwise use user-specified value
      console.log(`Starting batch processing of URLs with max concurrency: ${maxConcurrency}`);
      // Process batch with the desired concurrency
      processBatch(
        sourcesToProcess,
        techDetails,
        apiKey,
        { addDocuments, isInitialized },
        {
          cleanupModel: options.model,
          temperature: options.temperature,
          maxTokens: options.maxTokens,
          extractConcepts: true,
          maxConcurrency
        },
        (url, status, statusProgress, overallProgress) => {
          console.log(`Processing status update: URL=${url}, status=${status}, statusProgress=${statusProgress}, overallProgress=${overallProgress}`);
          setCurrentUrl(url);
          setCurrentStatus(status);
          // Update processed count for every status update to keep the count current
          // This ensures the count updates in real-time and not just at the end
          if ((status === ProcessingStatus.COMPLETE || status === ProcessingStatus.ERROR) && !processedUrlsRef.current.has(url)) {
            // Only increment if this URL hasn't been processed before
            processedUrlsRef.current.add(url);
            setProcessedCount(prevCount => Math.min(prevCount + 1, urls.length));
            console.log(`URL ${url} completed. Processed count: ${processedUrlsRef.current.size}/${urls.length}`);
          }
          // Always use the overall progress for the UI if available
          if (overallProgress !== undefined) {
            setProgress(overallProgress);
          } else if (statusProgress !== undefined) {
            setProgress(statusProgress);
          }
        },
        async (results) => {
          console.log("✅ Processing complete:", results.length, "URLs processed");
          console.log("Results summary:", results.map(r => `${r.url}: ${r.snippets.length} snippets`));
          // Reset for next time
          processedUrlsRef.current.clear();
          // Make sure the final count doesn't exceed the total URLs
          const finalCount = Math.min(results.length, urls.length);
          setProcessedCount(finalCount);
          await handleProcessingComplete(results);
        }
      );
    } catch (error) {
      console.error("Failed to start processing:", error);
      toast.error(`Processing failed: ${error instanceof Error ? error.message : String(error)}`);
      setProcessing(false);
    }
  };
  const handleCancel = () => {
    setProcessing(false);
    onCancel();
  };
  const processDocuments = async (documents: FullDocumentationSnippet[]) => {
    if (!isInitialized) {
      console.error("Vector database is not available");
      return;
    }
    try {
      console.log(`Attempting to store ${documents.length} snippets in vector DB`);
      console.log('Snippet preview:', documents.map(d => ({ 
        id: d.id,
        source_url: d.source_url,
        contentPreview: d.content.substring(0, 100) + '...' 
      })));
      // Use the addDocuments function from the hook
      const result = await addDocuments(documents);
      console.log(`Vector DB storage result:`, result);
      console.log(`Successfully stored ${documents.length} snippets in vector DB`);
      return true;
    } catch (error) {
      console.error("Error adding documents to vector database:", error);
      console.error("Full error details:", {
        name: (error as Error).name,
        message: (error as Error).message,
        stack: (error as Error).stack
      });
      return false;
    }
  };
  const handleProcessingComplete = async (results: any) => {
    // Get the URLs that were successfully processed
    const newProcessedUrls = results
      .filter((result: any) => result.success)
      .map((result: any) => result.url);
    // Only show toast for small batches to reduce notification overload
    if (newProcessedUrls.length <= 3) {
      toast.success(`Processed ${newProcessedUrls.length} URLs successfully`, { 
        duration: 2000,
        id: "processing-success" // Use unique ID to prevent duplicates
      });
    }
    setProcessing(false);
    onComplete(results);
  };
  // Show loading state if vector DB is still initializing
  if (vectorDBLoading) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Processing</CardTitle>
          <CardDescription>
            Initializing vector database...
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-2 w-full bg-secondary overflow-hidden rounded-full">
            <div className="h-full bg-primary animate-pulse" style={{ width: '100%' }}></div>
          </div>
        </CardContent>
      </Card>
    );
  }
  // Show error state if vector DB failed to initialize
  if (vectorDBError) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Error</CardTitle>
          <CardDescription>
            Failed to initialize vector database
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="p-4 border border-red-200 bg-red-50 text-red-800 rounded-md">
            {vectorDBError.message}
          </div>
          <div className="mt-4 flex justify-end">
            <Button onClick={onCancel}>Cancel</Button>
          </div>
        </CardContent>
      </Card>
    );
  }
  return (
    <div className="space-y-4">
      {showOptions ? (
        <ProcessingOptions 
          onSubmit={handleStartProcessing}
          onCancel={onCancel}
          disabled={processing}
        />
      ) : (
        <Card className="w-full">
          <CardHeader>
            <CardTitle>Processing</CardTitle>
            <CardDescription>
              Processing crawled content into documentation snippets
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-4">
              <div className="flex flex-col space-y-1">
                <div className="flex justify-between">
                  <Label>Current URL</Label>
                  <div className="text-sm text-muted-foreground">
                    {processedCount}/{urls.length} URLs
                  </div>
                </div>
                <div className="p-2 border rounded-md bg-muted/50 break-all">
                  {currentUrl ? currentUrl : "Waiting to start..."}
                </div>
              </div>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <Label>Status</Label>
                  <div className="text-sm font-medium">
                    {getStatusText(currentStatus)}
                  </div>
                </div>
                <div className="h-2 w-full bg-secondary overflow-hidden rounded-full">
                  <div
                    className="h-full bg-primary transition-all duration-300"
                    style={{ width: `${Math.min(progress * 100, 100)}%` }}
                  ></div>
                </div>
                <div className="text-xs text-right text-muted-foreground">
                  {Math.min(Math.round(progress * 100), 100)}%
                </div>
              </div>
              <div className="pt-4">
                <div className="rounded-md border p-3 bg-muted/50">
                  <h4 className="text-sm font-medium mb-2">Processing Details</h4>
                  <div className="space-y-1 text-xs">
                    <div className="flex justify-between">
                      <span>Category:</span>
                      <span className="font-mono">{category}</span>
                    </div>
                    {language && (
                      <div className="flex justify-between">
                        <span>Language:</span>
                        <span className="font-mono">{language} {languageVersion}</span>
                      </div>
                    )}
                    {framework && (
                      <div className="flex justify-between">
                        <span>Framework:</span>
                        <span className="font-mono">{framework} {frameworkVersion}</span>
                      </div>
                    )}
                    {library && (
                      <div className="flex justify-between">
                        <span>Library:</span>
                        <span className="font-mono">{library} {libraryVersion}</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>
              <div className="flex justify-center pt-4">
                <Button
                  variant="outline"
                  onClick={handleCancel}
                >
                  Cancel Processing
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/crawler/SnippetViewer.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import { Badge } from "../ui/badge";
import { ChevronLeft, ExternalLink } from "lucide-react";
interface SnippetViewerProps {
  url: string | null;
  snippets: any[];
  loading: boolean;
  error: string | null;
  onBack: () => void;
}
export default function SnippetViewer({ url, snippets, loading, error, onBack }: SnippetViewerProps) {
  if (!url) {
    return null;
  }
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={onBack} 
          className="flex items-center space-x-1"
        >
          <ChevronLeft className="h-4 w-4" />
          <span>Back to URLs</span>
        </Button>
        <a 
          href={url}
          target="_blank"
          rel="noopener noreferrer"
          className="inline-flex items-center text-sm text-primary hover:underline"
        >
          Visit page <ExternalLink className="h-3 w-3 ml-1" />
        </a>
      </div>
      <Card>
        <CardHeader className="pb-3">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-lg font-medium">Snippets</CardTitle>
              <CardDescription className="text-sm truncate" title={url}>
                {url}
              </CardDescription>
            </div>
            <Badge variant="outline">
              {snippets.length} {snippets.length === 1 ? 'snippet' : 'snippets'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="flex justify-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
            </div>
          ) : error ? (
            <div className="p-4 border border-destructive/30 bg-destructive/10 text-destructive rounded-md">
              Error: {error}
            </div>
          ) : snippets.length === 0 ? (
            <div className="p-4 border border-muted rounded-md text-muted-foreground">
              No snippets found for this URL.
            </div>
          ) : (
            <ScrollArea className="h-[400px] pr-4">
              <Accordion type="single" collapsible className="space-y-4">
                {snippets.map((snippet, index) => (
                  <AccordionItem 
                    key={snippet.id || index} 
                    value={snippet.id || `snippet-${index}`}
                    className="border rounded-md px-4"
                  >
                    <AccordionTrigger className="py-3 text-left hover:no-underline">
                      <div className="flex flex-col items-start">
                        <h3 className="font-medium">{snippet.title}</h3>
                        {snippet.description && (
                          <p className="text-sm text-muted-foreground mt-1 line-clamp-2">
                            {snippet.description}
                          </p>
                        )}
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="pb-4 pt-2">
                      <div className="space-y-4">
                        <div className="grid grid-cols-2 gap-2 text-xs text-muted-foreground">
                          <div>
                            <span className="font-medium">Category:</span> {snippet.category}
                          </div>
                          {snippet.language && (
                            <div>
                              <span className="font-medium">Language:</span> {snippet.language} {snippet.language_version}
                            </div>
                          )}
                          {snippet.framework && (
                            <div>
                              <span className="font-medium">Framework:</span> {snippet.framework} {snippet.framework_version}
                            </div>
                          )}
                          {snippet.library && (
                            <div>
                              <span className="font-medium">Library:</span> {snippet.library} {snippet.library_version}
                            </div>
                          )}
                        </div>
                        <div className="p-3 bg-muted rounded-md overflow-auto">
                          <pre className="text-sm whitespace-pre-wrap">
                            {snippet.content}
                          </pre>
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </ScrollArea>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/crawler/TechDetailsForm.tsx">
import { useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { DocumentationCategory } from "@/lib/db";
interface TechDetailsFormProps {
  onSubmit: (details: {
    category: DocumentationCategory;
    language?: string;
    languageVersion?: string;
    framework?: string;
    frameworkVersion?: string;
    library?: string;
    libraryVersion?: string;
  }) => void;
  onCancel: () => void;
}
export default function TechDetailsForm({
  onSubmit,
  onCancel,
}: TechDetailsFormProps) {
  const [category, setCategory] = useState<DocumentationCategory>(
    DocumentationCategory.LANGUAGE
  );
  const [language, setLanguage] = useState("");
  const [languageVersion, setLanguageVersion] = useState("");
  const [framework, setFramework] = useState("");
  const [frameworkVersion, setFrameworkVersion] = useState("");
  const [library, setLibrary] = useState("");
  const [libraryVersion, setLibraryVersion] = useState("");
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Construct the tech details object based on the selected category
    const details: {
      category: DocumentationCategory;
      language?: string;
      languageVersion?: string;
      framework?: string;
      frameworkVersion?: string;
      library?: string;
      libraryVersion?: string;
    } = { category };
    // Always include language for any category
    if (language) {
      details.language = language;
      if (languageVersion) details.languageVersion = languageVersion;
    }
    // Add framework details if category is framework or for library context
    if (category === DocumentationCategory.FRAMEWORK || 
        (category === DocumentationCategory.LIBRARY && framework)) {
      details.framework = framework;
      if (frameworkVersion) details.frameworkVersion = frameworkVersion;
    }
    // Add library details if category is library
    if (category === DocumentationCategory.LIBRARY) {
      details.library = library;
      if (libraryVersion) details.libraryVersion = libraryVersion;
    }
    onSubmit(details);
  };
  return (
    <Card>
      <CardHeader>
        <CardTitle>Technology Details</CardTitle>
        <CardDescription>
          Specify the programming language, framework, or library details
        </CardDescription>
      </CardHeader>
      <form onSubmit={handleSubmit}>
        <CardContent className="space-y-6">
          <div className="space-y-2">
            <Label>Documentation Category</Label>
            <Select
              value={category}
              onValueChange={(value) => setCategory(value as DocumentationCategory)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={DocumentationCategory.LANGUAGE}>
                  Programming Language
                </SelectItem>
                <SelectItem value={DocumentationCategory.FRAMEWORK}>
                  Framework
                </SelectItem>
                <SelectItem value={DocumentationCategory.LIBRARY}>
                  Library
                </SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-2">
            <Label htmlFor="language">Programming Language</Label>
            <Input
              id="language"
              placeholder="e.g., Python, JavaScript"
              value={language}
              onChange={(e) => setLanguage(e.target.value)}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="languageVersion">Language Version (optional)</Label>
            <Input
              id="languageVersion"
              placeholder="e.g., 3.10, ES2022"
              value={languageVersion}
              onChange={(e) => setLanguageVersion(e.target.value)}
            />
          </div>
          {(category === DocumentationCategory.FRAMEWORK ||
            category === DocumentationCategory.LIBRARY) && (
            <>
              <div className="space-y-2">
                <Label htmlFor="framework">
                  {category === DocumentationCategory.FRAMEWORK
                    ? "Framework Name"
                    : "Framework (optional)"}
                </Label>
                <Input
                  id="framework"
                  placeholder="e.g., React, Django"
                  value={framework}
                  onChange={(e) => setFramework(e.target.value)}
                  required={category === DocumentationCategory.FRAMEWORK}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="frameworkVersion">
                  Framework Version (optional)
                </Label>
                <Input
                  id="frameworkVersion"
                  placeholder="e.g., 18.2.0, 4.2"
                  value={frameworkVersion}
                  onChange={(e) => setFrameworkVersion(e.target.value)}
                />
              </div>
            </>
          )}
          {category === DocumentationCategory.LIBRARY && (
            <>
              <div className="space-y-2">
                <Label htmlFor="library">Library Name</Label>
                <Input
                  id="library"
                  placeholder="e.g., lodash, pandas"
                  value={library}
                  onChange={(e) => setLibrary(e.target.value)}
                  required
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="libraryVersion">
                  Library Version (optional)
                </Label>
                <Input
                  id="libraryVersion"
                  placeholder="e.g., 4.17.21, 2.0.3"
                  value={libraryVersion}
                  onChange={(e) => setLibraryVersion(e.target.value)}
                />
              </div>
            </>
          )}
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button type="submit">Save Details</Button>
        </CardFooter>
      </form>
    </Card>
  );
}
</file>

<file path="src/components/crawler/URLDetailModal.tsx">
import { useState, useEffect } from "react";
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogHeader, 
  DialogTitle,
  DialogFooter
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import { CrawlURL } from "@/lib/db";
interface URLDetailModalProps {
  url: CrawlURL | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
export default function URLDetailModal({ url, open, onOpenChange }: URLDetailModalProps) {
  const [activeTab, setActiveTab] = useState("info");
  // Reset tab when URL changes
  useEffect(() => {
    if (url) {
      setActiveTab("info");
    }
  }, [url]);
  if (!url) {
    return null;
  }
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'pending':
        return 'secondary';
      case 'crawled':
        return 'default';
      case 'error':
        return 'destructive';
      case 'skipped':
        return 'outline';
      default:
        return 'secondary';
    }
  };
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[80vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>URL Details</DialogTitle>
          <DialogDescription className="font-mono text-xs break-all">
            {url.url}
          </DialogDescription>
        </DialogHeader>
        <div className="flex items-center space-x-2 my-2">
          <span className="text-sm font-medium">Status:</span>
          <Badge variant={getStatusColor(url.status)}>
            {url.status}
          </Badge>
          {url.id && (
            <span className="text-xs text-muted-foreground ml-auto">ID: {url.id}</span>
          )}
        </div>
        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col">
          <TabsList>
            <TabsTrigger value="info">Info</TabsTrigger>
            {url.html && <TabsTrigger value="html">HTML</TabsTrigger>}
            {url.markdown && <TabsTrigger value="markdown">Markdown</TabsTrigger>}
            {url.cleaned_markdown && <TabsTrigger value="cleaned">Cleaned Markdown</TabsTrigger>}
          </TabsList>
          <TabsContent value="info" className="flex-1 border rounded-md p-4 mt-2">
            <div className="space-y-4">
              <div>
                <h3 className="text-sm font-medium">URL</h3>
                <p className="font-mono text-xs break-all">{url.url}</p>
              </div>
              <div>
                <h3 className="text-sm font-medium">Status</h3>
                <p>{url.status}</p>
              </div>
              <div>
                <h3 className="text-sm font-medium">Content Status</h3>
                <div className="space-y-1">
                  <div className="flex items-center">
                    <span className="text-xs">HTML:</span>
                    <Badge variant={url.html ? "default" : "outline"} className="ml-2">
                      {url.html ? "Available" : "Not Available"}
                    </Badge>
                    {url.html && (
                      <span className="text-xs ml-2">
                        ({(url.html.length / 1024).toFixed(1)} KB)
                      </span>
                    )}
                  </div>
                  <div className="flex items-center">
                    <span className="text-xs">Markdown:</span>
                    <Badge variant={url.markdown ? "default" : "outline"} className="ml-2">
                      {url.markdown ? "Available" : "Not Available"}
                    </Badge>
                    {url.markdown && (
                      <span className="text-xs ml-2">
                        ({(url.markdown.length / 1024).toFixed(1)} KB)
                      </span>
                    )}
                  </div>
                  <div className="flex items-center">
                    <span className="text-xs">Cleaned Markdown:</span>
                    <Badge variant={url.cleaned_markdown ? "default" : "outline"} className="ml-2">
                      {url.cleaned_markdown ? "Available" : "Not Available"}
                    </Badge>
                    {url.cleaned_markdown && (
                      <span className="text-xs ml-2">
                        ({(url.cleaned_markdown.length / 1024).toFixed(1)} KB)
                      </span>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </TabsContent>
          {url.html && (
            <TabsContent value="html" className="flex-1 border rounded-md mt-2">
              <ScrollArea className="h-[400px] w-full">
                <pre className="p-4 text-xs font-mono whitespace-pre-wrap">{url.html}</pre>
              </ScrollArea>
            </TabsContent>
          )}
          {url.markdown && (
            <TabsContent value="markdown" className="flex-1 border rounded-md mt-2">
              <ScrollArea className="h-[400px] w-full">
                <pre className="p-4 text-xs font-mono whitespace-pre-wrap">{url.markdown}</pre>
              </ScrollArea>
            </TabsContent>
          )}
          {url.cleaned_markdown && (
            <TabsContent value="cleaned" className="flex-1 border rounded-md mt-2">
              <ScrollArea className="h-[400px] w-full">
                <pre className="p-4 text-xs font-mono whitespace-pre-wrap">{url.cleaned_markdown}</pre>
              </ScrollArea>
            </TabsContent>
          )}
        </Tabs>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/crawler/UrlInput.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Form, FormField, FormItem, FormControl, FormMessage } from "@/components/ui/form";
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { urlFormSchema, type UrlFormValues } from "@/types/forms";
import { shouldCrawlURL } from "@/lib/crawler";
interface UrlInputProps {
  sessionId: number;
  prefixPath?: string;
  antiPaths?: string[];
  antiKeywords?: string[];
  onUrlAdded: (url: string) => void;
  disabled?: boolean;
}
export default function UrlInput({
  sessionId,
  prefixPath = "",
  antiPaths = [],
  antiKeywords = [],
  onUrlAdded,
  disabled = false
}: UrlInputProps) {
  const [submitting, setSubmitting] = useState(false);
  const form = useForm<UrlFormValues>({
    resolver: zodResolver(urlFormSchema),
    defaultValues: {
      url: ""
    }
  });
  const onSubmit = async (data: UrlFormValues) => {
    try {
      setSubmitting(true);
      // Check if URL matches crawler criteria
      if (prefixPath && !data.url.startsWith(prefixPath)) {
        toast.error(`URL must begin with "${prefixPath}"`);
        return;
      }
      const isAllowed = shouldCrawlURL(data.url, {
        startUrl: data.url,
        prefixPath,
        antiPaths,
        antiKeywords,
        sessionId
      });
      if (!isAllowed) {
        toast.error("URL doesn't match crawler criteria (contains anti-paths or anti-keywords)");
        return;
      }
      // Add the URL
      onUrlAdded(data.url);
      // Reset form
      form.reset();
      toast.success("URL added successfully");
    } catch (error) {
      console.error("Error adding URL:", error);
      toast.error("Failed to add URL. Please try again.");
    } finally {
      setSubmitting(false);
    }
  };
  return (
    <Card>
      <CardHeader>
        <CardTitle>Add URL</CardTitle>
        <CardDescription>Add a URL to crawl</CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="flex items-center gap-2">
            <div className="flex-1">
              <FormField
                control={form.control}
                name="url"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        placeholder={prefixPath || "https://example.com"}
                        {...field}
                        disabled={disabled || submitting}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <Button 
              type="submit" 
              disabled={disabled || submitting}
            >
              {submitting ? "Adding..." : "Add URL"}
            </Button>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/crawler/URLList.tsx">
import { useState, useEffect, useRef } from "react";
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from "../ui/table";
import { Badge } from "../ui/badge";
import { Checkbox } from "../ui/checkbox";
import { Input } from "../ui/input";
import { Button } from "../ui/button";
import { ScrollArea } from "../ui/scroll-area";
import { 
  getURLs, 
  CrawlURL, 
  cleanupDuplicateURLs, 
  deleteAllURLs, 
  getURLByUrl,
  getURLsMatchingAntiPatterns,
  deleteURLsMatchingAntiPatterns
} from "../../lib/db";
import { 
  RefreshCw, 
  Trash2, 
  AlertTriangle, 
  Eye,
  FilterX
} from "lucide-react";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "../ui/alert-dialog";
import URLDetailModal from "./URLDetailModal";
import { Switch } from "../ui/switch";
import { Label } from "../ui/label";
import { getCrawlSettings } from "../../lib/db";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../ui/select";
// Removed popover imports as they're no longer needed
interface URLListProps {
  sessionId: number;
  onStartCrawling: (urls: string[]) => void;
  refreshTrigger?: number;
  isCrawling?: boolean;
}
// Status types for URL filtering
type StatusFilter = 'all' | 'pending' | 'crawled' | 'processed' | 'error' | 'skipped';
// Crawling behavior options
interface CrawlOptions {
  skipProcessed: boolean;
  crawlPendingOnly: boolean;
  statusFilter: StatusFilter;
}
export default function URLList({ sessionId, onStartCrawling, refreshTrigger = 0, isCrawling = false }: URLListProps) {
  const [urls, setUrls] = useState<CrawlURL[]>([]);
  const [filteredUrls, setFilteredUrls] = useState<CrawlURL[]>([]);
  const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [initialLoadComplete, setInitialLoadComplete] = useState(false);
  const [filter, setFilter] = useState("");
  const [selectAll, setSelectAll] = useState(false);
  const [duplicateUrlMap, setDuplicateUrlMap] = useState<Record<string, number>>({});
  const [cleaningUp, setCleaningUp] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [detailModalOpen, setDetailModalOpen] = useState(false);
  const [selectedUrlDetail, setSelectedUrlDetail] = useState<CrawlURL | null>(null);
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true);
  const urlListContainerRef = useRef<HTMLDivElement>(null);
  // Crawl options state
  const [crawlOptions, setCrawlOptions] = useState<CrawlOptions>({
    skipProcessed: true,
    crawlPendingOnly: false,
    statusFilter: 'all'
  });
  // Anti-pattern filtering state
  const [antiPatternDialogOpen, setAntiPatternDialogOpen] = useState(false);
  const [antiPatternFiltering, setAntiPatternFiltering] = useState(false);
  const [urlsMatchingAntiPatterns, setUrlsMatchingAntiPatterns] = useState<CrawlURL[]>([]);
  const [antiPatternLoading, setAntiPatternLoading] = useState(false);
  // Initial load of URLs
  const loadURLs = async (showLoading = true) => {
    try {
      if (showLoading) {
        setLoading(true);
      }
      const data = await getURLs(sessionId, false); // Don't include content
      setUrls(data);
      // Apply current filter
      if (filter) {
        const filtered = data.filter(url => 
          url.url.toLowerCase().includes(filter.toLowerCase())
        );
        setFilteredUrls(filtered);
      } else {
        setFilteredUrls(data);
      }
      // Find duplicate URLs
      const urlCounts: Record<string, number> = {};
      data.forEach(item => {
        urlCounts[item.url] = (urlCounts[item.url] || 0) + 1;
      });
      // Filter to only URLs that appear more than once
      const duplicates: Record<string, number> = {};
      Object.entries(urlCounts).forEach(([url, count]) => {
        if (count > 1) {
          duplicates[url] = count;
        }
      });
      setDuplicateUrlMap(duplicates);
      setInitialLoadComplete(true);
    } catch (error) {
      console.error("Failed to load URLs:", error);
    } finally {
      if (showLoading) {
        setLoading(false);
      }
    }
  };
  // Check for new URLs without full reload
  const refreshUrlsIncremental = async () => {
    if (!sessionId || !initialLoadComplete) return;
    try {
      const data = await getURLs(sessionId, false); // Don't include content
      // Only update if we have new URLs or changes
      if (data.length !== urls.length) {
        // Get the new URLs
        const existingUrlSet = new Set(urls.map(u => u.url));
        const newUrls = data.filter(url => !existingUrlSet.has(url.url));
        if (newUrls.length > 0) {
          console.log(`Found ${newUrls.length} new URLs`);
          // Update the URLs array without resetting scroll or showing loading
          setUrls(data);
          // Apply current filter to the new list
          if (filter) {
            const filtered = data.filter(url => 
              url.url.toLowerCase().includes(filter.toLowerCase())
            );
            setFilteredUrls(filtered);
          } else {
            setFilteredUrls(data);
          }
          // Update duplicate map
          const urlCounts: Record<string, number> = {};
          data.forEach(item => {
            urlCounts[item.url] = (urlCounts[item.url] || 0) + 1;
          });
          const duplicates: Record<string, number> = {};
          Object.entries(urlCounts).forEach(([url, count]) => {
            if (count > 1) {
              duplicates[url] = count;
            }
          });
          setDuplicateUrlMap(duplicates);
        } else {
          // Check for URL status changes
          const hasStatusChanges = data.some((newUrl, index) => {
            const oldUrl = urls[index];
            return oldUrl && oldUrl.url === newUrl.url && oldUrl.status !== newUrl.status;
          });
          if (hasStatusChanges) {
            console.log("URL statuses have changed, updating");
            setUrls(data);
            // Apply current filter to the new list
            if (filter) {
              const filtered = data.filter(url => 
                url.url.toLowerCase().includes(filter.toLowerCase())
              );
              setFilteredUrls(filtered);
            } else {
              setFilteredUrls(data);
            }
          }
        }
      }
    } catch (error) {
      console.error("Failed to refresh URLs incrementally:", error);
    }
  };
  const handleFilterChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.toLowerCase();
    setFilter(value);
    if (!value) {
      setFilteredUrls(urls);
    } else {
      const filtered = urls.filter(url => 
        url.url.toLowerCase().includes(value)
      );
      setFilteredUrls(filtered);
    }
  };
  const handleSelectAll = () => {
    if (selectAll) {
      setSelectedUrls([]);
    } else {
      setSelectedUrls(filteredUrls.map(url => url.url));
    }
    setSelectAll(!selectAll);
  };
  const handleSelectURL = (url: string, checked: boolean) => {
    if (checked) {
      setSelectedUrls(prev => [...prev, url]);
    } else {
      setSelectedUrls(prev => prev.filter(u => u !== url));
    }
  };
  // Status filter is applied in the UI
  const getStatusColor = (status: string): "default" | "destructive" | "outline" | "secondary" => {
    switch (status) {
      case 'pending':
        return 'secondary';
      case 'crawled':
        return 'default';
      case 'error':
        return 'destructive';
      case 'skipped':
        return 'outline';
      case 'processed':
        return 'default'; // Changed from 'success' to 'default' since success variant isn't available
      default:
        return 'secondary';
    }
  };
  const handleStartCrawling = () => {
    if (selectedUrls.length === 0) {
      toast.error("No URLs selected for crawling");
      return;
    }
    // Apply crawl options to filter the selected URLs
    let urlsToCrawl = [...selectedUrls];
    if (crawlOptions.skipProcessed || crawlOptions.crawlPendingOnly) {
      // Get the actual URL objects for the selected URLs
      const selectedUrlObjects = urls.filter(url => selectedUrls.includes(url.url));
      // Apply filters based on options
      const filteredUrlObjects = selectedUrlObjects.filter(url => {
        if (crawlOptions.skipProcessed && url.status === 'processed') {
          return false;
        }
        if (crawlOptions.crawlPendingOnly && url.status !== 'pending') {
          return false;
        }
        return true;
      });
      // Convert back to URL strings
      urlsToCrawl = filteredUrlObjects.map(url => url.url);
      if (urlsToCrawl.length === 0) {
        toast.error("No URLs match your crawl options. Adjust your options or selection.");
        return;
      }
      if (urlsToCrawl.length !== selectedUrls.length) {
        toast.info(`Crawling ${urlsToCrawl.length} of ${selectedUrls.length} selected URLs based on your options.`);
      }
    }
    onStartCrawling(urlsToCrawl);
  };
  const handleCleanupDuplicates = async () => {
    if (Object.keys(duplicateUrlMap).length === 0) return;
    try {
      setCleaningUp(true);
      const removedCount = await cleanupDuplicateURLs(sessionId);
      toast.success(`Removed ${removedCount} duplicate URLs`);
      loadURLs(true);
    } catch (error) {
      console.error("Error cleaning up duplicates:", error);
      toast.error("Failed to clean up duplicates");
    } finally {
      setCleaningUp(false);
    }
  };
  const handleDeleteAllUrls = async () => {
    try {
      setDeleting(true);
      const deletedCount = await deleteAllURLs(sessionId);
      setDeleteDialogOpen(false);
      toast.success(`Deleted ${deletedCount} URLs`);
      loadURLs(true);
    } catch (error) {
      console.error("Error deleting all URLs:", error);
      toast.error("Failed to delete all URLs");
    } finally {
      setDeleting(false);
    }
  };
  const handleViewDetails = async (url: CrawlURL) => {
    try {
      // Always fetch the full URL data since our list now only contains metadata
      const fullUrl = await getURLByUrl(sessionId, url.url);
      if (fullUrl) {
        setSelectedUrlDetail(fullUrl);
      } else {
        setSelectedUrlDetail(url);
      }
      setDetailModalOpen(true);
    } catch (error) {
      console.error("Error fetching URL details:", error);
      toast.error("Failed to load URL details");
    }
  };
  useEffect(() => {
    loadURLs();
  }, [sessionId]);
  useEffect(() => {
    if (refreshTrigger > 0) {
      loadURLs();
    }
  }, [refreshTrigger]);
  // Create a derived state of the filtered URLs to display URL counts by status
  const getUrlCountsByStatus = () => {
    const counts = {
      all: urls.length,
      pending: 0,
      crawled: 0,
      error: 0,
      skipped: 0,
      processed: 0
    };
    urls.forEach(url => {
      counts[url.status as keyof typeof counts] += 1;
    });
    return counts;
  };
  const urlCountsByStatus = getUrlCountsByStatus();
  // Handle status filter change
  const handleStatusFilterChange = (value: string) => {
    setCrawlOptions(prev => ({
      ...prev,
      statusFilter: value as StatusFilter
    }));
    // Apply the new filter
    if (value === 'all') {
      if (filter) {
        const filtered = urls.filter(url => 
          url.url.toLowerCase().includes(filter.toLowerCase())
        );
        setFilteredUrls(filtered);
      } else {
        setFilteredUrls(urls);
      }
    } else {
      const statusFiltered = urls.filter(url => url.status === value);
      if (filter) {
        const filtered = statusFiltered.filter(url => 
          url.url.toLowerCase().includes(filter.toLowerCase())
        );
        setFilteredUrls(filtered);
      } else {
        setFilteredUrls(statusFiltered);
      }
    }
    // Clear selections when filter changes
    setSelectedUrls([]);
    setSelectAll(false);
  };
  // Handle crawl option changes
  const handleCrawlOptionChange = (option: keyof CrawlOptions, value: boolean) => {
    setCrawlOptions(prev => ({
      ...prev,
      [option]: value
    }));
  };
  // Delete URLs matching anti-patterns
  const handleDeleteAntiPatternUrls = async () => {
    try {
      setAntiPatternFiltering(true);
      // Get crawler settings
      const settings = await getCrawlSettings(sessionId);
      if (!settings) {
        toast.error("Failed to load crawler settings");
        return;
      }
      // Parse anti-patterns
      const antiPaths = (settings.anti_paths || "")
        .split(",")
        .filter(Boolean)
        .map(path => path.trim());
      const antiKeywords = (settings.anti_keywords || "")
        .split(",")
        .filter(Boolean)
        .map(keyword => keyword.trim());
      // Delete matching URLs
      const deletedCount = await deleteURLsMatchingAntiPatterns(
        sessionId, 
        antiPaths, 
        antiKeywords
      );
      // Close dialog and refresh
      setAntiPatternDialogOpen(false);
      loadURLs(true);
      // Show success message
      toast.success(`Removed ${deletedCount} URLs matching anti-patterns`);
    } catch (error) {
      console.error("Error deleting URLs matching anti-patterns:", error);
      toast.error("Failed to delete URLs matching anti-patterns");
    } finally {
      setAntiPatternFiltering(false);
    }
  };
  // Set up interval for automatic refresh if enabled
  useEffect(() => {
    if (!autoRefreshEnabled || !initialLoadComplete) return;
    const intervalId = setInterval(() => {
      if (isCrawling) {
        refreshUrlsIncremental();
      }
    }, 3000); // Refresh every 3 seconds
    return () => clearInterval(intervalId);
  }, [autoRefreshEnabled, isCrawling, sessionId, initialLoadComplete, urls, filter]);
  // Load the list of URLs matching anti-patterns
  const loadAntiPatternUrls = async () => {
    try {
      setAntiPatternLoading(true);
      // Get crawler settings
      const settings = await getCrawlSettings(sessionId);
      if (!settings) {
        toast.error("Failed to load crawler settings");
        return;
      }
      // Parse anti-patterns
      const antiPaths = (settings.anti_paths || "")
        .split(",")
        .filter(Boolean)
        .map(path => path.trim());
      const antiKeywords = (settings.anti_keywords || "")
        .split(",")
        .filter(Boolean)
        .map(keyword => keyword.trim());
      // Get matching URLs
      if (antiPaths.length === 0 && antiKeywords.length === 0) {
        toast.error("No anti-patterns defined in crawler settings");
        return;
      }
      const matchingUrls = await getURLsMatchingAntiPatterns(
        sessionId, 
        antiPaths, 
        antiKeywords
      );
      setUrlsMatchingAntiPatterns(matchingUrls);
      setAntiPatternDialogOpen(true);
    } catch (error) {
      console.error("Error loading URLs matching anti-patterns:", error);
      toast.error("Failed to load URLs matching anti-patterns");
    } finally {
      setAntiPatternLoading(false);
    }
  };
  return (
    <div ref={urlListContainerRef}>
      <div className="flex flex-wrap items-center gap-2 mb-4">
        <div className="flex-1 min-w-[300px]">
          <Input
            placeholder="Filter URLs..."
            value={filter}
            onChange={handleFilterChange}
          />
        </div>
        <div className="flex items-center gap-2">
          <div className="flex items-center">
            <Label className="mr-2 text-sm" htmlFor="status-filter">Status:</Label>
            <Select 
              value={crawlOptions.statusFilter} 
              onValueChange={handleStatusFilterChange}
            >
              <SelectTrigger id="status-filter" className="w-[150px]">
                <SelectValue placeholder="Select status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All ({urlCountsByStatus.all})</SelectItem>
                <SelectItem value="pending">Pending ({urlCountsByStatus.pending})</SelectItem>
                <SelectItem value="crawled">Crawled ({urlCountsByStatus.crawled})</SelectItem>
                <SelectItem value="processed">Processed ({urlCountsByStatus.processed})</SelectItem>
                <SelectItem value="error">Error ({urlCountsByStatus.error})</SelectItem>
                <SelectItem value="skipped">Skipped ({urlCountsByStatus.skipped})</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="border p-3 rounded-md space-y-2 ml-2">
            <h4 className="text-sm font-medium mb-2">Crawl Options</h4>
            <div className="flex items-center space-x-2">
              <Checkbox 
                id="skip-processed" 
                checked={crawlOptions.skipProcessed}
                onCheckedChange={(checked) => 
                  handleCrawlOptionChange('skipProcessed', checked === true)
                }
              />
              <Label htmlFor="skip-processed" className="cursor-pointer text-sm">Skip already processed URLs</Label>
            </div>
            <div className="flex items-center space-x-2">
              <Checkbox 
                id="pending-only" 
                checked={crawlOptions.crawlPendingOnly}
                onCheckedChange={(checked) => 
                  handleCrawlOptionChange('crawlPendingOnly', checked === true)
                }
              />
              <Label htmlFor="pending-only" className="cursor-pointer text-sm">Only crawl URLs with 'pending' status</Label>
            </div>
          </div>
          <div className="flex items-center space-x-2 ml-2">
            <Switch 
              id="auto-refresh" 
              checked={autoRefreshEnabled}
              onCheckedChange={setAutoRefreshEnabled}
            />
            <Label htmlFor="auto-refresh">Auto-refresh</Label>
          </div>
        </div>
      </div>
      <div className="bg-muted p-2 rounded-md mb-4 flex justify-between items-center">
        <div className="text-sm">
          <span>{filteredUrls.length} URLs</span>
          {selectedUrls.length > 0 && <span> ({selectedUrls.length} selected)</span>}
        </div>
        <div className="flex gap-1">
          <Button
            variant="outline"
            size="sm"
            onClick={handleSelectAll}
            disabled={filteredUrls.length === 0}
          >
            {selectAll ? "Deselect All" : "Select All"}
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => loadURLs(true)}
            disabled={loading}
            title="Refresh URL list"
          >
            <RefreshCw className="h-4 w-4" />
          </Button>
          {Object.keys(duplicateUrlMap).length > 0 && (
            <Button
              variant="outline"
              size="sm"
              onClick={handleCleanupDuplicates}
              disabled={cleaningUp}
              title={`${Object.keys(duplicateUrlMap).length} duplicate URLs found`}
              className="bg-amber-100 dark:bg-amber-900 text-amber-900 dark:text-amber-100 hover:bg-amber-200 dark:hover:bg-amber-800"
            >
              <div className="flex items-center">
                <Trash2 className="h-4 w-4 mr-1" />
                <span>Clean Up Duplicates</span>
              </div>
            </Button>
          )}
          <Button
            variant="outline"
            size="sm"
            onClick={loadAntiPatternUrls}
            disabled={antiPatternLoading}
            title="Filter URLs matching anti-patterns"
            className="bg-blue-100 dark:bg-blue-900 text-blue-900 dark:text-blue-100 hover:bg-blue-200 dark:hover:bg-blue-800"
          >
            <FilterX className="h-4 w-4 mr-1" />
            <span>Filter Anti-patterns</span>
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setDeleteDialogOpen(true)}
            disabled={urls.length === 0 || deleting}
            className="bg-destructive/10 hover:bg-destructive/20 text-destructive hover:text-destructive"
            title="Delete all URLs"
          >
            <AlertTriangle className="h-4 w-4 mr-1" />
            <span>Delete All</span>
          </Button>
          <Button 
            size="sm"
            onClick={handleStartCrawling}
            disabled={selectedUrls.length === 0}
          >
            Start Crawling ({selectedUrls.length})
          </Button>
        </div>
      </div>
      {loading && !initialLoadComplete ? (
        <div className="text-center py-4">Loading URLs...</div>
      ) : filteredUrls.length === 0 ? (
        <div className="text-center py-4">
          {urls.length === 0 
            ? "No URLs discovered yet. Start by adding a URL to crawl." 
            : "No URLs match your filter."}
        </div>
      ) : (
        <ScrollArea className="h-[800px] border rounded-md">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-[40px]">
                  <Checkbox 
                    checked={selectAll} 
                    onCheckedChange={handleSelectAll}
                    aria-label="Select all"
                  />
                </TableHead>
                <TableHead>URL</TableHead>
                <TableHead className="w-[100px]">Status</TableHead>
                <TableHead className="w-[80px]">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredUrls.map(url => (
                <TableRow key={url.url}>
                  <TableCell>
                    <Checkbox 
                      checked={selectedUrls.includes(url.url)} 
                      onCheckedChange={(checked) => handleSelectURL(url.url, checked === true)}
                      aria-label={`Select ${url.url}`}
                    />
                  </TableCell>
                  <TableCell>
                    <div className="max-w-full overflow-x-auto no-scrollbar">
                      <span className="whitespace-nowrap">{url.url}</span>
                    </div>
                  </TableCell>
                  <TableCell>
                    <Badge variant={getStatusColor(url.status)}>
                      {url.status}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleViewDetails(url)}
                      title="View details"
                    >
                      <Eye className="h-4 w-4" />
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </ScrollArea>
      )}
      {/* URL Detail Modal */}
      <URLDetailModal 
        url={selectedUrlDetail} 
        open={detailModalOpen} 
        onOpenChange={setDetailModalOpen} 
      />
      {/* Delete All Confirmation Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete all URLs?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete all {urls.length} URLs in this session. 
              This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleDeleteAllUrls}
              disabled={deleting}
              className="bg-destructive hover:bg-destructive/90"
            >
              {deleting ? "Deleting..." : "Delete All"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      {/* Anti-pattern Filter Dialog */}
      <AlertDialog open={antiPatternDialogOpen} onOpenChange={setAntiPatternDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>URLs Matching Anti-Patterns</AlertDialogTitle>
            <AlertDialogDescription>
              {urlsMatchingAntiPatterns.length} URLs match your configured anti-patterns. 
              You can delete them to clean up your URL list.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="max-h-[300px] overflow-y-auto border rounded-md p-2 my-2">
            {urlsMatchingAntiPatterns.length === 0 ? (
              <p className="text-center py-2">No matching URLs found</p>
            ) : (
              <ul className="space-y-1">
                {urlsMatchingAntiPatterns.map(url => (
                  <li key={url.url} className="truncate text-sm" title={url.url}>
                    {url.url}
                  </li>
                ))}
              </ul>
            )}
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={antiPatternFiltering}>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleDeleteAntiPatternUrls}
              disabled={urlsMatchingAntiPatterns.length === 0 || antiPatternFiltering}
              className="bg-destructive hover:bg-destructive/90"
            >
              {antiPatternFiltering ? "Deleting..." : "Delete Matching URLs"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/components/knowledge/KnowledgeBase.tsx">
import { useState, useEffect, useRef } from "react";
import { toast } from "sonner";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Search, BookOpen, Code, Library, Info, Database } from "lucide-react";
import { useVectorDB } from '../../hooks/useVectorDB';
interface KnowledgeBaseProps {
  sessionId: number;
}
interface DocSnippet {
  id: string;
  title: string;
  content: string;
  source: string;
  category: "language" | "framework" | "library";
  name: string;
  version?: string;
}
interface SearchResult {
  id: string;
  score: number;
  snippet: {
    title: string;
    content: string;
    source: string;
    category: "language" | "framework" | "library";
    name: string;
    version?: string;
  };
}
// Add a type definition for the vector DB document
interface VectorDBDocument {
  id: string;
  content: string;
  metadata: {
    title: string;
    source?: string;
    category?: string;
    name?: string;
    version?: string;
    url?: string;
    status?: string;
    [key: string]: any;
  };
  score?: number;
}
export default function KnowledgeBase({ sessionId }: KnowledgeBaseProps) {
  console.log("KnowledgeBase component rendered with sessionId:", sessionId);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string | undefined>(undefined);
  const [selectedComponent, setSelectedComponent] = useState<string | undefined>(undefined);
  const [components, setComponents] = useState<{ category: string; name: string }[]>([]);
  const [docResults, setDocResults] = useState<DocSnippet[]>([]);
  const [isLoadingDocs, setIsLoadingDocs] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [hasMoreDocs, setHasMoreDocs] = useState(true);
  const [activeTab, setActiveTab] = useState("search");
  const componentMountedRef = useRef(true);
  const loadingComponentsRef = useRef(false);
  const hasLoadedComponentsRef = useRef(false);
  // Use the hook with sessionId
  const { 
    vectorDB,
    searchDocuments, 
    getDocumentsByFilters,
    isInitialized,
    loading: vectorDBLoading,
    error: vectorDBError
  } = useVectorDB(sessionId);
  // Add debug logging for component mount and unmount
  useEffect(() => {
    componentMountedRef.current = true;
    console.log("KnowledgeBase component mounted");
    return () => {
      componentMountedRef.current = false;
      console.log("KnowledgeBase component unmounting");
    };
  }, []);
  // Add debug logging for vector DB state changes
  useEffect(() => {
    if (!componentMountedRef.current) return;
    console.log(`KnowledgeBase vector DB state changed:`, {
      sessionId,
      isInitialized,
      loading: vectorDBLoading,
      error: vectorDBError ? vectorDBError.message : 'none',
      hasComponents: components.length > 0,
      isMounted: componentMountedRef.current,
      hasVectorDB: !!vectorDB,
      loadingComponents: loadingComponentsRef.current,
      hasLoadedComponents: hasLoadedComponentsRef.current
    });
    // If we have a valid vector DB and haven't loaded components yet, load them
    if (vectorDB && isInitialized && !loadingComponentsRef.current && !hasLoadedComponentsRef.current) {
      loadComponents();
    }
  }, [sessionId, isInitialized, vectorDBLoading, vectorDBError, vectorDB]);
  const loadComponents = async () => {
    if (!componentMountedRef.current || loadingComponentsRef.current || hasLoadedComponentsRef.current) return;
    if (!vectorDB || !isInitialized) {
      console.log(`KnowledgeBase: Cannot load components - vector DB not initialized or unavailable`);
      return;
    }
    try {
      loadingComponentsRef.current = true;
      console.log(`KnowledgeBase: Starting component load for session ${sessionId}`);
      // Use the getDocumentsByFilters function from the hook with proper filtering
      // Get all unique categories first
      const categories = ["language", "framework", "library"];
      const componentsList: { category: string; name: string }[] = [];
      // Process each category separately to ensure we get components from all categories
      for (const category of categories) {
        if (!componentMountedRef.current) return;
        const results = await getDocumentsByFilters({ category }, 100);
        const uniqueComponents = new Set<string>();
        results.forEach((result: VectorDBDocument) => {
          const name = result.metadata.name;
          if (name) {
            const key = `${category}:${name}`;
            if (!uniqueComponents.has(key)) {
              uniqueComponents.add(key);
              componentsList.push({ category, name });
            }
          }
        });
      }
      if (componentMountedRef.current) {
        console.log(`Loaded ${componentsList.length} components:`, componentsList);
        setComponents(componentsList);
        hasLoadedComponentsRef.current = true;
      }
    } catch (error) {
      console.error("Error loading components:", error);
      if (componentMountedRef.current) {
        toast.error("Failed to load components");
      }
    } finally {
      loadingComponentsRef.current = false;
    }
  };
  // Vector search
  const handleVectorSearch = async () => {
    if (!searchQuery.trim()) {
      toast.error("Please enter a search query");
      return;
    }
    if (!isInitialized) {
      toast.error("Vector database is not available");
      return;
    }
    try {
      setIsSearching(true);
      setSearchResults([]);
      // Use the searchDocuments function from the hook
      const results = await searchDocuments(searchQuery, {
        category: selectedCategory || undefined,
        [selectedCategory || ""]: selectedComponent || undefined
      }, 10);
      const formattedResults = results.map((result: VectorDBDocument) => ({
        id: result.id,
        score: result.score || 0,
        snippet: {
          title: result.metadata.title,
          content: result.content,
          source: result.metadata.source || "",
          category: result.metadata.category as "language" | "framework" | "library",
          name: result.metadata.name || "",
          version: result.metadata.version
        }
      }));
      setSearchResults(formattedResults);
    } catch (error) {
      console.error("Error searching vector database:", error);
      toast.error("Error searching knowledge base");
    } finally {
      setIsSearching(false);
    }
  };
  // Doc snippets search
  const handleDocSearch = async (loadMore: boolean = false) => {
    if (!isInitialized) {
      toast.error("Vector database is not available");
      return;
    }
    try {
      setIsLoadingDocs(true);
      const page = loadMore ? currentPage + 1 : 1;
      const limit = 10;
      // Build proper filters object
      const filters: Record<string, any> = {};
      if (selectedCategory) {
        filters.category = selectedCategory;
      }
      if (selectedComponent) {
        filters.name = selectedComponent;
      }
      console.log(`Searching docs with filters:`, filters);
      // Use the getDocumentsByFilters function from the hook
      const results = await getDocumentsByFilters(filters, limit);
      const formattedResults = results.map((result: VectorDBDocument) => ({
        id: result.id,
        title: result.metadata.title || "Untitled",
        content: result.content,
        source: result.metadata.source || "",
        category: result.metadata.category as "language" | "framework" | "library",
        name: result.metadata.name || "",
        version: result.metadata.version
      }));
      if (loadMore) {
        setDocResults(prev => [...prev, ...formattedResults]);
      } else {
        setDocResults(formattedResults);
      }
      setCurrentPage(page);
      setHasMoreDocs(formattedResults.length === limit);
    } catch (error) {
      console.error("Error fetching documents:", error);
      toast.error("Error loading documents");
    } finally {
      setIsLoadingDocs(false);
    }
  };
  return (
    <div className="flex flex-col h-full">
      {/* Show alert when vector DB is not initialized */}
      {(!isInitialized || vectorDBLoading) && (
        <Alert className="mb-4">
          <AlertDescription className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <Database className="h-4 w-4" />
              <span className="font-medium">
                {vectorDBLoading 
                  ? "Initializing vector database..." 
                  : sessionId <= 0
                    ? "No session selected"
                    : "Vector database not initialized"}
              </span>
            </div>
            {!vectorDBLoading && (
              <div className="text-sm text-muted-foreground">
                {sessionId <= 0 
                  ? "Please select a session to use the knowledge base." 
                  : "Please wait while the vector database initializes."}
              </div>
            )}
            {vectorDBError && (
              <div className="text-sm text-destructive">
                Error: {vectorDBError.message}
              </div>
            )}
          </AlertDescription>
        </Alert>
      )}
      {/* Show knowledge base content when vector DB is initialized */}
      {isInitialized && (
        <Card className="border shadow-sm">
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center text-xl font-semibold">
              <BookOpen className="h-5 w-5 mr-2 text-primary" />
              Knowledge Base
            </CardTitle>
            <CardDescription>
              Search through processed content and documentation
            </CardDescription>
          </CardHeader>
          <CardContent className="pt-2">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
              <div className="w-full flex justify-center">
                <TabsList className="inline-flex h-12 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground w-full max-w-[450px] shadow-sm">
                  <TabsTrigger 
                    value="vectorSearch" 
                    className="inline-flex items-center justify-center whitespace-nowrap px-4 py-2 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm w-full rounded-md"
                  >
                    <div className="flex items-center">
                      <div className={`p-1.5 rounded-full mr-2 ${activeTab === "vectorSearch" ? "bg-primary/10" : ""}`}>
                        <Search className={`h-4 w-4 ${activeTab === "vectorSearch" ? "text-primary" : ""}`} />
                      </div>
                      <span className="truncate">Vector Search</span>
                    </div>
                  </TabsTrigger>
                  <TabsTrigger 
                    value="docsLibrary" 
                    className="inline-flex items-center justify-center whitespace-nowrap px-4 py-2 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm w-full rounded-md"
                  >
                    <div className="flex items-center">
                      <div className={`p-1.5 rounded-full mr-2 ${activeTab === "docsLibrary" ? "bg-primary/10" : ""}`}>
                        <BookOpen className={`h-4 w-4 ${activeTab === "docsLibrary" ? "text-primary" : ""}`} />
                      </div>
                      <span className="truncate">Docs Library</span>
                    </div>
                  </TabsTrigger>
                </TabsList>
              </div>
              {/* Vector Search Tab */}
              <TabsContent value="vectorSearch" className="space-y-6">
                <div className="flex flex-col gap-3">
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                      <Input
                        placeholder="Search for concepts, code examples, or solutions..."
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") handleVectorSearch();
                        }}
                        className="pl-9 h-11 shadow-sm border-muted focus-visible:ring-primary/20 focus-visible:ring-offset-0"
                      />
                      {searchQuery && (
                        <button
                          onClick={() => setSearchQuery("")}
                          className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground p-1 rounded-full"
                          aria-label="Clear search"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                          </svg>
                        </button>
                      )}
                    </div>
                    <Button 
                      onClick={handleVectorSearch}
                      disabled={isSearching || !searchQuery.trim()}
                      className="shrink-0 h-11 px-5 shadow-sm"
                    >
                      {isSearching ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent mr-2"></div>
                          <span>Searching...</span>
                        </>
                      ) : (
                        <span>Search</span>
                      )}
                    </Button>
                  </div>
                  <div className="flex items-center text-xs text-muted-foreground">
                    <Badge variant="secondary" className="mr-2">Global</Badge>
                    Searching across all processed content using semantic search
                  </div>
                </div>
                <div>
                  {searchResults.length > 0 ? (
                    <ScrollArea className="h-[650px] pr-4">
                      <div className="space-y-4">
                        {searchResults.map((result) => (
                          <Card 
                            key={result.id} 
                            className="overflow-hidden border-l-4 border-l-primary shadow-sm transition-all hover:shadow-md hover:scale-[1.01]"
                          >
                            <CardHeader className="p-4 pb-2 bg-gradient-to-r from-background to-background/95">
                              <div className="flex justify-between items-start gap-2">
                                <CardTitle className="text-base font-medium line-clamp-2">{result.snippet.title}</CardTitle>
                                <Badge variant="outline" className="shrink-0 bg-background/80">
                                  {typeof result.score === 'number' ? 
                                    `${(result.score * 100).toFixed(1)}%` : 
                                    'Score N/A'}
                                </Badge>
                              </div>
                              <CardDescription className="flex items-center gap-2 text-xs mt-1 truncate">
                                <Info className="h-3 w-3 opacity-70" />
                                <span className="truncate">{result.snippet.source}</span>
                                {result.snippet.category && (
                                  <Badge variant="secondary" className="text-xs">
                                    {result.snippet.category}
                                  </Badge>
                                )}
                              </CardDescription>
                            </CardHeader>
                            <CardContent className="p-4 pt-2 max-h-72 overflow-y-auto">
                              <pre className="text-sm bg-muted/50 p-3 rounded-md overflow-x-auto border whitespace-pre-wrap break-all">
                                {result.snippet.content}
                              </pre>
                            </CardContent>
                          </Card>
                        ))}
                      </div>
                    </ScrollArea>
                  ) : isSearching ? (
                    <div className="flex flex-col items-center justify-center py-12 space-y-4">
                      <div className="relative">
                        <div className="animate-spin rounded-full h-12 w-12 border-3 border-primary border-t-transparent"></div>
                        <div className="absolute inset-0 flex items-center justify-center">
                          <Search className="h-5 w-5 text-primary/60" />
                        </div>
                      </div>
                      <p className="text-muted-foreground font-medium">Searching knowledge base...</p>
                      <p className="text-xs text-muted-foreground/70">Finding the most relevant results for you</p>
                    </div>
                  ) : searchQuery.trim() ? (
                    <div className="flex flex-col items-center justify-center py-12 text-center max-w-md mx-auto">
                      <div className="bg-muted/30 rounded-full p-4 mb-5">
                        <Search className="h-12 w-12 text-muted-foreground/60" />
                      </div>
                      <p className="text-lg font-medium text-muted-foreground">No results found for "{searchQuery}"</p>
                      <p className="text-sm text-muted-foreground/70 mt-2 mb-4">Try adjusting your search terms or explore the suggestions below</p>
                      <div className="flex flex-wrap gap-2 justify-center mt-2">
                        <Button variant="outline" size="sm" onClick={() => setSearchQuery("documentation examples")}>
                          Documentation Examples
                        </Button>
                        <Button variant="outline" size="sm" onClick={() => setSearchQuery("code snippets")}>
                          Code Snippets
                        </Button>
                        <Button variant="outline" size="sm" onClick={() => setActiveTab("docsLibrary")}>
                          Browse Docs Library
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <div className="flex flex-col items-center justify-center py-12 text-center max-w-md mx-auto">
                      <div className="bg-muted/30 rounded-full p-4 mb-5">
                        <Search className="h-12 w-12 text-primary/50" />
                      </div>
                      <p className="text-lg font-medium text-foreground mb-2">Knowledge Base Search</p>
                      <p className="text-sm text-muted-foreground mb-6">Search across all processed documentation and code snippets</p>
                      <div className="w-full max-w-sm">
                        <div className="bg-muted/30 rounded-lg p-4">
                          <p className="text-sm font-medium text-muted-foreground mb-3">Try searching for:</p>
                          <div className="flex flex-wrap gap-2 justify-center">
                            <Button variant="secondary" size="sm" onClick={() => setSearchQuery("react hooks examples")}>
                              React Hooks
                            </Button>
                            <Button variant="secondary" size="sm" onClick={() => setSearchQuery("api authentication")}>
                              API Auth
                            </Button>
                            <Button variant="secondary" size="sm" onClick={() => setSearchQuery("css grid layout")}>
                              CSS Grid
                            </Button>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </TabsContent>
              {/* Docs Library Tab */}
              <TabsContent value="docsLibrary" className="space-y-6">
                <div className="flex flex-col gap-3">
                  <div className="flex flex-wrap gap-3">
                    <div className="flex items-center gap-2 flex-1 min-w-[200px]">
                      <Code className="h-4 w-4 text-muted-foreground" />
                      <Select value={selectedCategory} onValueChange={setSelectedCategory}>
                        <SelectTrigger className="w-full">
                          <SelectValue placeholder="Select category" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="language">Language</SelectItem>
                          <SelectItem value="framework">Framework</SelectItem>
                          <SelectItem value="library">Library</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    <div className="flex items-center gap-2 flex-1 min-w-[200px]">
                      <Library className="h-4 w-4 text-muted-foreground" />
                      <Select 
                        value={selectedComponent} 
                        onValueChange={setSelectedComponent}
                        disabled={!isInitialized || components.length === 0}
                      >
                        <SelectTrigger className="w-full">
                          <SelectValue placeholder={
                            !isInitialized 
                              ? "Vector database not available" 
                              : components.length === 0
                              ? "No components available"
                              : "Select component"
                          } />
                        </SelectTrigger>
                        <SelectContent>
                          {components.length > 0 ? (
                            components.map((component) => (
                              <SelectItem key={component.name} value={component.name}>
                                {component.name}
                              </SelectItem>
                            ))
                          ) : (
                            <div className="px-2 py-4 text-center">
                              <div className="text-sm text-muted-foreground">No {selectedCategory}s available</div>
                              <div className="text-xs text-muted-foreground/70 mt-1">Try crawling documentation first</div>
                            </div>
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                      <Input
                        placeholder="Search in docs..."
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") handleDocSearch();
                        }}
                        className="pl-9 w-full h-11 shadow-sm border-muted focus-visible:ring-primary/20 focus-visible:ring-offset-0"
                      />
                      {searchQuery && (
                        <button
                          onClick={() => setSearchQuery("")}
                          className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground p-1 rounded-full"
                          aria-label="Clear search"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                          </svg>
                        </button>
                      )}
                    </div>
                    <Button 
                      onClick={() => handleDocSearch(true)}
                      disabled={
                        isLoadingDocs || 
                        // Enable if we have a component selected, even without a query
                        (!searchQuery.trim() && !selectedComponent) ||
                        // But require a version if component is selected
                        (!!selectedComponent && !components.find(c => c.name === selectedComponent))
                      }
                      className="shrink-0 h-11 px-5 shadow-sm"
                    >
                      {isLoadingDocs ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent mr-2"></div>
                          <span>Searching...</span>
                        </>
                      ) : searchQuery.trim() ? (
                        <span>Search</span>
                      ) : (
                        <>
                          <BookOpen className="h-4 w-4 mr-2" />
                          <span>Browse Docs</span>
                        </>
                      )}
                    </Button>
                  </div>
                </div>
                <div>
                  {docResults.length > 0 ? (
                    <ScrollArea className="h-[650px] pr-4">
                      <div className="space-y-4">
                        {docResults.map((result) => (
                          <Card 
                            key={result.id} 
                            className="overflow-hidden border-l-4 border-l-primary shadow-sm transition-all hover:shadow-md hover:scale-[1.01]"
                          >
                            <CardHeader className="p-4 pb-2 bg-gradient-to-r from-background to-background/95">
                              <div className="flex flex-wrap justify-between items-start gap-2">
                                <CardTitle className="text-base font-medium line-clamp-2">{result.title}</CardTitle>
                                <div className="flex flex-wrap gap-2">
                                  <Badge className="shrink-0 bg-secondary/10">
                                    {result.name} {result.version || ""}
                                  </Badge>
                                </div>
                              </div>
                              <CardDescription className="flex items-center text-xs mt-1 truncate">
                                <Info className="h-3 w-3 mr-1 opacity-70" />
                                Category: {result.category}
                              </CardDescription>
                            </CardHeader>
                            <CardContent className="p-4 pt-2 max-h-72 overflow-y-auto">
                              <pre className="text-sm bg-muted/50 p-3 rounded-md overflow-x-auto border whitespace-pre-wrap break-all">
                                {result.content}
                              </pre>
                            </CardContent>
                          </Card>
                        ))}
                        {/* Load More Button */}
                        {hasMoreDocs && (
                          <div className="flex justify-center mt-4">
                            <Button
                              variant="outline"
                              onClick={() => handleDocSearch(true)}
                              disabled={isLoadingDocs}
                              className="w-full max-w-[300px] bg-background hover:bg-muted/50 transition-all"
                            >
                              {isLoadingDocs ? (
                                <>
                                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-primary border-t-transparent mr-2"></div>
                                  <span>Loading more results...</span>
                                </>
                              ) : (
                                <>
                                  <Database className="h-4 w-4 mr-2" />
                                  <span>Load More Documents</span>
                                </>
                              )}
                            </Button>
                          </div>
                        )}
                      </div>
                    </ScrollArea>
                  ) : isLoadingDocs ? (
                    <div className="flex flex-col items-center justify-center py-12 space-y-4">
                      <div className="relative">
                        <div className="animate-spin rounded-full h-12 w-12 border-3 border-primary border-t-transparent"></div>
                        <div className="absolute inset-0 flex items-center justify-center">
                          <BookOpen className="h-5 w-5 text-primary/60" />
                        </div>
                      </div>
                      <p className="text-muted-foreground font-medium">Searching documentation...</p>
                      <p className="text-xs text-muted-foreground/70">Looking through the documentation library</p>
                    </div>
                  ) : selectedCategory && components.length === 0 ? (
                    <div className="flex flex-col items-center justify-center py-12 text-center max-w-md mx-auto">
                      <div className="bg-amber-100/30 dark:bg-amber-900/20 rounded-full p-4 mb-5">
                        <Database className="h-12 w-12 text-amber-600 dark:text-amber-400" />
                      </div>
                      <p className="text-lg font-medium text-foreground">No {selectedCategory}s available</p>
                      <p className="text-sm text-muted-foreground mt-2 mb-4">
                        Your knowledge base doesn't have any {selectedCategory} documentation yet
                      </p>
                      <Button variant="outline" size="sm" className="border-amber-200 dark:border-amber-800">
                        <BookOpen className="h-4 w-4 mr-2" />
                        Crawl {selectedCategory} documentation
                      </Button>
                    </div>
                  ) : searchQuery.trim() || selectedComponent ? (
                    <div className="flex flex-col items-center justify-center py-12 text-center max-w-md mx-auto">
                      <div className="bg-muted/30 rounded-full p-4 mb-5">
                        <Search className="h-12 w-12 text-muted-foreground/60" />
                      </div>
                      <p className="text-lg font-medium text-muted-foreground">No documentation snippets found</p>
                      <p className="text-sm text-muted-foreground/70 mt-2 mb-4">Try a different search term or select another component</p>
                      <div className="flex gap-3">
                        <Button variant="outline" size="sm" onClick={() => setSearchQuery("")}>
                          Clear Search
                        </Button>
                        <Button variant="outline" size="sm" onClick={() => setSelectedCategory(undefined)}>
                          Reset Filters
                        </Button>
                      </div>
                    </div>
                  ) : null}
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/sessions/CreateSessionForm.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../ui/card";
import { createSession, CrawlSession, saveSessionVectorDBMapping } from "../../lib/db";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "../ui/select";
interface CreateSessionFormProps {
  onSessionCreated: (session: CrawlSession) => void;
  onCancel: () => void;
}
const formSchema = z.object({
  title: z.string().min(1, "Title is required"),
  version: z.string().optional(),
  vectorDb: z.enum(["chromadb", "pinecone"]),
});
type FormData = z.infer<typeof formSchema>;
// Vector DB options
const VECTOR_DB_OPTIONS = [
  { value: "chromadb", label: "ChromaDB (local)" },
  { value: "pinecone", label: "Pinecone (shared)" },
];
export default function CreateSessionForm({ 
  onSessionCreated, 
  onCancel 
}: CreateSessionFormProps) {
  const [submitting, setSubmitting] = useState(false);
  const [titleValue, setTitleValue] = useState("");
  const [versionValue, setVersionValue] = useState("");
  const [vectorDbValue, setVectorDbValue] = useState<"chromadb" | "pinecone">("chromadb");
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: "",
      version: "",
      vectorDb: "chromadb",
    },
    mode: "all",
  });
  const onSubmit = async (data: FormData) => {
    try {
      setSubmitting(true);
      console.log("Creating session with data:", data);
      // Additional validation and prepare data
      if (!titleValue || titleValue.trim() === "") {
        throw new Error("Title is required");
      }
      // Create session with manually prepared data
      const sessionData = {
        title: titleValue.trim(),
        version: versionValue.trim()
      };
      console.log("Submitting session data:", sessionData);
      const session = await createSession(sessionData);
      // Save vector DB mapping
      await saveSessionVectorDBMapping({
        session_id: session.id!,
        provider_name: vectorDbValue,
        config_data: JSON.stringify({
          // Default empty config, will be populated when needed
        })
      });
      console.log("Session created successfully:", session);
      onSessionCreated(session);
    } catch (error) {
      console.error("Failed to create session:", error);
      alert("Failed to create session. Please try again. Error: " + String(error));
    } finally {
      setSubmitting(false);
    }
  };
  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Create New Session</CardTitle>
        <CardDescription>Create a new documentation crawl session.</CardDescription>
      </CardHeader>
      <form onSubmit={form.handleSubmit((data) => {
        console.log("Form submit event triggered with validated data:", data);
        onSubmit(data);
      })}>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="title">Title <span className="text-red-500">*</span></Label>
            <Input
              id="title"
              placeholder="e.g., Tauri V2 Documentation"
              value={titleValue}
              onChange={(e) => {
                const value = e.target.value;
                setTitleValue(value);
                form.setValue("title", value);
              }}
            />
            {form.formState.errors.title?.message && (
              <p className="text-sm text-red-500">
                {form.formState.errors.title.message}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="version">Version (Optional)</Label>
            <Input
              id="version"
              placeholder="e.g., 2.0.0"
              value={versionValue}
              onChange={(e) => {
                const value = e.target.value;
                setVersionValue(value);
                form.setValue("version", value);
              }}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="vectorDb">Vector Database</Label>
            <Select
              value={vectorDbValue}
              onValueChange={(value: "chromadb" | "pinecone") => {
                setVectorDbValue(value);
                form.setValue("vectorDb", value);
              }}
            >
              <SelectTrigger id="vectorDb">
                <SelectValue placeholder="Select vector database" />
              </SelectTrigger>
              <SelectContent>
                {VECTOR_DB_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <p className="text-xs text-gray-500">
              {vectorDbValue === "chromadb" 
                ? "ChromaDB stores embeddings locally on your machine." 
                : "Pinecone stores embeddings in the cloud for better performance and sharing."}
            </p>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button 
            type="button" 
            variant="outline"
            onClick={onCancel}
            disabled={submitting}
          >
            Cancel
          </Button>
          <Button 
            type="submit"
            disabled={submitting || !titleValue.trim()}
          >
            {submitting ? "Creating..." : "Create Session"}
          </Button>
        </CardFooter>
      </form>
    </Card>
  );
}
</file>

<file path="src/components/sessions/SessionList.tsx">
import { useState, useEffect, useRef } from "react";
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from "../ui/card";
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from "../ui/table";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "../ui/button";
import { Trash2, Copy, Download, Upload } from "lucide-react";
import { toast } from "sonner";
import { getSessions, CrawlSession, deleteSession, duplicateSession, exportSession, importSession } from "../../lib/db";
interface SessionListProps {
  onCreateSession: () => void;
  onSelectSession: (session: CrawlSession) => void;
}
export default function SessionList({ onCreateSession, onSelectSession }: SessionListProps) {
  const [sessions, setSessions] = useState<CrawlSession[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState<number | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const loadSessions = async () => {
    try {
      setLoading(true);
      const data = await getSessions();
      setSessions(data);
      setError(null);
    } catch (err) {
      console.error("Failed to load sessions:", err);
      setError("Failed to load sessions. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  useEffect(() => {
    loadSessions();
  }, []);
  const handleDelete = (sessionId: number) => {
    setSessionToDelete(sessionId);
    setDeleteDialogOpen(true);
  };
  const confirmDelete = async () => {
    if (sessionToDelete !== null) {
      try {
        await deleteSession(sessionToDelete);
        toast.success("Session deleted successfully");
        // Reload the sessions list
        await loadSessions();
      } catch (error) {
        console.error("Error deleting session:", error);
        toast.error("Failed to delete session");
      } finally {
        setDeleteDialogOpen(false);
        setSessionToDelete(null);
      }
    }
  };
  const handleDuplicate = async (sessionId: number) => {
    try {
      await duplicateSession(sessionId);
      toast.success("Session duplicated successfully");
      // Reload the sessions list
      await loadSessions();
    } catch (error) {
      console.error("Error duplicating session:", error);
      toast.error("Failed to duplicate session");
    }
  };
  const handleExport = async (sessionId: number) => {
    try {
      const exportData = await exportSession(sessionId);
      // Convert to JSON string
      const jsonString = JSON.stringify(exportData, null, 2);
      // Create a blob and download link
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      // Create a temporary link and trigger download
      const a = document.createElement('a');
      a.href = url;
      a.download = `session-${sessionId}-export.json`;
      document.body.appendChild(a);
      a.click();
      // Clean up
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast.success("Session exported successfully");
    } catch (error) {
      console.error("Error exporting session:", error);
      toast.error("Failed to export session");
    }
  };
  const handleImportClick = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };
  const handleImportFile = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    try {
      // Read the file
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const content = e.target?.result as string;
          const importData = JSON.parse(content);
          // Import the session
          await importSession(importData);
          toast.success("Session imported successfully");
          // Reload the sessions list
          await loadSessions();
        } catch (error) {
          console.error("Error parsing import file:", error);
          toast.error("Failed to import session: Invalid file format");
        }
      };
      reader.readAsText(file);
    } catch (error) {
      console.error("Error importing session:", error);
      toast.error("Failed to import session");
    } finally {
      // Reset the file input
      if (event.target) {
        event.target.value = '';
      }
    }
  };
  return (
    <>
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Crawl Sessions</CardTitle>
          <CardDescription>Manage your documentation crawl sessions.</CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-4">Loading sessions...</div>
          ) : error ? (
            <div className="text-red-500 py-4">{error}</div>
          ) : sessions.length === 0 ? (
            <div className="text-center py-4">No sessions yet. Create a new session to start crawling.</div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Title</TableHead>
                  <TableHead>Version</TableHead>
                  <TableHead>Created At</TableHead>
                  <TableHead>Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {sessions.map((session) => (
                  <TableRow key={session.id}>
                    <TableCell>{session.title}</TableCell>
                    <TableCell>{session.version || "N/A"}</TableCell>
                    <TableCell>{new Date(session.created_at!).toLocaleString()}</TableCell>
                    <TableCell>
                      <div className="flex space-x-2">
                        <Button 
                          variant="outline" 
                          size="sm"
                          onClick={() => onSelectSession(session)}
                        >
                          Select
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleExport(session.id!)}
                          title="Export session"
                        >
                          <Download className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleDuplicate(session.id!)}
                          title="Duplicate session"
                        >
                          <Copy className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleDelete(session.id!)}
                          title="Delete session"
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button 
            variant="outline" 
            onClick={handleImportClick}
          >
            <Upload className="h-4 w-4 mr-2" />
            Import Session
          </Button>
          <input 
            type="file" 
            ref={fileInputRef} 
            style={{ display: 'none' }} 
            accept=".json" 
            onChange={handleImportFile}
          />
          <Button onClick={onCreateSession}>
            Create New Session
          </Button>
        </CardFooter>
      </Card>
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the session
              and all its data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={confirmDelete}>Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="src/components/sessions/SessionsPage.tsx">
import { useState, useEffect } from "react";
import SessionList from "./SessionList";
import CreateSessionForm from "./CreateSessionForm";
import { CrawlSession, getSession } from "../../lib/db";
import { Alert, AlertDescription } from "../../components/ui/alert";
interface SessionsPageProps {
  onSelectSession: (session: CrawlSession) => void;
}
export default function SessionsPage({ onSelectSession }: SessionsPageProps) {
  const [selectedSessionId, setSelectedSessionId] = useState<number | null>(null);
  const [isCreating, setIsCreating] = useState(false);
  useEffect(() => {
    async function loadSelectedSession() {
      try {
        const session = await getSession(1); // Get the first session or use a different method
        if (session) {
          setSelectedSessionId(session.id!);
        }
      } catch (error) {
        console.error("Error loading session:", error);
      }
    }
    loadSelectedSession();
  }, []);
  const handleCreateSession = () => {
    setIsCreating(true);
  };
  const handleSessionCreated = (session: CrawlSession) => {
    setIsCreating(false);
    setSelectedSessionId(session.id!);
    onSelectSession(session);
  };
  const handleCancel = () => {
    setIsCreating(false);
  };
  const handleSelectSession = (session: CrawlSession) => {
    setSelectedSessionId(session.id!);
    onSelectSession(session);
  };
  return (
    <div>
      {isCreating ? (
        <CreateSessionForm 
          onSessionCreated={handleSessionCreated}
          onCancel={handleCancel}
        />
      ) : (
        <SessionList 
          onCreateSession={handleCreateSession}
          onSelectSession={handleSelectSession}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/settings/ApiSettings.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Form, FormField, FormItem, FormControl, FormMessage, FormLabel, FormDescription } from "@/components/ui/form";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { saveUserSettings, getUserSettings } from "@/lib/db";
import { apiSettingsFormSchema, type ApiSettingsValues } from "@/types/forms";
export default function ApiSettings() {
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const form = useForm<ApiSettingsValues>({
    resolver: zodResolver(apiSettingsFormSchema),
    defaultValues: {
      openai_key: "",
    },
  });
  const loadSettings = async () => {
    try {
      setLoading(true);
      const settings = await getUserSettings();
      console.log("Loading settings in API settings form:", settings);
      if (settings.openai_key) {
        form.setValue("openai_key", settings.openai_key);
      }
    } catch (error) {
      console.error("Failed to load API settings:", error);
    } finally {
      setLoading(false);
    }
  };
  // ChromaDB path validation no longer needed - using HTTP endpoint instead
  const onSubmit = async (data: ApiSettingsValues) => {
    try {
      setSaving(true);
      console.log("Saving settings to database:", data);
      // Save the settings - only OpenAI key needed now
      await saveUserSettings({
        openai_key: data.openai_key,
      });
      // Get the saved settings to confirm
      const savedSettings = await getUserSettings();
      console.log("Saved settings confirmed:", savedSettings);
      toast.success("API key saved successfully", {
        id: "api-settings-success"
      });
    } catch (error) {
      console.error("Failed to save API settings:", error);
      toast.error("Failed to save API settings. Please try again.", {
        id: "api-settings-error" 
      });
    } finally {
      setSaving(false);
    }
  };
  useEffect(() => {
    loadSettings();
  }, []);
  return (
    <Card>
      <CardHeader>
        <CardTitle>API Settings</CardTitle>
        <CardDescription>Configure API keys and paths for services.</CardDescription>
      </CardHeader>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <CardContent>
            <div className="space-y-4">
              <FormField
                control={form.control}
                name="openai_key"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>OpenAI API Key</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="sk-..."
                        {...field}
                        disabled={loading}
                      />
                    </FormControl>
                    <FormDescription>
                      Required for cleaning up and chunking markdown files using GPT-4o-mini.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />
              {/* ChromaDB path field removed - using HTTP container instead */}
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              type="submit"
              disabled={loading || saving}
            >
              {saving ? "Saving..." : "Save Settings"}
            </Button>
          </CardFooter>
        </form>
      </Form>
    </Card>
  );
}
</file>

<file path="src/components/settings/ProxySettings.tsx">
import { useState, useEffect } from "react";
import { fetchAndSaveProxies, getProxies } from "../../lib/db";
import { invoke } from "@tauri-apps/api/core";
import { Button } from "../ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "../ui/table";
import { Badge } from "../ui/badge";
export default function ProxySettings() {
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [proxies, setProxies] = useState<{ id?: number; url: string; last_used?: string; status: string }[]>([]);
  const loadProxies = async () => {
    try {
      setLoading(true);
      const data = await getProxies();
      setProxies(data);
    } catch (error) {
      console.error("Failed to load proxies:", error);
    } finally {
      setLoading(false);
    }
  };
  const refreshProxies = async () => {
    try {
      setRefreshing(true);
      const proxyList = await invoke<string[]>("fetch_proxies");
      const updatedProxies = await fetchAndSaveProxies(proxyList);
      setProxies(updatedProxies);
    } catch (error) {
      console.error("Failed to refresh proxies:", error);
    } finally {
      setRefreshing(false);
    }
  };
  useEffect(() => {
    loadProxies();
  }, []);
  return (
    <Card>
      <CardHeader>
        <CardTitle>Proxy Settings</CardTitle>
        <CardDescription>Manage proxies for web crawling.</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex justify-between items-center">
            <div>
              <h3 className="text-lg font-medium">Proxy List</h3>
              <p className="text-sm text-gray-500">
                {proxies.length} proxies available
              </p>
            </div>
            <Button
              onClick={refreshProxies}
              disabled={refreshing}
            >
              {refreshing ? "Refreshing..." : "Refresh Proxies"}
            </Button>
          </div>
          {loading ? (
            <div className="text-center py-4">Loading proxies...</div>
          ) : proxies.length === 0 ? (
            <div className="text-center py-4">
              No proxies available. Click "Refresh Proxies" to fetch the proxy list.
            </div>
          ) : (
            <div className="border rounded-md">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Proxy URL</TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead>Last Used</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {proxies.slice(0, 10).map((proxy) => (
                    <TableRow key={proxy.id}>
                      <TableCell className="font-mono">{proxy.url}</TableCell>
                      <TableCell>
                        <Badge
                          variant={
                            proxy.status === "active"
                              ? "default"
                              : proxy.status === "error"
                              ? "destructive"
                              : "secondary"
                          }
                        >
                          {proxy.status}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        {proxy.last_used
                          ? new Date(proxy.last_used).toLocaleString()
                          : "Never"}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
              {proxies.length > 10 && (
                <div className="text-center p-2 text-sm text-gray-500">
                  Showing 10 of {proxies.length} proxies
                </div>
              )}
            </div>
          )}
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <div className="text-sm text-gray-500">
          Proxies are automatically rotated during web crawling
        </div>
      </CardFooter>
    </Card>
  );
}
</file>

<file path="src/components/settings/SettingsPage.tsx">
import ApiSettings from './ApiSettings';
import ProxySettings from './ProxySettings';
import VectorDBSettings from './VectorDBSettings';
export default function SettingsPage() {
  return (
    <div className="container mx-auto p-4 space-y-4">
      <ApiSettings />
      <ProxySettings />
      <VectorDBSettings />
    </div>
  );
}
</file>

<file path="src/components/settings/theme-provider-wrapper.tsx">
import { ReactNode } from "react";
import { ThemeProvider } from "./theme-provider";
interface ThemeProviderWrapperProps {
  children: ReactNode;
  defaultTheme?: "light" | "dark" | "system";
  storageKey?: string;
}
// This wrapper component avoids the direct use of refs
export function ThemeProviderWrapper({
  children,
  defaultTheme = "system",
  storageKey = "anchoring-theme",
}: ThemeProviderWrapperProps) {
  return (
    <ThemeProvider defaultTheme={defaultTheme} storageKey={storageKey}>
      {children}
    </ThemeProvider>
  );
}
</file>

<file path="src/components/settings/theme-provider.tsx">
import { createContext, useContext, useEffect, useState } from "react"
type Theme = "dark" | "light" | "system"
type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}
type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}
const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}
const ThemeProviderContext = createContext<ThemeProviderState>(initialState)
export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "anchoring-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )
  useEffect(() => {
    const root = window.document.documentElement
    root.classList.remove("light", "dark")
    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"
      root.classList.add(systemTheme)
      return
    }
    root.classList.add(theme)
  }, [theme])
  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }
  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}
export const useTheme = () => {
  const context = useContext(ThemeProviderContext)
  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")
  return context
}
</file>

<file path="src/components/settings/VectorDBSettings.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { saveVectorDBSettings, getVectorDBSettings } from '@/lib/db';
interface VectorDBSettings {
  pinecone_api_key: string;
  pinecone_environment: string;
  pinecone_index: string;
}
export default function VectorDBSettings() {
  const [settings, setSettings] = useState<VectorDBSettings>({
    pinecone_api_key: '',
    pinecone_environment: '',
    pinecone_index: ''
  });
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  useEffect(() => {
    loadSettings();
  }, []);
  const loadSettings = async () => {
    try {
      setLoading(true);
      const config = await getVectorDBSettings();
      setSettings(config);
    } catch (error) {
      console.error('Error loading vector DB settings:', error);
      toast.error("Failed to load vector DB settings");
    } finally {
      setLoading(false);
    }
  };
  const handleSave = async () => {
    try {
      setSaving(true);
      await saveVectorDBSettings(settings);
      toast.success("Vector DB settings saved successfully");
    } catch (error) {
      console.error('Error saving vector DB settings:', error);
      toast.error("Failed to save vector DB settings");
    } finally {
      setSaving(false);
    }
  };
  return (
    <Card>
      <CardHeader>
        <CardTitle>Vector Database Settings</CardTitle>
        <CardDescription>Configure your vector database connections.</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-4">
          <div>
            <h3 className="text-lg font-medium">Remote Pinecone Settings</h3>
            <div className="grid gap-4 mt-2">
              <div className="grid gap-2">
                <Label htmlFor="pinecone_api_key">API Key</Label>
                <Input
                  id="pinecone_api_key"
                  type="password"
                  value={settings.pinecone_api_key}
                  onChange={(e) => setSettings({ ...settings, pinecone_api_key: e.target.value })}
                  placeholder="Enter Pinecone API key"
                  disabled={loading}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="pinecone_environment">Environment</Label>
                <Input
                  id="pinecone_environment"
                  value={settings.pinecone_environment}
                  onChange={(e) => setSettings({ ...settings, pinecone_environment: e.target.value })}
                  placeholder="us-east-1"
                  disabled={loading}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="pinecone_index">Index Name</Label>
                <Input
                  id="pinecone_index"
                  value={settings.pinecone_index}
                  onChange={(e) => setSettings({ ...settings, pinecone_index: e.target.value })}
                  placeholder="Enter index name"
                  disabled={loading}
                />
              </div>
            </div>
          </div>
        </div>
        <Button 
          onClick={handleSave} 
          className="w-full"
          disabled={loading || saving}
        >
          {saving ? "Saving..." : "Save Settings"}
        </Button>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}
function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}
function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}
function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}
export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}
function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}
function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}
function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}
function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}
function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}
function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}
function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}
function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}
function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}
export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "text-destructive-foreground [&>svg]:text-current *:data-[slot=alert-description]:text-destructive-foreground/80",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}
function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}
function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}
export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"
function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}
export { AspectRatio }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import { cn } from "@/lib/utils"
function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}
function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}
function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}
export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"
  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}
export { Badge, badgeVariants }
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"
import { cn } from "@/lib/utils"
function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}
function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}
function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}
function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}
function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}
function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}
function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}
export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}
export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
export { Calendar }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}
function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("flex flex-col gap-1.5 px-6", className)}
      {...props}
    />
  )
}
function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}
function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}
function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6", className)}
      {...props}
    />
  )
}
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/carousel.tsx">
"use client"
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]
type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}
type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps
const CarouselContext = React.createContext<CarouselContextProps | null>(null)
function useCarousel() {
  const context = React.useContext(CarouselContext)
  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }
  return context
}
function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)
  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])
  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])
  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])
  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )
  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])
  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)
    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])
  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}
function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()
  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}
function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()
  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}
function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()
  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}
function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()
  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}
export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="src/components/ui/chart.tsx">
import * as React from "react"
import * as RechartsPrimitive from "recharts"
import { cn } from "@/lib/utils"
// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const
export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}
type ChartContextProps = {
  config: ChartConfig
}
const ChartContext = React.createContext<ChartContextProps | null>(null)
function useChart() {
  const context = React.useContext(ChartContext)
  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }
  return context
}
function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`
  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}
const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )
  if (!colorConfig.length) {
    return null
  }
  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}
const ChartTooltip = RechartsPrimitive.Tooltip
function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()
  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }
    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label
    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }
    if (!value) {
      return null
    }
    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])
  if (!active || !payload?.length) {
    return null
  }
  const nestLabel = payload.length === 1 && indicator !== "dot"
  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color
          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}
const ChartLegend = RechartsPrimitive.Legend
function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()
  if (!payload?.length) {
    return null
  }
  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)
        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}
// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }
  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined
  let configLabelKey: string = key
  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }
  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}
export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}
export { Checkbox }
</file>

<file path="src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"
function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}
export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="src/components/ui/command.tsx">
"use client"
import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"
import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}
function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}
function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}
function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}
function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}
function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}
function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}
function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}
export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/context-menu.tsx">
"use client"
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}
function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}
function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}
function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}
function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}
function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}
function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}
function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}
function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}
function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}
function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}
function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}
function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}
function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}
export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}
function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}
function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}
function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}
function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}
function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}
function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}
function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}
function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/drawer.tsx">
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"
import { cn } from "@/lib/utils"
function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}
function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}
function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}
function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}
function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}
function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}
function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}
function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}
function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}
function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}
function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}
function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}
function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}
function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}
function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}
function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}
export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/form.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"
import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"
const Form = FormProvider
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}
const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}
const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }
  const { id } = itemContext
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}
type FormItemContextValue = {
  id: string
}
const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)
function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()
  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}
function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()
  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive-foreground", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}
function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()
  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}
function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()
  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children
  if (!body) {
    return null
  }
  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive-foreground text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}
export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/hover-card.tsx">
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"
import { cn } from "@/lib/utils"
function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}
function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}
function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Content
      data-slot="hover-card-content"
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 rounded-md border p-4 shadow-md outline-hidden",
        className
      )}
      {...props}
    />
  )
}
export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="src/components/ui/input-otp.tsx">
"use client"
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}
function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}
function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}
  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "border-input data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}
function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}
export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Input = React.forwardRef<HTMLInputElement, React.InputHTMLAttributes<HTMLInputElement>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        data-slot="input"
        className={cn(
          "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
          "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"
export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cn } from "@/lib/utils"
function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}
export { Label }
</file>

<file path="src/components/ui/menubar.tsx">
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}
function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}
function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}
function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}
function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}
function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}
function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}
function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}
function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}
function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}
function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}
function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}
function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}
function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}
function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}
export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}
</file>

<file path="src/components/ui/navigation-menu.tsx">
"use client"
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}
function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}
function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}
const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
)
function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}
function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}
function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}
function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}
export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"
import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"
function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}
function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}
function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}
type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">
function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}
function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}
function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}
function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}
export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
</file>

<file path="src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"
function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}
function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}
function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}
function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}
export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/progress.tsx">
"use client"
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cn } from "@/lib/utils"
function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}
export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}
function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}
export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/resizable.tsx">
"use client"
import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"
import { cn } from "@/lib/utils"
function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}
function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}
function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}
export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="src/components/ui/responsive-grid.tsx">
import React from "react";
import { cn } from "@/lib/utils";
interface ResponsiveGridProps extends React.HTMLAttributes<HTMLDivElement> {
  columns?: {
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
    "2xl"?: number;
  };
  gap?: string;
}
/**
 * A responsive grid component that adapts its columns based on screen size
 */
export function ResponsiveGrid({
  children,
  columns = { sm: 1, md: 2, lg: 3, xl: 4, "2xl": 4 },
  gap = "4",
  className,
  ...props
}: ResponsiveGridProps) {
  // Generate column class names for different breakpoints
  const columnClasses = [
    columns.sm && `grid-cols-${columns.sm}`,
    columns.md && `md:grid-cols-${columns.md}`,
    columns.lg && `lg:grid-cols-${columns.lg}`,
    columns.xl && `xl:grid-cols-${columns.xl}`,
    columns["2xl"] && `2xl:grid-cols-${columns["2xl"]}`,
  ].filter(Boolean);
  return (
    <div
      className={cn(
        "grid",
        `gap-${gap}`,
        ...columnClasses,
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}
export default ResponsiveGrid;
</file>

<file path="src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
import { cn } from "@/lib/utils"
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}
function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}
export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}
function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}
function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}
function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}
function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}
function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}
function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}
function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}
function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}
function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}
export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"
import { cn } from "@/lib/utils"
function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}
export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
"use client"
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"
import { cn } from "@/lib/utils"
function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}
function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}
function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}
function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}
function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}
function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}
function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}
function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}
function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}
export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"
import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"
type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}
const SidebarContext = React.createContext<SidebarContext | null>(null)
function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }
  return context
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)
  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }
      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )
  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])
  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }
    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])
  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"
  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )
  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}
function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()
  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }
  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }
  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}
function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()
  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}
function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()
  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}
function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}
function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}
function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}
function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}
function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}
function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}
function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}
function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"
  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}
function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}
function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}
function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}
function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}
const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()
  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )
  if (!tooltip) {
    return button
  }
  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }
  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}
function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}
function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])
  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}
function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}
function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}
function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"
function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-primary/10 animate-pulse rounded-md", className)}
      {...props}
    />
  )
}
export { Skeleton }
</file>

<file path="src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"
import { cn } from "@/lib/utils"
function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )
  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}
export { Slider }
</file>

<file path="src/components/ui/sonner.tsx">
"use client"
import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"
const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()
  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
        },
      }}
      {...props}
    />
  )
}
export { Toaster }
</file>

<file path="src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"
function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 inline-flex h-5 w-9 shrink-0 items-center rounded-full border-2 border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background pointer-events-none block size-4 rounded-full ring-0 shadow-lg transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}
export { Switch }
</file>

<file path="src/components/ui/table.tsx">
"use client"
import * as React from "react"
import { cn } from "@/lib/utils"
function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}
function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}
function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}
function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}
function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}
function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}
function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}
function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}
export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"
function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}
function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1",
        className
      )}
      {...props}
    />
  )
}
function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}
function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}
export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}
export { Textarea }
</file>

<file path="src/components/ui/toggle-group.tsx">
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})
function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}
function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)
  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}
export { ToggleGroup, ToggleGroupItem }
</file>

<file path="src/components/ui/toggle.tsx">
"use client"
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}
export { Toggle, toggleVariants }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "@/lib/utils"
function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}
function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}
function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}
export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/docs/structured-output.md">
# Using Structured Outputs with OpenAI API

This document provides guidance on how to implement structured outputs with the OpenAI API using Zod schemas for validation.

## Basic Implementation

To implement structured outputs:

1. Define a Zod schema that describes your expected output structure
2. Configure the OpenAI API request with the `response_format` parameter
3. Parse and validate the response

```typescript
import { z } from "zod";

// Define your schema
const ExampleSchema = z.object({
  title: z.string(),
  summary: z.string(),
  tags: z.array(z.string()),
  rating: z.number().min(1).max(5),
});

// Make OpenAI API call with structured output
async function getStructuredOutput(prompt: string) {
  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: "gpt-4o",
      messages: [
        { role: "system", content: "You are a helpful assistant." },
        { role: "user", content: prompt }
      ],
      response_format: { 
        type: "json_object", 
        schema: ExampleSchema.shape 
      }
    })
  });
  
  const result = await response.json();
  const content = result.choices[0]?.message?.content;
  
  // Parse and validate with Zod
  if (content) {
    try {
      const parsedResponse = JSON.parse(content);
      const validatedResponse = ExampleSchema.parse(parsedResponse);
      return validatedResponse;
    } catch (error) {
      console.error("Error parsing structured output:", error);
      throw error;
    }
  }
}
```

## Advanced Usage: Nested Schemas

You can create complex nested schemas:

```typescript
const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});

const CommentSchema = z.object({
  id: z.string(),
  text: z.string(),
  author: UserSchema,
  timestamp: z.string().datetime(),
});

const BlogPostSchema = z.object({
  title: z.string(),
  content: z.string(),
  author: UserSchema,
  tags: z.array(z.string()),
  comments: z.array(CommentSchema),
  published: z.boolean(),
  createdAt: z.string().datetime(),
});
```

## Handling Arrays

When you need an array of structured objects:

```typescript
const ProductSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number().positive(),
  category: z.string(),
});

const ProductListSchema = z.object({
  products: z.array(ProductSchema),
  totalCount: z.number().int().positive(),
});
```

## Enums and Union Types

For fields that can have specific values:

```typescript
const StatusEnum = z.enum(['pending', 'processing', 'completed', 'failed']);

const TaskSchema = z.object({
  id: z.string(),
  title: z.string(),
  status: StatusEnum,
  assignee: z.string().optional(),
});

// Union types for different response structures
const ResponseSchema = z.union([
  z.object({ success: z.literal(true), data: z.any() }),
  z.object({ success: z.literal(false), error: z.string() })
]);
```

## Error Handling

Proper error handling for schema validation:

```typescript
try {
  const parsedResponse = JSON.parse(content);
  const validatedResponse = MySchema.parse(parsedResponse);
  return validatedResponse;
} catch (error) {
  if (error instanceof z.ZodError) {
    // Handle validation errors
    console.error("Validation errors:", error.errors);
  } else if (error instanceof SyntaxError) {
    // Handle JSON parsing errors
    console.error("JSON parsing error:", error.message);
  } else {
    // Handle other errors
    console.error("Unknown error:", error);
  }
  throw error;
}
```

## Using with Function Calls

You can combine structured outputs with function calling:

```typescript
const response = await fetch("https://api.openai.com/v1/chat/completions", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    model: "gpt-4o",
    messages: [...],
    tools: [{
      type: "function",
      function: {
        name: "process_data",
        description: "Process structured data from user input",
        parameters: MySchema.shape
      }
    }],
    tool_choice: {
      type: "function",
      function: { name: "process_data" }
    }
  })
});
```

## Type Safety

For TypeScript integration, you can extract the type from a Zod schema:

```typescript
type MySchemaType = z.infer<typeof MySchema>;

// Now you can use it for type safety
function processData(data: MySchemaType) {
  // Type-safe access to data
}
```

## Best Practices

1. **Provide Field Descriptions**: Use `.describe()` to provide context for each field
   ```typescript
   const UserSchema = z.object({
     name: z.string().describe("The user's full name"),
     email: z.string().email().describe("The user's email address")
   });
   ```

2. **Use Default Values**: Set default values for optional fields
   ```typescript
   const ConfigSchema = z.object({
     theme: z.string().default("light"),
     notifications: z.boolean().default(true)
   });
   ```

3. **Refine Values**: Use `.refine()` for custom validation logic
   ```typescript
   const DateRangeSchema = z.object({
     start: z.string().datetime(),
     end: z.string().datetime()
   }).refine(data => new Date(data.start) < new Date(data.end), {
     message: "End date must be after start date",
     path: ["end"]
   });
   ```

4. **Transform Values**: Use `.transform()` to modify values after validation
   ```typescript
   const UserInputSchema = z.object({
     email: z.string().email().transform(val => val.toLowerCase())
   });
   ```
</file>

<file path="src/hooks/use-mobile.ts">
import * as React from "react"
const MOBILE_BREAKPOINT = 768
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])
  return !!isMobile
}
</file>

<file path="src/hooks/useKnowledgeBase.ts">
import { useState, useEffect, useRef } from 'react';
import { DocumentationCategory, FullDocumentationSnippet } from '../lib/db';
import { useVectorDB } from './useVectorDB';
/**
 * Interface for a documentation snippet
 */
export interface DocSnippet {
  id: string;
  title: string;
  content: string;
  source: string;
  category: "language" | "framework" | "library";
  name: string;
  version?: string;
}
/**
 * Interface for a search result
 */
export interface SearchResult {
  id: string;
  score: number;
  snippet: DocSnippet;
}
/**
 * Interface for documentation search parameters
 */
export interface DocSearchParams {
  query?: string;
  category?: "language" | "framework" | "library";
  componentName?: string;
  componentVersion?: string;
  apiKey?: string;
  limit?: number;  // Number of documents to return
  page?: number;   // Page number for pagination
}
// Interface for filters
export interface KnowledgeBaseFilters {
  category: DocumentationCategory | 'all';
  language?: string;
  language_version?: string;
  framework?: string;
  framework_version?: string;
  library?: string;
  library_version?: string;
}
interface ComponentOptions {
  languages: string[];
  frameworks: string[];
  libraries: string[];
}
/**
 * Hook to manage knowledge base search, filtering and available components
 */
export function useKnowledgeBase(sessionId: number) {
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [searchResults, setSearchResults] = useState<FullDocumentationSnippet[]>([]);
  const [filters, setFilters] = useState<KnowledgeBaseFilters>({
    category: 'all'
  });
  const [error, setError] = useState<string | null>(null);
  const [availableComponents, setAvailableComponents] = useState<ComponentOptions>({
    languages: [],
    frameworks: [],
    libraries: []
  });
  const [snippets, setSnippets] = useState<FullDocumentationSnippet[]>([]);
  // Track initialization state
  const componentsLoaded = useRef(false);
  const knowledgeBaseLoaded = useRef(false);
  // Use the vectorDB hook with sessionId
  const { 
    vectorDB,
    loading,
    error: vectorDBError,
    isInitialized,
    searchDocuments,
    getDocumentsByFilters
  } = useVectorDB(sessionId);
  // Update error state when vectorDBError changes
  useEffect(() => {
    if (vectorDBError) {
      console.error('Vector DB error:', vectorDBError);
      setError(vectorDBError.message);
    }
  }, [vectorDBError]);
  // Load available components for filters
  const loadAvailableComponents = async () => {
    if (!isInitialized) {
      console.warn('Vector DB is not initialized, cannot load components');
      return;
    }
    if (componentsLoaded.current) {
      console.log('Components already loaded, skipping');
      return;
    }
    try {
      console.log('Loading available components from vector DB...');
      // Get all component types
      const languageResults = await getDocumentsByFilters({ category: DocumentationCategory.LANGUAGE }, 100);
      const frameworkResults = await getDocumentsByFilters({ category: DocumentationCategory.FRAMEWORK }, 100);
      const libraryResults = await getDocumentsByFilters({ category: DocumentationCategory.LIBRARY }, 100);
      // Extract unique component names
      const languages = [...new Set(languageResults.map(doc => doc.language).filter(Boolean))];
      const frameworks = [...new Set(frameworkResults.map(doc => doc.framework).filter(Boolean))];
      const libraries = [...new Set(libraryResults.map(doc => doc.library).filter(Boolean))];
      setAvailableComponents({
        languages,
        frameworks,
        libraries
      });
      componentsLoaded.current = true;
      console.log('Loaded components:', { languages, frameworks, libraries });
    } catch (err) {
      console.error('Error loading components:', err);
      setError('Failed to load available components');
    }
  };
  // Search for snippets
  const searchSnippets = async (query: string, searchFilters?: KnowledgeBaseFilters) => {
    if (!query) {
      setSearchResults([]);
      return;
    }
    if (!isInitialized) {
      const errorMsg = 'Vector database not initialized. Please configure it in settings.';
      console.error(errorMsg);
      setError(errorMsg);
      return;
    }
    try {
      // Clear previous results to free memory
      setSearchResults([]);
      setError(null);
      setSearchQuery(query);
      // Prepare filters for the search
      const filtersToUse = searchFilters || filters;
      const searchFiltersObj: any = {};
      // Only add non-'all' categories to the filter
      if (filtersToUse.category !== 'all') {
        searchFiltersObj.category = filtersToUse.category;
      }
      // Add other filters if they exist
      if (filtersToUse.language) searchFiltersObj.language = filtersToUse.language;
      if (filtersToUse.language_version) searchFiltersObj.language_version = filtersToUse.language_version;
      if (filtersToUse.framework) searchFiltersObj.framework = filtersToUse.framework;
      if (filtersToUse.framework_version) searchFiltersObj.framework_version = filtersToUse.framework_version;
      if (filtersToUse.library) searchFiltersObj.library = filtersToUse.library;
      if (filtersToUse.library_version) searchFiltersObj.library_version = filtersToUse.library_version;
      console.log(`Searching for "${query}" with filters:`, searchFiltersObj);
      // Search with the query and filters - limit to 10 results for memory savings
      const results = await searchDocuments(query, searchFiltersObj, 10);
      console.log(`Found ${results.length} results for "${query}"`);
      setSearchResults(results);
    } catch (err) {
      console.error('Error searching snippets:', err);
      setError('Failed to search documentation snippets');
      setSearchResults([]);
    }
  };
  // Update filters
  const updateFilters = (newFilters: Partial<KnowledgeBaseFilters>) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters
    }));
  };
  // Clear search results
  const clearSearch = () => {
    setSearchQuery('');
    setSearchResults([]);
  };
  // Load components and knowledge base when vector DB becomes initialized
  useEffect(() => {
    if (isInitialized && !componentsLoaded.current) {
      console.log('Vector DB is initialized, loading components');
      loadAvailableComponents();
    }
  }, [isInitialized]); // Depend on isInitialized instead of available
  // Load knowledge base separately
  useEffect(() => {
    if (isInitialized && !knowledgeBaseLoaded.current) {
      console.log('Vector DB is initialized, loading knowledge base');
      const loadKnowledgeBase = async () => {
        try {
          knowledgeBaseLoaded.current = true;
          const results = await getDocumentsByFilters({}, 100);
          console.log(`Loaded ${results.length} snippets from knowledge base`);
          setSnippets(results);
        } catch (err) {
          console.error('Error loading knowledge base:', err);
          setError(err instanceof Error ? err.message : 'Failed to load knowledge base');
        }
      };
      loadKnowledgeBase();
    }
  }, [isInitialized, getDocumentsByFilters]);
  return {
    searchQuery,
    searchResults,
    filters,
    loading,
    error,
    availableComponents,
    searchSnippets,
    updateFilters,
    clearSearch,
    loadAvailableComponents,
    snippets,
    isInitialized
  };
}
</file>

<file path="src/hooks/useProcessedUrls.ts">
import { useState, useEffect } from 'react';
import { useVectorDB } from './useVectorDB';
interface UrlSnippetCount {
  url: string;
  count: number | null;
}
/**
 * Hook to manage processed URLs for a session
 */
export function useProcessedUrls(sessionId: number) {
  const [processedUrls, setProcessedUrls] = useState<string[]>([]);
  const [urlSnippetCounts, setUrlSnippetCounts] = useState<UrlSnippetCount[]>([]);
  const [loading, setLoading] = useState(false);
  const [countLoading, setCountLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // Use the vectorDB hook with sessionId
  const { 
    vectorDB,
    loading: vectorDBLoading,
    error: vectorDBError,
    getDocumentsByFilters,
    getSnippetCountForUrl,
    updateURLStatus
  } = useVectorDB(sessionId);
  // Update error state when vectorDBError changes
  useEffect(() => {
    if (vectorDBError) {
      setError(vectorDBError.message);
    }
  }, [vectorDBError]);
  // Load processed URLs from the database
  const loadProcessedUrls = async () => {
    if (!sessionId || !vectorDB) return;
    try {
      setLoading(true);
      setError(null);
      // Get all URLs for the session
      const results = await getDocumentsByFilters({});
      // Filter to only get processed URLs
      const processed = results
        .map(doc => doc.source_url)
        .filter(Boolean)
        .filter(url => url.status === 'processed');
      setProcessedUrls(processed);
      // Initialize snippet counts as null (unknown)
      const initialCounts = processed.map(url => ({ url, count: null }));
      setUrlSnippetCounts(initialCounts);
      // Load snippet counts
      if (processed.length > 0) {
        loadSnippetCounts(processed);
      }
    } catch (err) {
      console.error('Error loading processed URLs:', err);
      setError('Failed to load processed URLs');
    } finally {
      setLoading(false);
    }
  };
  // Load snippet counts for URLs (optimized to avoid loading content)
  const loadSnippetCounts = async (urls: string[]) => {
    if (!urls.length || !vectorDB) return;
    try {
      setCountLoading(true);
      // Get counts for each URL - process in batches to avoid memory issues
      const BATCH_SIZE = 5;
      let counts: UrlSnippetCount[] = [];
      for (let i = 0; i < urls.length; i += BATCH_SIZE) {
        const batchUrls = urls.slice(i, i + BATCH_SIZE);
        const batchCounts: UrlSnippetCount[] = [];
        for (const url of batchUrls) {
          try {
            // Use the hook's method that handles the optional nature of the function
            const count = await getSnippetCountForUrl(url);
            batchCounts.push({
              url,
              count: count
            });
          } catch (err) {
            console.error(`Error getting snippet count for ${url}:`, err);
            batchCounts.push({
              url,
              count: null
            });
          }
        }
        // Update state with each batch to show progress
        counts = [...counts, ...batchCounts];
        setUrlSnippetCounts(prev => {
          const updatedCounts = [...prev];
          // Update counts for batch URLs
          for (const item of batchCounts) {
            const existingIndex = updatedCounts.findIndex(u => u.url === item.url);
            if (existingIndex >= 0) {
              updatedCounts[existingIndex] = item;
            } else {
              updatedCounts.push(item);
            }
          }
          return updatedCounts;
        });
      }
    } catch (err) {
      console.error('Error loading snippet counts:', err);
    } finally {
      setCountLoading(false);
    }
  };
  // Mark URLs as processed in the database
  const markUrlsAsProcessed = async (urls: string[]) => {
    if (!sessionId || !urls.length || !vectorDB) return;
    try {
      setLoading(true);
      setError(null);
      // Get all URLs for the session to find their IDs
      const results = await getDocumentsByFilters({});
      // Find matching URLs and update their status
      const urlsToUpdate = results
        .filter(doc => urls.includes(doc.source_url))
        .map(doc => doc.source_url);
      // Update each URL status
      for (const url of urlsToUpdate) {
        await updateURLStatus(url, 'processed');
      }
      // Add the new processed URLs to our state
      setProcessedUrls(prev => {
        const newProcessed = [...prev];
        // Add any URLs that aren't already in the list
        for (const url of urls) {
          if (!newProcessed.includes(url)) {
            newProcessed.push(url);
          }
        }
        return newProcessed;
      });
      // Update the snippet counts
      loadSnippetCounts(urls);
    } catch (err) {
      console.error('Error marking URLs as processed:', err);
      setError('Failed to update URL status');
    } finally {
      setLoading(false);
    }
  };
  // Get snippet count for a URL
  const getSnippetCount = (url: string): number | null => {
    const entry = urlSnippetCounts.find(item => item.url === url);
    return entry ? entry.count : null;
  };
  // Initial load of processed URLs
  useEffect(() => {
    if (sessionId && vectorDB) {
      loadProcessedUrls();
    }
  }, [sessionId, vectorDB]);
  return {
    processedUrls,
    getSnippetCount,
    loading: loading || countLoading || vectorDBLoading,
    error,
    loadProcessedUrls,
    markUrlsAsProcessed,
  };
}
</file>

<file path="src/hooks/useSnippets.ts">
import { useState, useEffect } from 'react';
import { FullDocumentationSnippet } from '../lib/db';
import { useVectorDB } from './useVectorDB';
/**
 * Hook to manage snippets for a specific URL
 */
export function useSnippets(sessionId: number) {
  const [snippets, setSnippets] = useState<FullDocumentationSnippet[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedUrl, setSelectedUrl] = useState<string | null>(null);
  // Use the vectorDB hook with sessionId
  const { 
    vectorDB,
    loading: vectorDBLoading,
    error: vectorDBError,
    isInitialized,
    getDocumentsByFilters
  } = useVectorDB(sessionId);
  // Update error state when vectorDBError changes
  useEffect(() => {
    if (vectorDBError) {
      setError(vectorDBError.message);
    }
  }, [vectorDBError]);
  /**
   * Fetch snippets for a specific URL
   */
  const fetchSnippets = async (url: string) => {
    if (!sessionId) {
      setError("No session selected");
      return;
    }
    if (!isInitialized) {
      setError("Vector database not initialized");
      return;
    }
    try {
      setLoading(true);
      setError(null);
      setSelectedUrl(url);
      // Clear any previous snippets to avoid memory accumulation
      setSnippets([]);
      // Get snippets for the URL (limited to 50 for memory conservation)
      const urlSnippets = await getDocumentsByFilters(
        { metadata: { url } },
        50
      );
      setSnippets(urlSnippets);
    } catch (err) {
      console.error('Error fetching snippets:', err);
      setError('Failed to fetch snippets from vector database');
      setSnippets([]);
    } finally {
      setLoading(false);
    }
  };
  /**
   * Clear the selected snippets
   */
  const clearSnippets = () => {
    setSnippets([]);
    setSelectedUrl(null);
  };
  return {
    snippets,
    loading: loading || vectorDBLoading,
    error,
    selectedUrl,
    fetchSnippets,
    clearSnippets,
    isInitialized
  };
}
</file>

<file path="src/hooks/useVectorDB.ts">
import { useState, useEffect, useRef } from 'react';
import { 
  VectorDBInstance, 
  VectorDBError, 
  getVectorDBInstance,
  DocumentFilter
} from '../lib/vector-db';
// Global cache for vector DB instances
const vectorDBCache = new Map<number, VectorDBInstance>();
const initializedSessions = new Set<number>();
/**
 * Hook for accessing a vector DB instance for a session
 */
export function useVectorDB(sessionId: number) {
  console.log(`useVectorDB hook called with sessionId: ${sessionId}`);
  // Use cached instance if available
  const [vectorDB, setVectorDB] = useState<VectorDBInstance | null>(() => vectorDBCache.get(sessionId) || null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [isInitialized, setIsInitialized] = useState(() => initializedSessions.has(sessionId));
  const initializationInProgress = useRef(false);
  const lastSessionId = useRef<number | null>(null);
  const initAttempts = useRef(0);
  const mountedRef = useRef(true);
  // Set up mounted ref
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);
  // Debug log for state changes
  useEffect(() => {
    console.log(`useVectorDB state changed:`, {
      sessionId,
      hasVectorDB: !!vectorDB,
      loading,
      error: error?.message || 'none',
      isInitialized,
      initializationInProgress: initializationInProgress.current,
      lastSessionId: lastSessionId.current,
      initAttempts: initAttempts.current,
      isInInitializedSet: initializedSessions.has(sessionId),
      cachedInstance: vectorDBCache.has(sessionId)
    });
  }, [sessionId, vectorDB, loading, error, isInitialized]);
  useEffect(() => {
    if (!mountedRef.current) return;
    console.log(`useVectorDB: Effect triggered for session ${sessionId}`, {
      currentState: {
        isInitialized,
        loading,
        hasVectorDB: !!vectorDB,
        initializationInProgress: initializationInProgress.current,
        lastSessionId: lastSessionId.current,
        initAttempts: initAttempts.current,
        isInInitializedSet: initializedSessions.has(sessionId),
        cachedInstance: vectorDBCache.has(sessionId)
      }
    });
    // Skip initialization if no valid session is selected
    if (sessionId <= 0) {
      console.log(`useVectorDB: No valid session selected (ID: ${sessionId}), resetting state`);
      if (mountedRef.current) {
        // Reset state when no session is selected
        if (vectorDB !== null) setVectorDB(null);
        if (loading) setLoading(false);
        if (error !== null) setError(null);
        if (isInitialized) {
          setIsInitialized(false);
          initializedSessions.delete(sessionId);
          vectorDBCache.delete(sessionId);
        }
        initAttempts.current = 0;
      }
      return;
    }
    // Check if we have a cached instance first
    const cachedInstance = vectorDBCache.get(sessionId);
    if (cachedInstance) {
      console.log(`useVectorDB: Using cached instance for session ${sessionId}`);
      if (!vectorDB) {
        setVectorDB(cachedInstance);
      }
      if (!isInitialized) {
        setIsInitialized(true);
        initializedSessions.add(sessionId);
      }
      return;
    }
    // Skip if this session is already initialized with a valid vectorDB
    if (lastSessionId.current === sessionId && vectorDB && isInitialized) {
      console.log(`useVectorDB: Vector DB for session ${sessionId} already initialized and available`);
      if (!initializedSessions.has(sessionId)) {
        initializedSessions.add(sessionId);
      }
      if (!vectorDBCache.has(sessionId)) {
        vectorDBCache.set(sessionId, vectorDB);
      }
      return;
    }
    // Skip if we're already initializing this session
    if (initializationInProgress.current) {
      console.log(`useVectorDB: Already initializing vector DB for session ${sessionId}, skipping duplicate init`);
      return;
    }
    // Prevent excessive initialization attempts
    if (initAttempts.current > 3) {
      console.error(`useVectorDB: Too many initialization attempts for session ${sessionId}, giving up`);
      if (mountedRef.current) {
        setError(new Error('Too many initialization attempts'));
        setLoading(false);
        initializedSessions.delete(sessionId);
        vectorDBCache.delete(sessionId);
      }
      return;
    }
    // Initialize vector DB
    async function initVectorDB() {
      initializationInProgress.current = true;
      lastSessionId.current = sessionId;
      initAttempts.current++;
      if (mountedRef.current) {
        setLoading(true);
        setError(null);
      }
      try {
        console.log(`useVectorDB: Starting getVectorDBInstance for session ${sessionId} (attempt ${initAttempts.current})`);
        const instance = await getVectorDBInstance(sessionId);
        if (mountedRef.current) {
          console.log(`useVectorDB: Successfully got instance for session ${sessionId}, setting state...`);
          setVectorDB(instance);
          setIsInitialized(true);
          initializedSessions.add(sessionId);
          vectorDBCache.set(sessionId, instance);
          setLoading(false);
          console.log(`useVectorDB: State updated for session ${sessionId} - isInitialized=true, loading=false`);
        } else {
          console.log(`useVectorDB: Component unmounted during initialization of session ${sessionId}`);
          // Still cache the instance even if component unmounted
          vectorDBCache.set(sessionId, instance);
          initializedSessions.add(sessionId);
        }
      } catch (err) {
        console.error(`useVectorDB: Error initializing vector DB for session ${sessionId} (attempt ${initAttempts.current}):`, err);
        if (mountedRef.current) {
          const errorMessage = err instanceof Error ? err.message : String(err);
          console.log(`useVectorDB: Setting error state for session ${sessionId}: ${errorMessage}`);
          setError(err instanceof Error ? err : new Error(String(err)));
          setLoading(false);
          setVectorDB(null);
          setIsInitialized(false);
          initializedSessions.delete(sessionId);
          vectorDBCache.delete(sessionId);
        }
      } finally {
        initializationInProgress.current = false;
      }
    }
    // Only initialize if not already initialized for this session
    if (!isInitialized || lastSessionId.current !== sessionId) {
      initVectorDB();
    }
    return () => {
      console.log(`useVectorDB: Cleanup for session ${sessionId}`);
    };
  }, [sessionId, isInitialized, vectorDB]);
  /**
   * Add documents to the vector DB
   */
  const addDocuments = async (documents: any[]): Promise<void> => {
    if (!vectorDB) {
      const error = new VectorDBError('Vector DB not initialized');
      console.error('Cannot add documents:', error.message);
      throw error;
    }
    try {
      console.log(`Adding ${documents.length} documents to vector DB...`);
      await vectorDB.addDocuments(documents);
      console.log(`Successfully added ${documents.length} documents to vector DB`);
    } catch (err) {
      console.error('Error adding documents to vector DB:', err);
      throw err;
    }
  };
  /**
   * Search for documents in the vector DB
   */
  const searchDocuments = async (
    query: string | number[], 
    filters?: DocumentFilter, 
    limit?: number
  ): Promise<any[]> => {
    if (!vectorDB) {
      const error = new VectorDBError('Vector DB not initialized');
      console.error('Cannot search documents:', error.message);
      throw error;
    }
    try {
      console.log(`Searching vector DB with query "${typeof query === 'string' ? query : '[vector]'}" and filters:`, filters);
      const results = await vectorDB.searchDocuments(query, filters, limit);
      console.log(`Search returned ${results.length} results`);
      return results;
    } catch (err) {
      console.error('Error searching documents in vector DB:', err);
      throw err;
    }
  };
  /**
   * Get documents by filters from the vector DB
   */
  const getDocumentsByFilters = async (
    filters?: DocumentFilter, 
    limit?: number
  ): Promise<any[]> => {
    if (!vectorDB) {
      const error = new VectorDBError('Vector DB not initialized');
      console.error('Cannot get documents by filters:', error.message);
      throw error;
    }
    try {
      console.log(`Getting documents from vector DB with filters:`, filters);
      const results = await vectorDB.getDocumentsByFilters(filters, limit);
      console.log(`Retrieved ${results.length} documents by filters`);
      return results;
    } catch (err) {
      console.error('Error getting documents by filters from vector DB:', err);
      throw err;
    }
  };
  /**
   * Get the count of snippets for a specific URL
   */
  const getSnippetCountForUrl = async (url: string): Promise<number> => {
    if (!vectorDB) {
      const error = new VectorDBError('Vector DB not initialized');
      console.error('Cannot get snippet count for URL:', error.message);
      throw error;
    }
    try {
      console.log(`Getting snippet count for URL: ${url}`);
      // If the vectorDB instance has this method, use it
      if (vectorDB.getSnippetCountForUrl) {
        const count = await vectorDB.getSnippetCountForUrl(url);
        console.log(`Found ${count} snippets for URL: ${url}`);
        return count;
      } else {
        // Fallback implementation using getDocumentsByFilters
        console.log(`Using fallback method to get snippet count for URL: ${url}`);
        const snippets = await vectorDB.getDocumentsByFilters({ metadata: { url } });
        console.log(`Found ${snippets.length} snippets for URL: ${url} (fallback method)`);
        return snippets.length;
      }
    } catch (err) {
      console.error(`Error getting snippet count for URL ${url}:`, err);
      throw err;
    }
  };
  /**
   * Update the status of a URL in the vector DB
   */
  const updateURLStatus = async (url: string, status: string): Promise<void> => {
    if (!vectorDB) {
      const error = new VectorDBError('Vector DB not initialized');
      console.error('Cannot update URL status:', error.message);
      throw error;
    }
    try {
      console.log(`Updating status for URL ${url} to ${status}`);
      // If the vectorDB instance has this method, use it
      if (vectorDB.updateURLStatus) {
        await vectorDB.updateURLStatus(url, status);
        console.log(`Successfully updated status for URL ${url} to ${status}`);
        return;
      } else {
        // Since we can't directly update documents (no updateDocument method in the interface),
        // we'll need to remove the old documents and add new ones with updated status
        console.log(`Using fallback method to update status for URL ${url}`);
        const documents = await vectorDB.getDocumentsByFilters({ metadata: { url } });
        // If we have documents to update
        if (documents.length > 0) {
          console.log(`Found ${documents.length} documents to update for URL ${url}`);
          // Create new documents with updated status
          const updatedDocuments = documents.map(doc => {
            if (doc.metadata) {
              return {
                ...doc,
                metadata: {
                  ...doc.metadata,
                  status
                }
              };
            }
            return doc;
          });
          // Remove old documents and add updated ones
          // Note: This is a workaround since we don't have direct update capability
          // This might not be optimal for all vector DB implementations
          try {
            // Add the updated documents
            await vectorDB.addDocuments(updatedDocuments);
            console.log(`Successfully updated status for ${url} to ${status} (fallback method)`);
          } catch (err) {
            console.error(`Error updating URL status for ${url}:`, err);
            throw new VectorDBError(`Failed to update URL status: ${err instanceof Error ? err.message : String(err)}`);
          }
        } else {
          console.log(`No documents found for URL ${url}, nothing to update`);
        }
      }
    } catch (err) {
      console.error(`Error updating URL status for ${url}:`, err);
      throw err;
    }
  };
  return {
    vectorDB,
    loading,
    error,
    isInitialized,
    addDocuments,
    searchDocuments,
    getDocumentsByFilters,
    getSnippetCountForUrl,
    updateURLStatus
  };
}
</file>

<file path="src/lib/vector-db/providers/chroma.ts">
import { ContextType, DocumentFilter, VectorDBError, VectorDBInstance, VectorDBProvider } from '../types';
import { generateEmbedding } from '../../openai';
import { updateURLStatusByUrl } from '../../db';
export interface ChromaConfig {
  host: string;
  port: number;
  apiKey: string; // OpenAI API key for embedding generation
  collectionName?: string;
}
export class ChromaProvider implements VectorDBProvider {
  async createInstance(sessionId: number): Promise<VectorDBInstance> {
    return new ChromaInstance(sessionId);
  }
  async configure(sessionId: number, config: any): Promise<void> {
    // Configuration is handled during instance initialization
  }
}
class ChromaInstance implements VectorDBInstance {
  private client: any;
  private collection: any;
  private config!: ChromaConfig;
  private initialized: boolean = false;
  constructor(private sessionId: number) {}
  async initialize(config?: ChromaConfig): Promise<void> {
    try {
      if (config) {
        this.config = config;
      }
      // Initialize ChromaDB client
      // This is a placeholder for the actual implementation
      // In a real implementation, we would use the ChromaDB client library
      this.client = {
        getOrCreateCollection: async (name: string) => {
          return {
            add: async (documents: any) => {},
            query: async (query: any) => {}
          };
        }
      };
      // Get or create collection
      const collectionName = this.config.collectionName || 'default';
      this.collection = await this.client.getOrCreateCollection(collectionName);
      this.initialized = true;
    } catch (error) {
      throw new VectorDBError('Failed to initialize ChromaDB provider', error as Error);
    }
  }
  /**
   * Update the OpenAI API key used for generating embeddings
   */
  updateApiKey(apiKey: string): void {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    console.log(`Updating OpenAI API key in ChromaDB instance: ${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}`);
    this.config.apiKey = apiKey;
  }
  async addDocuments(documents: any[]): Promise<void> {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    try {
      // Process documents to add embeddings
      const processedDocuments = await Promise.all(documents.map(async (doc) => {
        // Generate embedding for document content
        const embedding = await generateEmbedding(
          doc.content, 
          this.config.apiKey
        );
        return {
          id: doc.id,
          embedding: embedding,
          metadata: {
            ...doc.metadata,
            content: doc.content
          }
        };
      }));
      // Add documents to collection
      await this.collection.add({
        ids: processedDocuments.map(doc => doc.id),
        embeddings: processedDocuments.map(doc => doc.embedding),
        metadatas: processedDocuments.map(doc => doc.metadata)
      });
    } catch (error) {
      throw new VectorDBError('Failed to add documents to ChromaDB', error as Error);
    }
  }
  async searchDocuments(query: string | number[], filters?: DocumentFilter, limit: number = 10): Promise<any[]> {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    try {
      // If query is a string, generate embedding
      const embedding = typeof query === 'string' 
        ? await generateEmbedding(query, this.config.apiKey)
        : query;
      // Convert filters to ChromaDB format
      const whereClause = filters ? this._convertFiltersToWhereClause(filters) : undefined;
      // Search collection with embedding and filters
      const results = await this.collection.query({
        queryEmbeddings: [embedding],
        nResults: limit,
        where: whereClause
      });
      // Format results
      return this._formatSearchResults(results);
    } catch (error) {
      throw new VectorDBError('Failed to search documents in ChromaDB', error as Error);
    }
  }
  async getDocumentsByFilters(filters?: DocumentFilter, limit: number = 10): Promise<any[]> {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    try {
      // Convert filters to ChromaDB format
      const whereClause = filters ? this._convertFiltersToWhereClause(filters) : undefined;
      // Get documents by filters
      const results = await this.collection.query({
        nResults: limit,
        where: whereClause
      });
      // Format results
      return this._formatSearchResults(results);
    } catch (error) {
      throw new VectorDBError('Failed to get documents from ChromaDB', error as Error);
    }
  }
  async getSnippetCountForUrl(url: string): Promise<number> {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    try {
      const results = await this.getDocumentsByFilters({ url });
      return results.length;
    } catch (error) {
      throw new VectorDBError('Failed to get snippet count from ChromaDB', error as Error);
    }
  }
  async updateURLStatus(url: string, status: string): Promise<void> {
    if (!this.initialized) {
      throw new VectorDBError('ChromaDB provider not initialized');
    }
    try {
      // Get existing documents for this URL
      const documents = await this.getDocumentsByFilters({ url });
      // Update each document's metadata with the new status
      const updatedDocuments = documents.map(doc => ({
        ...doc,
        metadata: {
          ...doc.metadata,
          status
        }
      }));
      // Remove old documents and add updated ones
      // Note: In a real implementation, we would use a proper update mechanism
      if (updatedDocuments.length > 0) {
        await this.addDocuments(updatedDocuments);
      }
      // Also update the status in the SQL database
      await updateURLStatusByUrl(url, status);
    } catch (error) {
      throw new VectorDBError(`Failed to update URL status in ChromaDB: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  isAvailable(): boolean {
    return this.initialized;
  }
  getContextType(): ContextType {
    return ContextType.LOCAL;
  }
  // Helper methods
  private _convertFiltersToWhereClause(filters: DocumentFilter): any {
    // Convert filters to ChromaDB where clause format
    const whereClause: Record<string, any> = {};
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined) {
        whereClause[key] = value;
      }
    }
    return whereClause;
  }
  private _formatSearchResults(results: any): any[] {
    // Format ChromaDB results to a consistent format
    if (!results || !results.ids) {
      return [];
    }
    const { ids, metadatas, distances } = results;
    return ids[0].map((id: string, index: number) => {
      return {
        id,
        metadata: metadatas[0][index],
        score: distances ? 1 - distances[0][index] : 1, // Convert distance to similarity score
      };
    });
  }
}
</file>

<file path="src/lib/vector-db/providers/pinecone.ts">
import { ContextType, DocumentFilter, VectorDBError, VectorDBInstance, VectorDBProvider } from '../types';
import { generateEmbedding } from '../../openai';
import { invoke } from '@tauri-apps/api/core';
export interface PineconeConfig {
  apiKey: string;
  indexName: string;
  openAIApiKey: string;
}
export class PineconeProvider implements VectorDBProvider {
  async createInstance(sessionId: number): Promise<VectorDBInstance> {
    return new PineconeInstance(sessionId);
  }
}
class PineconeInstance implements VectorDBInstance {
  private config!: PineconeConfig;
  private initialized: boolean = false;
  constructor(private sessionId: number) {}
  async initialize(config: PineconeConfig): Promise<void> {
    try {
      if (!config) {
        throw new VectorDBError('Configuration is required for Pinecone initialization');
      }
      if (!config.apiKey) {
        throw new VectorDBError('API key is required for Pinecone initialization');
      }
      if (!config.indexName) {
        throw new VectorDBError('Index name is required for Pinecone initialization');
      }
      if (!config.openAIApiKey) {
        throw new VectorDBError('OpenAI API key is required for Pinecone initialization');
      }
      this.config = config;
      // Log the configuration being sent to Rust
      console.log('Initializing Pinecone with config:', {
        sessionId: this.sessionId,
        config: {
          api_key: config.apiKey ? `${config.apiKey.substring(0, 5)}...` : 'missing',
          index_name: config.indexName || 'missing'
        }
      });
      // Initialize Pinecone using Tauri command
      await invoke('initialize_vector_db', {
        sessionId: this.sessionId,
        config: {
          api_key: config.apiKey,
          index_name: config.indexName
        }
      });
      console.log('Pinecone initialized successfully');
      this.initialized = true;
    } catch (error) {
      console.error('Pinecone initialization error:', error);
      throw new VectorDBError('Failed to initialize Pinecone provider', error as Error);
    }
  }
  async addDocuments(documents: any[]): Promise<void> {
    if (!this.initialized) {
      throw new VectorDBError('Pinecone provider not initialized');
    }
    try {
      console.log(`[PineconeInstance] Processing ${documents.length} documents for embedding...`);
      // Generate embeddings client-side since we need OpenAI key
      const processedDocuments = await Promise.all(documents.map(async (doc, index) => {
        console.log(`[PineconeInstance] Generating embedding for document ${index+1}/${documents.length}, ID: ${doc.id}`);
        try {
          const embedding = await generateEmbedding(doc.content, this.config.openAIApiKey);
          console.log(`[PineconeInstance] Embedding generated for document ${index+1}, length: ${embedding.length}`);
          // Ensure each document has an ID and metadata
          const id = doc.id || `doc-${Date.now()}-${index}`;
          // Create metadata object with all document fields
          const metadata = {
            content: doc.content,
            category: doc.category,
            language: doc.language,
            language_version: doc.language_version,
            framework: doc.framework,
            framework_version: doc.framework_version,
            library: doc.library,
            library_version: doc.library_version,
            title: doc.title,
            description: doc.description,
            source_url: doc.source_url,
            concepts: doc.concepts,
            ...doc.metadata // Include any additional metadata
          };
          // Remove undefined values
          Object.keys(metadata).forEach(key => {
            if (metadata[key] === undefined) {
              delete metadata[key];
            }
          });
          return {
            id: id,
            content: doc.content,
            embedding: embedding,
            metadata: metadata
          };
        } catch (embeddingError) {
          console.error(`[PineconeInstance] Error generating embedding for document ${index+1}:`, embeddingError);
          throw new Error(`Failed to generate embedding for document ${doc.id}: ${embeddingError}`);
        }
      }));
      console.log(`[PineconeInstance] Sending ${processedDocuments.length} documents to Rust with sessionId: ${this.sessionId}`);
      if (processedDocuments.length > 0) {
        const sample = processedDocuments[0];
        console.log(`[PineconeInstance] Sample processed document:`, {
          id: sample.id,
          embeddingLength: sample.embedding.length,
          contentPreview: sample.content.substring(0, 50) + '...',
          metadataKeys: sample.metadata ? Object.keys(sample.metadata) : 'empty object'
        });
      }
      try {
        // Add documents using Tauri command
        console.log(`[PineconeInstance] Invoking Rust 'add_documents' command...`);
        await invoke('add_documents', {
          sessionId: this.sessionId,
          documents: processedDocuments
        });
        console.log(`[PineconeInstance] Successfully added ${processedDocuments.length} documents to Pinecone`);
      } catch (invokeError) {
        console.error(`[PineconeInstance] Error invoking Rust 'add_documents' command:`, invokeError);
        throw invokeError;
      }
    } catch (error) {
      console.error('[PineconeInstance] Error in addDocuments:', error);
      throw new VectorDBError('Failed to add documents to Pinecone', error as Error);
    }
  }
  async searchDocuments(query: string | number[], filters?: DocumentFilter, limit: number = 10): Promise<any[]> {
    if (!this.initialized) {
      throw new VectorDBError('Pinecone provider not initialized');
    }
    try {
      const embedding = typeof query === 'string' 
        ? await generateEmbedding(query, this.config.openAIApiKey)
        : query;
      console.log('Searching Pinecone with:', {
        sessionId: this.sessionId,
        embeddingLength: embedding.length,
        filters: filters ? JSON.stringify(filters) : 'none',
        limit
      });
      // Search documents using Tauri command
      const results = await invoke<any[]>('search_documents', {
        sessionId: this.sessionId,
        embedding: embedding,
        filter: filters,
        limit: limit
      });
      console.log('Pinecone search results:', {
        count: results ? (Array.isArray(results) ? results.length : 'not an array') : 'null',
        sample: results && Array.isArray(results) && results.length > 0 ? results[0] : null
      });
      return this._formatSearchResults(results);
    } catch (error) {
      console.error('Pinecone search error:', error);
      throw new VectorDBError('Failed to search documents in Pinecone', error as Error);
    }
  }
  async getDocumentsByFilters(filters?: DocumentFilter, limit: number = 10): Promise<any[]> {
    if (!this.initialized) {
      throw new VectorDBError('Pinecone provider not initialized');
    }
    try {
      console.log('Getting documents by filters:', {
        sessionId: this.sessionId,
        filters: filters ? JSON.stringify(filters) : 'none',
        limit
      });
      // For filter-only queries, use a zero vector as the query vector
      // Use 3072 dimensions for text-embedding-3-large model
      const zeroVector = new Array(3072).fill(0);
      return await this.searchDocuments(zeroVector, filters, limit);
    } catch (error) {
      console.error('Error getting documents by filters:', error);
      throw new VectorDBError('Failed to get documents from Pinecone', error as Error);
    }
  }
  async getSnippetCountForUrl(url: string): Promise<number> {
    if (!this.initialized) {
      throw new VectorDBError('Pinecone provider not initialized');
    }
    try {
      const results = await this.getDocumentsByFilters({ source_url: url });
      return results.length;
    } catch (error) {
      throw new VectorDBError('Failed to get snippet count from Pinecone', error as Error);
    }
  }
  async updateURLStatus(url: string, status: string): Promise<void> {
    if (!this.initialized) {
      throw new VectorDBError('Pinecone provider not initialized');
    }
    try {
      // Get documents by URL
      const documents = await this.getDocumentsByFilters({ source_url: url });
      // Update each document's metadata with the new status
      const updatedDocuments = documents.map(doc => ({
        ...doc,
        metadata: {
          ...doc.metadata,
          status
        }
      }));
      // Re-add the updated documents
      if (updatedDocuments.length > 0) {
        await this.addDocuments(updatedDocuments);
      }
    } catch (error) {
      throw new VectorDBError(`Failed to update URL status in Pinecone: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  isAvailable(): boolean {
    return this.initialized;
  }
  getContextType(): ContextType {
    return ContextType.SHARED;
  }
  private _formatSearchResults(results: any): any[] {
    if (!results || !Array.isArray(results)) {
      console.warn('Unexpected results format from Pinecone search:', results);
      return [];
    }
    return results.map((match: any) => ({
      id: match.id,
      metadata: match.metadata || {},
      score: 1.0 // Default score since Pinecone doesn't return scores in this implementation
    }));
  }
}
</file>

<file path="src/lib/vector-db/index.ts">
// Re-export types
export * from './types';
// Re-export service functions
export { 
  getVectorDBInstance,
  clearVectorDBInstanceCache,
  clearAllVectorDBInstanceCaches
} from './service';
// Re-export provider implementations
export { ChromaProvider } from './providers/chroma';
export { PineconeProvider } from './providers/pinecone';
</file>

<file path="src/lib/vector-db/README.md">
# Vector Database Service

This directory contains the implementation of the vector database service for the Anchoring desktop application. The service provides a consistent interface for interacting with different vector database providers, such as ChromaDB (local) and Pinecone (shared).

## Architecture Overview

The vector database service is designed with the following components:

- **Core Types**: Defines interfaces and types for vector DB functionality
- **Service Layer**: Provides functions for managing vector DB instances
- **Provider Implementations**: Adapters for different vector DB backends (ChromaDB, Pinecone)
- **Settings Management**: Global settings for vector DB providers

## Database Schema

The vector DB functionality uses the following table in the SQLite database:

- `vector_db_settings`: Stores global settings for vector DB providers (Pinecone API key, environment, index)

## Directory Structure

- `types.ts`: Core interfaces and types for the vector database system
- `service.ts`: Main service functions for configuring and using vector databases
- `index.ts`: Public API exports
- `providers/`: Directory containing provider implementations
  - `chroma.ts`: ChromaDB provider implementation
  - `pinecone.ts`: Pinecone provider implementation

## Usage

### Basic Usage

```typescript
import { getVectorDBInstance } from '../lib/vector-db';

// Get a vector DB instance for a session
const vectorDB = await getVectorDBInstance(sessionId);

// Add documents to the vector DB
await vectorDB.addDocuments(documents);

// Search for documents
const results = await vectorDB.searchDocuments('query', { category: 'language' }, 10);

// Get documents by filters
const docs = await vectorDB.getDocumentsByFilters({ category: 'language' }, 10);
```

### Settings Management

```typescript
import { saveVectorDBSettings, getVectorDBSettings } from '../lib/db';

// Save vector DB settings
await saveVectorDBSettings({
  pinecone_api_key: 'your-pinecone-api-key',
  pinecone_environment: 'your-environment',
  pinecone_index: 'your-index'
});

// Get vector DB settings
const settings = await getVectorDBSettings();
console.log(settings.pinecone_api_key);
```

## Provider Selection

The system automatically selects the appropriate vector DB provider based on the global settings:

- If Pinecone settings (API key, environment, and index) are configured, the Pinecone provider is used
- Otherwise, the local ChromaDB provider is used

This selection happens in the `getVectorDBInstance` function in `service.ts`:

```typescript
// Determine which provider to use based on settings
const providerName = settings.pinecone_api_key && 
                     settings.pinecone_environment && 
                     settings.pinecone_index ? 'pinecone' : 'chroma';
```

## Error Handling

All service functions throw a `VectorDBError` when an error occurs. This error includes the original error as the `cause` property.

```typescript
import { getVectorDBInstance, VectorDBError } from '../lib/vector-db';

try {
  const vectorDB = await getVectorDBInstance(sessionId);
} catch (error) {
  if (error instanceof VectorDBError) {
    console.error('Vector DB error:', error.message);
    console.error('Cause:', error.cause);
  }
}
```

## Extending

To add a new provider, create a new file in the `providers/` directory that implements the `VectorDBProvider` interface, and register it in the provider registry in `service.ts`.

```typescript
import { VectorDBInstance, VectorDBProvider } from '../types';

export class NewProvider implements VectorDBProvider {
  async createInstance(sessionId: number): Promise<VectorDBInstance> {
    return new NewProviderInstance(sessionId);
  }
}

class NewProviderInstance implements VectorDBInstance {
  // Implementation
}
```

## Integration with Database

The vector DB service integrates with the main database through the following functions in `db.ts`:

- **Settings Management**:
  - `saveVectorDBSettings`: Save global vector DB settings
  - `getVectorDBSettings`: Get global vector DB settings

## Implementation Notes

- The service uses a caching mechanism to avoid recreating vector DB instances for the same session
- Provider implementations handle the details of connecting to and interacting with the underlying vector DB
- The service is designed to be extensible with new providers
- All sessions use the global vector DB settings for connecting to the appropriate provider

### Direct API Usage

You can use the vector DB API directly:

```tsx
import { getVectorDBInstance } from '@/lib/vector-db';

// Get an instance for a session
const instance = await getVectorDBInstance(sessionId);

// Use the instance
const results = await instance.searchDocuments('query', { category: 'language' }, 10);
```

### Error Handling

All vector DB operations can throw errors, which should be caught and handled appropriately:

```tsx
try {
  const results = await vectorDB.searchDocuments('query');
  // Process results
} catch (error) {
  console.error('Error searching vector DB:', error);
  // Handle error
}
```
</file>

<file path="src/lib/vector-db/service.ts">
import { getVectorDBSettings, getUserSettings } from '../db';
import { VectorDBInstance, VectorDBError, VectorDBProvider } from './types';
import { ChromaProvider } from './providers/chroma';
import { PineconeProvider } from './providers/pinecone';
// Extend the VectorDBSettings type to include openai_key
interface ExtendedVectorDBSettings {
  pinecone_api_key: string;
  pinecone_index: string;
  openai_key?: string;
}
// Cache of vector DB instances
const instanceCache = new Map<number, VectorDBInstance>();
// Simple provider registry
const providers: Record<string, VectorDBProvider> = {
  'chroma': new ChromaProvider(),
  'pinecone': new PineconeProvider()
};
/**
 * Create a vector DB instance with an API key
 */
export async function createProviderWithKey(apiKey: string): Promise<VectorDBInstance> {
  // Get global vector DB settings
  const settings = await getVectorDBSettings() as ExtendedVectorDBSettings;
  // Use Pinecone as the default provider
  const provider = providers['pinecone'];
  if (!provider) {
    throw new VectorDBError(`Invalid vector DB provider: pinecone`);
  }
  // Create instance with a temporary session ID
  const tempSessionId = Date.now(); // Use timestamp as temporary session ID
  const instance = await provider.createInstance(tempSessionId);
  // Initialize with the provided API key
  await instance.initialize({
    apiKey: settings.pinecone_api_key,
    indexName: settings.pinecone_index,
    openAIApiKey: apiKey // Use the provided API key
  });
  return instance;
}
/**
 * Get a vector DB instance for a session
 */
export async function getVectorDBInstance(sessionId: number): Promise<VectorDBInstance> {
  console.log(`getVectorDBInstance called for session ${sessionId}`);
  // Check cache first
  const cached = instanceCache.get(sessionId);
  if (cached) {
    console.log(`getVectorDBInstance: Cache hit for session ${sessionId}`);
    return cached;
  }
  console.log(`getVectorDBInstance: Cache miss for session ${sessionId}, creating new instance`);
  // Get global vector DB settings
  console.log(`getVectorDBInstance: Fetching vector DB settings for session ${sessionId}`);
  const settings = await getVectorDBSettings() as ExtendedVectorDBSettings;
  console.log(`getVectorDBInstance: Vector DB settings loaded:`, {
    hasPineconeApiKey: !!settings.pinecone_api_key,
    hasPineconeIndex: !!settings.pinecone_index,
  });
  // Get user settings to get the OpenAI API key
  console.log(`getVectorDBInstance: Fetching user settings for session ${sessionId}`);
  const userSettings = await getUserSettings();
  const openAIApiKey = userSettings?.openai_key || '';
  // Log the API key for debugging (first and last few characters)
  if (openAIApiKey) {
    console.log(`getVectorDBInstance: Using OpenAI API key: ${openAIApiKey.substring(0, 5)}...${openAIApiKey.substring(openAIApiKey.length - 4)}`);
  } else {
    console.error("getVectorDBInstance: No OpenAI API key found in user settings");
  }
  // Validate Pinecone settings - ensure we have actual values, not just empty strings
  const hasPineconeSettings = settings.pinecone_api_key?.trim() && 
                             settings.pinecone_index?.trim();
  // Determine which provider to use based on settings
  // If Pinecone settings are configured, use Pinecone, otherwise use ChromaDB
  const providerName = hasPineconeSettings ? 'pinecone' : 'chroma';
  console.log(`getVectorDBInstance: Using provider ${providerName} for session ${sessionId}`, {
    hasPineconeSettings,
    pineconeApiKey: settings.pinecone_api_key ? `${settings.pinecone_api_key.substring(0, 5)}...` : 'missing',
    pineconeIndex: settings.pinecone_index || 'missing',
    hasOpenAIKey: !!openAIApiKey
  });
  const provider = providers[providerName];
  if (!provider) {
    const error = new VectorDBError(`Invalid vector DB provider: ${providerName}`);
    console.error(`getVectorDBInstance: ${error.message}`);
    throw error;
  }
  try {
    // Create instance
    console.log(`getVectorDBInstance: Creating instance with provider ${providerName} for session ${sessionId}`);
    const instance = await provider.createInstance(sessionId);
    // Configure the instance based on the provider type
    if (providerName === 'pinecone') {
      if (!hasPineconeSettings) {
        const error = new VectorDBError('Pinecone settings are not properly configured. Please check your settings.');
        console.error(`getVectorDBInstance: ${error.message}`);
        throw error;
      }
      console.log(`getVectorDBInstance: Initializing Pinecone instance for session ${sessionId}`);
      await instance.initialize({
        apiKey: settings.pinecone_api_key,
        indexName: settings.pinecone_index,
        openAIApiKey: openAIApiKey // Use the OpenAI API key from user settings
      });
    } else {
      // ChromaDB configuration
      console.log(`getVectorDBInstance: Initializing ChromaDB instance for session ${sessionId}`);
      await instance.initialize({
        host: 'localhost', // Default ChromaDB host
        port: 8000, // Default ChromaDB port
        apiKey: openAIApiKey, // OpenAI API key for embeddings
        collectionName: `session-${sessionId}`
      });
    }
    console.log(`getVectorDBInstance: Successfully initialized ${providerName} instance for session ${sessionId}`);
    // Cache instance
    instanceCache.set(sessionId, instance);
    console.log(`getVectorDBInstance: Cached instance for session ${sessionId}`);
    return instance;
  } catch (error) {
    console.error(`getVectorDBInstance: Error creating/initializing instance for session ${sessionId}:`, error);
    throw error;
  }
}
/**
 * Clear the vector DB instance cache for a session
 */
export function clearVectorDBInstanceCache(sessionId: number): void {
  instanceCache.delete(sessionId);
}
/**
 * Clear all vector DB instance caches
 */
export function clearAllVectorDBInstanceCaches(): void {
  instanceCache.clear();
}
</file>

<file path="src/lib/vector-db/types.ts">
export enum ContextType {
  LOCAL = 'local',
  SHARED = 'shared'
}
export interface DocumentFilter {
  category?: string;
  language?: string;
  framework?: string;
  library?: string;
  [key: string]: any;
}
export interface VectorDBInstance {
  /**
   * Initialize the vector DB instance with the given configuration
   */
  initialize(config: any): Promise<void>;
  /**
   * Add documents to the vector DB
   */
  addDocuments(documents: any[]): Promise<void>;
  /**
   * Search for documents using a query string or embedding
   */
  searchDocuments(query: string | number[], filters?: DocumentFilter, limit?: number): Promise<any[]>;
  /**
   * Get documents by filters without a query
   */
  getDocumentsByFilters(filters?: DocumentFilter, limit?: number): Promise<any[]>;
  /**
   * Get the count of snippets for a specific URL
   */
  getSnippetCountForUrl(url: string): Promise<number>;
  /**
   * Update the status of a URL in the vector DB
   */
  updateURLStatus(url: string, status: string): Promise<void>;
  /**
   * Check if the vector DB is available
   */
  isAvailable(): boolean;
  /**
   * Get the context type (LOCAL or SHARED)
   */
  getContextType(): ContextType;
  /**
   * Update the OpenAI API key used for generating embeddings
   */
  updateApiKey?(apiKey: string): void;
}
export interface VectorDBProvider {
  /**
   * Create a new instance for the given session
   */
  createInstance(sessionId: number): Promise<VectorDBInstance>;
}
export interface VectorDBConfig {
  provider: string;
  config: Record<string, any>;
}
export class VectorDBError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'VectorDBError';
  }
}
</file>

<file path="src/lib/crawler.ts">
import { addURL, updateURLContent, updateURLStatus, getURLByUrl, getProxies } from './db';
import TurndownService from 'turndown';
// Global state to track if crawling is in progress
let isCrawling = false;
let crawlingStopped = false;
let activeCrawlUrls: string[] = [];
// Global URL cache to prevent duplicate crawling across concurrent processes
const globalVisitedUrls = new Set<string>();
// Proxy rotation queue
const proxyQueue: string[] = [];
// Set to track which proxies are currently in use (to avoid duplicates in the queue)
const activeProxies = new Set<string>();
// Function to stop any active crawling
export const stopCrawling = (): void => {
  console.log("Stopping all crawling activities");
  crawlingStopped = true;
  isCrawling = false;
  activeCrawlUrls = [];
  console.log("Crawling has been stopped. Current urls being processed will finish.");
};
// Function to reset crawler state after stopping
export const resetCrawlerState = (): void => {
  console.log("Resetting crawler state");
  crawlingStopped = false;
  isCrawling = false;
  activeCrawlUrls = [];
  globalVisitedUrls.clear();
};
// Function to check if crawling is in progress
export const getCrawlingStatus = (): { isCrawling: boolean, activeCrawlUrls: string[] } => {
  // Only report as crawling if we have active URLs or the flag is explicitly set
  const actuallyIsCrawling = isCrawling && (activeCrawlUrls.length > 0 || crawlingStopped);
  // If we're not actually crawling but the flag says we are, reset it
  if (!actuallyIsCrawling && isCrawling) {
    console.log("No active URLs but crawling flag was set. Resetting crawler state.");
    isCrawling = false;
  }
  return { 
    isCrawling: actuallyIsCrawling, 
    activeCrawlUrls: [...activeCrawlUrls] 
  };
};
// Interface for crawler configuration
export interface CrawlerConfig {
  startUrl: string;
  prefixPath: string;
  antiPaths: string[];
  antiKeywords: string[];
  sessionId: number;
  maxConcurrentRequests?: number; // Optional param for controlling parallelism
  unlimitedParallelism?: boolean; // Optional param to enable unlimited parallelism
}
// Function to check if URL should be crawled based on config
export const shouldCrawlURL = (url: string, config: CrawlerConfig): boolean => {
  // Check if URL is null, undefined, or empty
  if (!url || url.trim() === '') {
    console.log(`Rejecting invalid URL: ${url}`);
    return false;
  }
  try {
    // Try to parse the URL to validate it
    new URL(url);
  } catch (e) {
    console.log(`Rejecting malformed URL: ${url}`);
    return false;
  }
  // Check if URL starts with the prefix path
  if (!url.startsWith(config.prefixPath)) {
    console.log(`URL not matching prefix. URL: ${url}, Prefix: ${config.prefixPath}`);
    return false;
  }
  // Check if URL contains any anti-paths
  if (config.antiPaths.length > 0 && config.antiPaths.some(path => {
    if (path && path.trim() !== '' && url.includes(path)) {
      console.log(`URL contains excluded path. URL: ${url}, Excluded Path: ${path}`);
      return true;
    }
    return false;
  })) {
    return false;
  }
  // Check if URL contains any anti-keywords
  if (config.antiKeywords.length > 0 && config.antiKeywords.some(keyword => {
    if (keyword && keyword.trim() !== '' && url.includes(keyword)) {
      console.log(`URL contains excluded keyword. URL: ${url}, Excluded Keyword: ${keyword}`);
      return true;
    }
    return false;
  })) {
    return false;
  }
  return true;
};
// Function to extract links from HTML content
export const extractLinks = (html: string, baseUrl: string): string[] => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const links = Array.from(doc.querySelectorAll('a[href]'))
    .map(link => {
      const href = link.getAttribute('href');
      if (!href) return null;
      try {
        // Convert relative URLs to absolute
        return new URL(href, baseUrl).href;
      } catch (e) {
        return null;
      }
    })
    .filter((link): link is string => link !== null);
  // Return unique links
  return [...new Set(links)];
};
// Function to initialize proxy queue
export const initializeProxyQueue = async () => {
  // Clear existing queue
  proxyQueue.length = 0;
  activeProxies.clear();
  // Get all available proxies from DB
  const proxies = await getProxiesForQueue();
  if (proxies && proxies.length > 0) {
    // Add all proxies to queue
    proxies.forEach(proxy => {
      if (proxy.url && !proxyQueue.includes(proxy.url)) {
        proxyQueue.push(proxy.url);
      }
    });
    console.log(`Initialized proxy queue with ${proxyQueue.length} proxies`);
  } else {
    console.log("No proxies found in database");
  }
};
// Helper function to get all proxies
const getProxiesForQueue = async () => {
  try {
    const proxies = await getProxies();
    return proxies.filter(p => p.status === 'active');
  } catch (error) {
    console.error("Error getting proxies for queue:", error);
    return [];
  }
};
// Function to fetch HTML content from a URL with headless Chrome
export const fetchWithProxy = async (url: string): Promise<string> => {
  try {
    // Get a proxy from the queue or refill if empty
    let proxyUrl: string | undefined;
    // If queue is empty, try to refill it
    if (proxyQueue.length === 0) {
      await initializeProxyQueue();
    }
    if (proxyQueue.length > 0) {
      // Pop from the left (shift)
      proxyUrl = proxyQueue.shift();
      console.log(`Using proxy ${proxyUrl} for ${url}`);
      // Mark as active
      if (proxyUrl) {
        activeProxies.add(proxyUrl);
      }
      // We'll add it back to the queue after use
      setTimeout(() => {
        if (proxyUrl) {
          // Remove from active set
          activeProxies.delete(proxyUrl);
          // Add back to end of queue
          if (!proxyQueue.includes(proxyUrl)) {
            proxyQueue.push(proxyUrl);
            console.log(`Returned proxy ${proxyUrl} to queue`);
          }
        }
      }, 5000); // 5 second delay before reusing
    } else {
      console.log("No proxies available, proceeding without proxy");
    }
    // Always use headless browser for all sites to handle JavaScript and avoid CORS issues
    // In the future, we could actually use the proxy in a headless browser session
    return await fetchWithHeadlessBrowser(url);
  } catch (error) {
    console.error(`Error fetching ${url}:`, error);
    // Fallback to regular fetch if headless browser fails
    console.log(`Falling back to regular fetch for ${url}`);
    try {
      // Fallback to direct fetch
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 seconds timeout
      const response = await fetch(url, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
      }
      return await response.text();
    } catch (fallbackError) {
      console.error(`Fallback fetch also failed for ${url}:`, fallbackError);
      throw new Error(`Failed to fetch ${url} with both headless browser and direct fetch: ${error}`);
    }
  }
};
/**
 * Fetch a URL using a headless browser to handle JavaScript-rendered content
 */
export const fetchWithHeadlessBrowser = async (url: string): Promise<string> => {
  try {
    console.log(`Using headless browser to fetch: ${url}`);
    try {
      // Use Tauri invoke to call the Rust function
      const { invoke } = await import('@tauri-apps/api/core');
      const html = await invoke('fetch_with_headless_browser', { url });
      if (!html || typeof html !== 'string' || html.length < 10) {
        throw new Error(`Empty or invalid response from headless browser fetch for ${url}`);
      }
      console.log(`Successfully fetched content from ${url} (${html.length} bytes)`);
      return html as string;
    } catch (tauriError) {
      console.error(`Tauri command error: ${tauriError}`);
      throw new Error(`Failed to fetch ${url} with headless browser. Error: ${tauriError}`);
    }
  } catch (error) {
    console.error(`Error fetching with headless browser: ${url}`, error);
    throw error;
  }
};
/**
 * Convert HTML to Markdown using Rust implementation
 */
export const convertToMarkdown = async (html: string): Promise<string> => {
  console.log("================================");
  console.log("HTML TO MARKDOWN CONVERSION");
  console.log("================================");
  console.log(`HTML content length: ${html.length} characters`);
  console.log(`HTML content preview: ${html.substring(0, 100)}...`);
  const startTime = performance.now();
  try {
    // Use the Rust implementation via Tauri command
    console.log("Using Rust implementation for HTML-to-Markdown conversion");
    try {
      // Import Tauri invoke
      const { invoke } = await import('@tauri-apps/api/core');
      // Call the Rust function
      const markdown = await invoke('convert_html_to_markdown', { html }) as string;
      const endTime = performance.now();
      console.log(`✅ HTML to Markdown conversion completed in ${(endTime - startTime).toFixed(2)}ms`);
      console.log(`Markdown length: ${markdown.length} characters`);
      console.log(`Markdown preview: ${markdown.substring(0, 100)}...`);
      return markdown;
    } catch (tauriError) {
      console.error(`Tauri command error:`, tauriError);
      // Fallback to JS implementation if Rust version fails
      console.log("Falling back to JS implementation due to error");
      return fallbackConvertHtmlToMarkdown(html);
    }
  } catch (error) {
    const endTime = performance.now();
    console.error(`❌ HTML to Markdown conversion FAILED in ${(endTime - startTime).toFixed(2)}ms:`, error);
    throw error;
  }
};
/**
 * Fallback JavaScript HTML to Markdown conversion
 * Only used if the Rust implementation fails
 */
function fallbackConvertHtmlToMarkdown(html: string): string {
  console.log("Converting HTML to Markdown with Turndown (fallback)");
  // Create an instance of TurndownService
  const turndownService = new TurndownService({
    headingStyle: 'atx',
    codeBlockStyle: 'fenced',
    emDelimiter: '*',
    hr: '---',
    bulletListMarker: '-'
  });
  // Add performance improvement rules
  turndownService.remove(['script', 'style', 'noscript', 'iframe']);
  // Directly use turndown
  return turndownService.turndown(html);
};
// Main crawler function
export const crawlURL = async (url: string, config: CrawlerConfig): Promise<string[]> => {
  try {
    // Check if we already have this URL in the DB before processing
    const existingUrl = await getURLByUrl(config.sessionId, url);
    // If URL already exists and is already processed, don't reprocess it
    if (existingUrl && (existingUrl.status === 'crawled' || existingUrl.status === 'processed')) {
      console.log(`Skipping already processed URL: ${url} (status: ${existingUrl.status})`);
      return [];
    }
    // Add or update URL in database with pending status
    if (existingUrl && existingUrl.id) {
      await updateURLStatus(existingUrl.id, 'pending');
    } else {
      await addURL({
        session_id: config.sessionId,
        url,
        status: 'pending'
      });
    }
    // Fetch HTML content
    const html = await fetchWithProxy(url);
    // Convert to markdown (now fully async with Rust implementation)
    const markdown = await convertToMarkdown(html);
    // Update URL in database with content
    const urlObj = await getURLByUrl(config.sessionId, url);
    if (urlObj && urlObj.id) {
      await updateURLContent(urlObj.id, html, markdown);
      await updateURLStatus(urlObj.id, 'crawled');
    }
    // Extract links for further crawling
    const links = extractLinks(html, url);
    // Filter links based on crawler config
    const validLinks = links.filter(link => shouldCrawlURL(link, config));
    console.log(`Found ${links.length} links, ${validLinks.length} match criteria for URL: ${url}`);
    return validLinks;
  } catch (error) {
    console.error(`Error crawling ${url}:`, error);
    const urlObj = await getURLByUrl(config.sessionId, url);
    if (urlObj && urlObj.id) {
      await updateURLStatus(urlObj.id, 'error');
    }
    return [];
  }
};
// Function to start the crawler with a given configuration
export const startCrawler = async (config: CrawlerConfig): Promise<void> => {
  // Check if crawling was stopped - don't restart if requested to stop
  if (crawlingStopped) {
    console.log("Crawling was previously stopped. Not starting new crawler. Reset required.");
    return;
  }
  // Log important configuration details at start
  console.log("----------- CRAWLER CONFIGURATION -----------");
  console.log(`Start URL: ${config.startUrl}`);
  console.log(`Prefix Path: ${config.prefixPath}`);
  console.log(`Anti-Paths: ${config.antiPaths.join(', ')}`);
  console.log(`Anti-Keywords: ${config.antiKeywords.join(', ')}`);
  console.log(`Unlimited Parallelism: ${config.unlimitedParallelism}`);
  console.log(`Session ID: ${config.sessionId}`);
  console.log("-------------------------------------------");
  // Set crawling state
  isCrawling = true;
  crawlingStopped = false;
  // Check if we need to reset global visited URLs 
  // Only reset when starting a new crawler session, not when using multiple parallel crawlers
  if (activeCrawlUrls.length === 0) {
    console.log("Starting new crawler session, clearing global visited URLs cache");
    globalVisitedUrls.clear();
    // Initialize proxy queue if this is a new crawler session
    await initializeProxyQueue();
  } else {
    console.log(`Adding to existing crawler session with ${globalVisitedUrls.size} known URLs`);
  }
  // Set up parallelism
  const DEFAULT_CONCURRENCY = 4; // Default to 4 parallel requests
  const MAX_POSSIBLE_CONCURRENT = 1000; // Setting this to a very high number, effectively removing the limit
  // Determine concurrency based on config
  let concurrency = DEFAULT_CONCURRENCY;
  if (config.unlimitedParallelism) {
    // Use a truly high number for unlimited parallelism
    concurrency = 1000; 
    console.log(`Crawler using unlimited parallelism (${concurrency} concurrent requests)`);
  } else if (config.maxConcurrentRequests) {
    // Use specified concurrency without capping
    concurrency = config.maxConcurrentRequests;
    console.log(`Crawler using ${concurrency} concurrent requests`);
  } else {
    console.log(`Crawler using default concurrency: ${concurrency} concurrent requests`);
  }
  // Use a Set for queue to ensure URLs are unique
  const queueSet = new Set<string>();
  // Only add the startUrl if it passes our crawling criteria
  if (shouldCrawlURL(config.startUrl, config)) {
    queueSet.add(config.startUrl);
  } else {
    console.warn(`Starting URL ${config.startUrl} does not match crawling criteria. Check your configuration.`);
    return; // Exit early if the start URL doesn't match the criteria
  }
  // Convert to array for easier manipulation
  const queue: string[] = Array.from(queueSet);
  const visited = new Set<string>();
  const inProgress = new Set<string>();
  // Add the starting URL to database
  await addURL({
    session_id: config.sessionId,
    url: config.startUrl,
    status: 'pending'
  });
  // First check the DB for any URLs that are already crawled
  // to avoid recrawling them
  console.log("Loading already crawled URLs from database...");
  try {
    // Import the module for getting URLs
    const { getURLs } = await import('./db');
    // Get all URLs from the database for this session
    const existingUrls = await getURLs(config.sessionId);
    // Use a Set for the queue to ensure uniqueness
    const queueSet = new Set<string>();
    // Always add start URL to the queue, regardless of tracking status
    console.log(`Always adding start URL to queue: ${config.startUrl}`);
    queueSet.add(config.startUrl);
    // Add them to the appropriate sets
    let pendingCount = 0;
    for (const urlObj of existingUrls) {
      // Check if it's the start URL - we always want to crawl the start URL
      const isStartUrl = (urlObj.url === config.startUrl);
      // Only add to global tracking if not the start URL
      if (!isStartUrl) {
        globalVisitedUrls.add(urlObj.url);
      }
      if ((urlObj.status === 'crawled' || urlObj.status === 'error' || urlObj.status === 'processed') && !isStartUrl) {
        // If already processed and not the start URL, just mark as visited and don't recrawl
        console.log(`Skipping already processed URL: ${urlObj.url} (status: ${urlObj.status})`);
        visited.add(urlObj.url);
      } else if (urlObj.status === 'pending' || isStartUrl) {
        // Only add to queue if it passes the criteria check
        if (shouldCrawlURL(urlObj.url, config)) {
          console.log(`Adding pending URL to queue: ${urlObj.url}`);
          queueSet.add(urlObj.url);
          pendingCount++;
        } else {
          console.log(`Skipping pending URL that doesn't match criteria: ${urlObj.url}`);
          // Update status to avoid processing in the future
          try {
            if (urlObj.id) {
              await updateURLStatus(urlObj.id, 'error');
            }
          } catch (err) {
            console.error(`Error updating URL status: ${urlObj.url}`, err);
          }
        }
      }
    }
    // Convert the queueSet to an array for processing
    const queue: string[] = Array.from(queueSet);
    console.log(`Loaded ${visited.size} processed and ${pendingCount} pending URLs from database`);
    // Debugging: Check if startUrl is in the queue
    if (queue.includes(config.startUrl)) {
      console.log(`Start URL ${config.startUrl} is in the queue`);
    } else {
      console.log(`Start URL ${config.startUrl} is NOT in the queue!`);
      // Force add the start URL to the queue if it's not there
      if (shouldCrawlURL(config.startUrl, config)) {
        console.log(`Forcing start URL ${config.startUrl} into the queue`);
        queue.push(config.startUrl);
      } else {
        console.log(`Cannot add start URL ${config.startUrl} to queue because it doesn't match criteria`);
      }
    }
  } catch (error) {
    console.error("Error loading existing URLs:", error);
  }
  console.log(`Starting crawler with concurrency of ${concurrency}`);
  // Process queue with parallelism
  while ((queue.length > 0 || inProgress.size > 0) && !crawlingStopped) {
    // Log crawler status periodically
    if (queue.length > 0 || inProgress.size > 0) {
      console.log(`Crawler status: ${inProgress.size} in progress, ${queue.length} queued, ${visited.size} visited, prefix: ${config.prefixPath}`);
      // Detailed logging for in-progress URLs
      if (inProgress.size > 0) {
        console.log(`In progress URLs: ${Array.from(inProgress).slice(0, 3).join(', ')}${inProgress.size > 3 ? ` and ${inProgress.size - 3} more...` : ''}`);
      }
    }
    // Fill the processing queue up to concurrency limit
    while (inProgress.size < concurrency && queue.length > 0 && !crawlingStopped) {
      const url = queue.shift()!;
      // Check if this is the start URL - special case
      const isStartUrl = (url === config.startUrl);
      // Skip if already visited or in progress - but always process the start URL
      if (!isStartUrl && (visited.has(url) || inProgress.has(url) || globalVisitedUrls.has(url))) {
        console.log(`Skipping already visited/in-progress URL: ${url}`);
        continue;
      }
      // Double check that URL still matches criteria (could have changed since being added to queue)
      if (!shouldCrawlURL(url, config)) {
        console.log(`URL no longer matches criteria, skipping: ${url}`);
        visited.add(url);
        globalVisitedUrls.add(url);
        continue;
      }
      // Double-check URL in database to avoid race conditions
      try {
        const urlObj = await getURLByUrl(config.sessionId, url);
        // Check if this is the start URL - special case
        const isStartUrl = (url === config.startUrl);
        // If URL exists and is already processed, mark as visited and skip (unless it's the start URL)
        if (!isStartUrl && urlObj && (urlObj.status === 'crawled' || urlObj.status === 'processed')) {
          console.log(`Skipping already processed URL from DB check: ${url} (status: ${urlObj.status})`);
          visited.add(url);
          globalVisitedUrls.add(url);
          continue;
        }
        // If it's the start URL, always process it regardless of status
        if (isStartUrl) {
          console.log(`Processing start URL regardless of status: ${url}`);
        }
      } catch (err) {
        console.error(`Error checking URL status in DB: ${url}`, err);
      }
      // Mark as in progress in both local and global state
      inProgress.add(url);
      visited.add(url);
      globalVisitedUrls.add(url);
      // Process URL in the background (don't await)
      (async (currentUrl) => {
        try {
          // Add to active crawl URLs
          activeCrawlUrls.push(currentUrl);
          // Check if we should stop crawling
          if (crawlingStopped) {
            console.log(`Skipping crawl of ${currentUrl} due to stop request`);
            inProgress.delete(currentUrl);
            const urlIndex = activeCrawlUrls.indexOf(currentUrl);
            if (urlIndex !== -1) activeCrawlUrls.splice(urlIndex, 1);
            return;
          }
          console.log(`Crawling ${currentUrl}`);
          const newLinks = await crawlURL(currentUrl, config);
          // If crawling has been stopped, don't enqueue new links
          if (!crawlingStopped) {
            // Add valid links to queue
            for (const link of newLinks) {
              // Skip if we already know about this URL
              if (visited.has(link) || inProgress.has(link) || globalVisitedUrls.has(link) || queue.includes(link)) {
                console.log(`Skipping already known URL: ${link}`);
                continue;
              }
              // Check if URL exists in database before adding
              try {
                const urlObj = await getURLByUrl(config.sessionId, link);
                // If URL exists in any state, mark it as visited and don't add to queue again
                if (urlObj) {
                  console.log(`URL exists in DB with status ${urlObj.status}: ${link}`);
                  visited.add(link);
                  globalVisitedUrls.add(link);
                  // Only add to queue if it's still pending or errored
                  if (urlObj.status === 'pending' || urlObj.status === 'error') {
                    console.log(`Adding existing ${urlObj.status} URL to queue: ${link}`);
                    if (!queue.includes(link)) {
                      queue.push(link);
                    }
                  } else {
                    console.log(`Skipping URL with status ${urlObj.status}: ${link}`);
                  }
                  continue;
                }
              } catch (err) {
                console.error(`Error checking URL status in DB: ${link}`, err);
              }
              // If we get here, URL is new and not in DB yet
              console.log(`Adding new URL to queue: ${link}`);
              // Check if it's in queue before adding
              if (!queue.includes(link)) {
                queue.push(link);
                // Add to database with pending status
                try {
                  await addURL({
                    session_id: config.sessionId,
                    url: link,
                    status: 'pending'
                  });
                } catch (err) {
                  console.error(`Error adding URL to database: ${link}`, err);
                }
              }
            }
          }
        } catch (error) {
          console.error(`Error processing ${currentUrl}:`, error);
        } finally {
          // Always remove from in-progress list
          inProgress.delete(currentUrl);
          // Remove from active crawl URLs
          const urlIndex = activeCrawlUrls.indexOf(currentUrl);
          if (urlIndex !== -1) activeCrawlUrls.splice(urlIndex, 1);
        }
      })(url);
    }
    // Check if the crawler has been stopped before waiting
    if (crawlingStopped) break;
    // Wait a bit before checking the queue again
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  // Reset crawling state
  isCrawling = false;
  activeCrawlUrls = [];
  // If crawling was stopped, log it
  if (crawlingStopped) {
    console.log("Crawling was stopped manually");
    crawlingStopped = false;
  }
  console.log(`Crawling complete, visited ${visited.size} URLs`);
};
</file>

<file path="src/lib/db.ts">
import Database from '@tauri-apps/plugin-sql';
import { runMigrations } from './migrations';
// Database connection
let db: Database | null = null;
// Initialize database connection
export const initDB = async () => {
  if (db) return db;
  try {
    db = await Database.load("sqlite:anchoring.db");
    console.log("Database connection established");
    await createTables();
    // Run migrations to handle schema changes
    await runMigrations(db);
    return db;
  } catch (error) {
    console.error("Error initializing database:", error);
    throw error;
  }
};
// Create database tables
const createTables = async () => {
  const dbConn = db!;
  try {
    // Create tables if they don't exist
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS proxies (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL UNIQUE,
        last_used TIMESTAMP,
        status TEXT CHECK(status IN ('active', 'inactive', 'error'))
      )
    `);
    // Use the post-migration schema for new installations - without chroma_path
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS crawl_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        version TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS urls (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id INTEGER NOT NULL,
        url TEXT NOT NULL,
        status TEXT CHECK(status IN ('pending', 'crawled', 'error', 'skipped', 'processed')),
        html TEXT,
        markdown TEXT,
        cleaned_markdown TEXT,
        FOREIGN KEY(session_id) REFERENCES crawl_sessions(id) ON DELETE CASCADE
      )
    `);
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS crawl_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id INTEGER NOT NULL,
        prefix_path TEXT,
        anti_paths TEXT,
        anti_keywords TEXT,
        max_concurrent_requests INTEGER DEFAULT 4,
        unlimited_parallelism INTEGER DEFAULT 0,
        FOREIGN KEY(session_id) REFERENCES crawl_sessions(id) ON DELETE CASCADE
      )
    `);
    // Use the post-migration schema for new installations - without chroma_path
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS user_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        openai_key TEXT,
        language TEXT,
        language_version TEXT,
        framework TEXT,
        framework_version TEXT,
        library TEXT,
        library_version TEXT
      )
    `);
    // Add processing_settings table if it doesn't exist
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS processing_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id INTEGER NOT NULL,
        category TEXT CHECK(category IN ('language', 'framework', 'library')),
        language TEXT,
        language_version TEXT,
        framework TEXT,
        framework_version TEXT,
        library TEXT,
        library_version TEXT,
        FOREIGN KEY(session_id) REFERENCES crawl_sessions(id) ON DELETE CASCADE
      )
    `);
    // Add documentation_snippets table if it doesn't exist
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS documentation_snippets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        snippet_id TEXT NOT NULL UNIQUE,
        title TEXT NOT NULL,
        source_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Add vector DB tables
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS vector_db_providers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        version TEXT NOT NULL,
        schema TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS vector_db_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        pinecone_api_key TEXT,
        pinecone_environment TEXT,
        pinecone_index TEXT
      )
    `);
    // Updated to remove reference to vector_db_configurations
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS session_vector_db_mappings (
        session_id INTEGER NOT NULL,
        provider_name TEXT NOT NULL,
        config_data TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (session_id, provider_name),
        FOREIGN KEY(session_id) REFERENCES crawl_sessions(id) ON DELETE CASCADE
      )
    `);
    console.log("All database tables created successfully");
  } catch (error) {
    console.error("Error creating tables:", error);
    throw error;
  }
};
// Proxy Types
export interface Proxy {
  id?: number;
  url: string;
  last_used?: string;
  status: 'active' | 'inactive' | 'error';
}
// Session Types
export interface CrawlSession {
  id?: number;
  title: string;
  version?: string;
  created_at?: string;
}
// URL Types
export interface CrawlURL {
  id?: number;
  session_id: number;
  url: string;
  status: 'pending' | 'crawled' | 'error' | 'skipped' | 'processed';
  html?: string;
  markdown?: string;
  cleaned_markdown?: string;
}
// Settings Types
export interface CrawlSettings {
  id?: number;
  session_id: number;
  prefix_path?: string;
  anti_paths?: string;
  anti_keywords?: string;
  max_concurrent_requests?: number;
  unlimited_parallelism?: boolean;
}
// User Settings Types
export interface UserSettings {
  id?: number;
  openai_key?: string;
  // AI processing details
  language?: string;
  language_version?: string;
  framework?: string;
  framework_version?: string;
  library?: string;
  library_version?: string;
}
// Documentation category enum matching MCP server
export enum DocumentationCategory {
  LANGUAGE = "language",
  FRAMEWORK = "framework",
  LIBRARY = "library"
}
// Tech component interface matching MCP server
export interface TechComponent {
  name: string;
  version?: string;
}
// DocumentationSnippet interfaces
// Full documentation snippet for ChromaDB storage and processing
export interface FullDocumentationSnippet {
  id?: number;
  snippet_id: string;
  category: DocumentationCategory;
  language?: string;
  language_version?: string;
  framework?: string;
  framework_version?: string;
  library?: string;
  library_version?: string;
  title: string;
  description: string;
  source_url?: string;
  content: string;
  concepts?: string[];
  created_at?: string;
  score?: number; // Similarity score from vector search
}
// Simplified documentation snippet for SQLite storage (reference table)
export interface DocumentationSnippet {
  id?: number;
  snippet_id: string;
  title: string;
  source_url?: string;
  created_at?: string;
  updated_at?: string;
}
// Vector DB Settings Types
export interface VectorDBSettings {
  id?: number;
  pinecone_api_key?: string;
  pinecone_environment?: string;
  pinecone_index?: string;
}
// Proxy Operations
export const fetchAndSaveProxies = async (proxyUrls: string[]) => {
  const dbConn = await initDB();
  try {
    // Clear existing proxies
    await dbConn.execute('DELETE FROM proxies');
    // Insert new proxies in batches to improve performance
    const batchSize = 50;
    for (let i = 0; i < proxyUrls.length; i += batchSize) {
      const batch = proxyUrls.slice(i, i + batchSize);
      const placeholders = batch.map(() => '(?, ?)').join(',');
      const values = batch.flatMap(url => [url, 'active']);
      await dbConn.execute(
        `INSERT INTO proxies (url, status) VALUES ${placeholders}`,
        values
      );
    }
    return getProxies();
  } catch (error) {
    console.error('Error saving proxies:', error);
    throw error;
  }
};
export const getProxies = async () => {
  const dbConn = await initDB();
  try {
    const result = await dbConn.select<Proxy[]>('SELECT * FROM proxies');
    return result;
  } catch (error) {
    console.error('Error fetching proxies:', error);
    throw error;
  }
};
export const getNextProxy = async () => {
  const dbConn = await initDB();
  try {
    // Get the oldest used or never used proxy
    const result = await dbConn.select<Proxy[]>(
      'SELECT * FROM proxies WHERE status = "active" ORDER BY last_used NULLS FIRST, id ASC LIMIT 1'
    );
    if (result.length === 0) {
      return null;
    }
    // Update the last_used timestamp
    const proxy = result[0];
    await dbConn.execute(
      'UPDATE proxies SET last_used = CURRENT_TIMESTAMP WHERE id = ?',
      [proxy.id]
    );
    return proxy;
  } catch (error) {
    console.error('Error getting next proxy:', error);
    throw error;
  }
};
export const updateProxyStatus = async (id: number, status: 'active' | 'inactive' | 'error') => {
  const dbConn = await initDB();
  try {
    await dbConn.execute(
      'UPDATE proxies SET status = ? WHERE id = ?',
      [status, id]
    );
  } catch (error) {
    console.error('Error updating proxy status:', error);
    throw error;
  }
};
// Session Operations
export const createSession = async (sessionData: CrawlSession) => {
  try {
    console.log("Starting createSession with data:", sessionData);
    const dbConn = await initDB();
    console.log("Executing SQL to create session");
    const result = await dbConn.execute(
      'INSERT INTO crawl_sessions (title, version) VALUES (?, ?)',
      [sessionData.title, sessionData.version || '']
    );
    console.log("Session created in database, result:", result);
    return {
      ...sessionData,
      id: result.lastInsertId!
    };
  } catch (error) {
    console.error("Error in createSession:", error);
    throw error; // Re-throw so it can be caught by the calling function
  }
};
export const getSessions = async () => {
  const dbConn = await initDB();
  const result = await dbConn.select<CrawlSession[]>(
    'SELECT * FROM crawl_sessions ORDER BY created_at DESC'
  );
  return result;
};
export const getSession = async (id: number) => {
  const dbConn = await initDB();
  const result = await dbConn.select<CrawlSession[]>(
    'SELECT * FROM crawl_sessions WHERE id = ?',
    [id]
  );
  if (result.length === 0) {
    return null;
  }
  return result[0];
};
export const deleteSession = async (id: number): Promise<boolean> => {
  const dbConn = await initDB();
  try {
    // Delete session (cascade will delete related URLs and settings)
    await dbConn.execute(
      'DELETE FROM crawl_sessions WHERE id = ?',
      [id]
    );
    return true;
  } catch (error) {
    console.error('Error deleting session:', error);
    throw error;
  }
};
export const duplicateSession = async (id: number): Promise<CrawlSession> => {
  try {
    // Get the session to duplicate
    const originalSession = await getSession(id);
    if (!originalSession) {
      throw new Error('Session not found');
    }
    // Create a copy with "Copy of" prefix
    const newSession = await createSession({
      title: `Copy of ${originalSession.title}`,
      version: originalSession.version
    });
    // Get the original crawl settings
    const settings = await getCrawlSettings(id);
    // Duplicate the crawl settings
    await saveCrawlSettings({
      session_id: newSession.id!,
      prefix_path: settings.prefix_path,
      anti_paths: settings.anti_paths,
      anti_keywords: settings.anti_keywords
    });
    // Return the new session
    return newSession;
  } catch (error) {
    console.error('Error duplicating session:', error);
    throw error;
  }
};
// URL Operations
export const addURL = async (urlData: CrawlURL) => {
  const dbConn = await initDB();
  // Check if the URL already exists for this session
  const existingUrls = await dbConn.select<CrawlURL[]>(
    'SELECT * FROM urls WHERE session_id = ? AND url = ?',
    [urlData.session_id, urlData.url]
  );
  // If URL already exists, return the existing record instead of creating a duplicate
  if (existingUrls.length > 0) {
    console.log(`URL already exists: ${urlData.url}`);
    return existingUrls[0];
  }
  // If URL doesn't exist, insert it
  const result = await dbConn.execute(
    'INSERT INTO urls (session_id, url, status) VALUES (?, ?, ?)',
    [urlData.session_id, urlData.url, urlData.status]
  );
  return {
    ...urlData,
    id: result.lastInsertId!
  };
};
export const getURLs = async (sessionId: number, includeContent: boolean = false) => {
  const dbConn = await initDB();
  const columns = includeContent 
    ? '*' 
    : 'id, session_id, url, status';
  const result = await dbConn.select<CrawlURL[]>(
    `SELECT ${columns} FROM urls WHERE session_id = ? ORDER BY url`,
    [sessionId]
  );
  return result;
};
export const getURLByUrl = async (sessionId: number, url: string): Promise<CrawlURL | null> => {
  const dbConn = await initDB();
  const result = await dbConn.select<CrawlURL[]>(
    'SELECT * FROM urls WHERE session_id = ? AND url = ?',
    [sessionId, url]
  );
  if (result.length === 0) {
    return null;
  }
  return result[0];
};
export const updateURLStatus = async (id: number, status: string) => {
  const dbConn = await initDB();
  try {
    await dbConn.execute(
      'UPDATE urls SET status = ? WHERE id = ?',
      [status, id]
    );
    return true;
  } catch (error) {
    console.error("Error updating URL status:", error);
    throw error;
  }
};
/**
 * Update URL status by URL string instead of ID
 * This function is used by the vector-db library
 */
export const updateURLStatusByUrl = async (url: string, status: string) => {
  const dbConn = await initDB();
  try {
    await dbConn.execute(
      'UPDATE urls SET status = ? WHERE url = ?',
      [status, url]
    );
    return true;
  } catch (error) {
    console.error("Error updating URL status by URL:", error);
    throw error;
  }
};
export const updateURLContent = async (id: number, html: string, markdown: string) => {
  const dbConn = await initDB();
  await dbConn.execute(
    'UPDATE urls SET html = ?, markdown = ? WHERE id = ?',
    [html, markdown, id]
  );
};
export const updateURLCleanedMarkdown = async (id: number, cleanedMarkdown: string) => {
  const dbConn = await initDB();
  await dbConn.execute(
    'UPDATE urls SET cleaned_markdown = ? WHERE id = ?',
    [cleanedMarkdown, id]
  );
};
// Crawl Settings Operations
export const saveCrawlSettings = async (settingsData: CrawlSettings) => {
  const dbConn = await initDB();
  try {
    console.log("Saving crawler settings:", settingsData);
    // Check if settings exist for this session
    const existing = await dbConn.select<CrawlSettings[]>(
      'SELECT * FROM crawl_settings WHERE session_id = ?',
      [settingsData.session_id]
    );
    if (existing.length === 0) {
      console.log("Creating new crawler settings for session ID:", settingsData.session_id);
      // Create new settings
      const result = await dbConn.execute(
        'INSERT INTO crawl_settings (session_id, prefix_path, anti_paths, anti_keywords, max_concurrent_requests, unlimited_parallelism) VALUES (?, ?, ?, ?, ?, ?)',
        [
          settingsData.session_id,
          settingsData.prefix_path || '',
          settingsData.anti_paths || '',
          settingsData.anti_keywords || '',
          settingsData.max_concurrent_requests || 4,
          settingsData.unlimited_parallelism ? 1 : 0
        ]
      );
      const savedSettings = {
        ...settingsData,
        id: result.lastInsertId!
      };
      console.log("Created new crawler settings:", savedSettings);
      return savedSettings;
    } else {
      console.log("Updating existing crawler settings for session ID:", settingsData.session_id);
      // Update existing settings
      await dbConn.execute(
        'UPDATE crawl_settings SET prefix_path = ?, anti_paths = ?, anti_keywords = ?, max_concurrent_requests = ?, unlimited_parallelism = ? WHERE session_id = ?',
        [
          settingsData.prefix_path || '',
          settingsData.anti_paths || '',
          settingsData.anti_keywords || '',
          settingsData.max_concurrent_requests || 4,
          settingsData.unlimited_parallelism ? 1 : 0,
          settingsData.session_id
        ]
      );
      const updatedSettings = {
        ...settingsData,
        id: existing[0].id
      };
      console.log("Updated crawler settings:", updatedSettings);
      return updatedSettings;
    }
  } catch (error) {
    console.error("Error saving crawler settings:", error);
    throw error;
  }
};
export const getCrawlSettings = async (sessionId: number) => {
  const dbConn = await initDB();
  try {
    console.log(`Fetching crawler settings for session ID: ${sessionId}`);
    const result = await dbConn.select<CrawlSettings[]>(
      'SELECT * FROM crawl_settings WHERE session_id = ?',
      [sessionId]
    );
    if (result.length === 0) {
      console.log(`No settings found for session ID: ${sessionId}, returning defaults`);
      return {
        session_id: sessionId,
        prefix_path: '',
        anti_paths: '',
        anti_keywords: ''
      };
    }
    console.log(`Found settings for session ID: ${sessionId}`, result[0]);
    return result[0];
  } catch (error) {
    console.error(`Error fetching crawler settings for session ID: ${sessionId}`, error);
    // Return defaults in case of error
    return {
      session_id: sessionId,
      prefix_path: '',
      anti_paths: '',
      anti_keywords: ''
    };
  }
};
// User Settings Operations
export const saveUserSettings = async (settings: UserSettings) => {
  const dbConn = await initDB();
  console.log("Saving user settings:", settings);
  // Check if any settings exist
  const existing = await dbConn.select<UserSettings[]>('SELECT * FROM user_settings LIMIT 1');
  console.log("Existing settings:", existing.length ? existing[0] : "None");
  if (existing.length === 0) {
    // Create new settings
    console.log("No existing settings found, creating new settings");
    const result = await dbConn.execute(
      'INSERT INTO user_settings (openai_key, language, language_version, framework, framework_version, library, library_version) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [
        settings.openai_key || '', 
        settings.language || null,
        settings.language_version || null,
        settings.framework || null,
        settings.framework_version || null,
        settings.library || null,
        settings.library_version || null
      ]
    );
    console.log("Settings created with ID:", result.lastInsertId!);
    return {
      ...settings,
      id: result.lastInsertId!
    };
  } else {
    // Update existing settings with non-null values
    const updates = [];
    const params = [];
    if (settings.openai_key !== undefined) {
      updates.push('openai_key = ?');
      params.push(settings.openai_key);
    }
    // Add AI processing fields
    if (settings.language !== undefined) {
      updates.push('language = ?');
      params.push(settings.language || null);
    }
    if (settings.language_version !== undefined) {
      updates.push('language_version = ?');
      params.push(settings.language_version || null);
    }
    if (settings.framework !== undefined) {
      updates.push('framework = ?');
      params.push(settings.framework || null);
    }
    if (settings.framework_version !== undefined) {
      updates.push('framework_version = ?');
      params.push(settings.framework_version || null);
    }
    if (settings.library !== undefined) {
      updates.push('library = ?');
      params.push(settings.library || null);
    }
    if (settings.library_version !== undefined) {
      updates.push('library_version = ?');
      params.push(settings.library_version || null);
    }
    console.log("Updating settings with fields:", updates);
    console.log("Update parameters:", params);
    if (updates.length > 0) {
      params.push(existing[0].id);
      const query = `UPDATE user_settings SET ${updates.join(', ')} WHERE id = ?`;
      console.log("Update query:", query);
      const result = await dbConn.execute(query, params);
      console.log("Update result:", result);
    } else {
      console.log("No fields to update");
    }
    // Get the updated settings to confirm the changes
    const updatedSettings = await getUserSettings();
    console.log("Updated settings:", updatedSettings);
    return {
      ...existing[0],
      ...settings,
    };
  }
};
export interface ProcessingSettings {
  session_id: number;
  language?: string;
  language_version?: string;
  framework?: string;
  framework_version?: string;
  library?: string;
  library_version?: string;
  category?: DocumentationCategory;
}
// Get processing settings for a specific session
export const getProcessingSettings = async (sessionId: number): Promise<ProcessingSettings | null> => {
  const dbConn = await initDB();
  console.log(`Fetching processing settings for session ${sessionId}`);
  try {
    // First check if the settings table exists
    const tableExists = await dbConn.select<{name: string}[]>(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='processing_settings'"
    );
    // If the table doesn't exist, create it
    if (tableExists.length === 0) {
      console.log("Creating processing_settings table");
      await dbConn.execute(`
        CREATE TABLE IF NOT EXISTS processing_settings (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          session_id INTEGER NOT NULL UNIQUE,
          language TEXT,
          language_version TEXT,
          framework TEXT,
          framework_version TEXT,
          library TEXT,
          library_version TEXT,
          category TEXT,
          FOREIGN KEY(session_id) REFERENCES crawl_sessions(id) ON DELETE CASCADE
        )
      `);
    } else {
      // Check if the category column exists
      const columns = await dbConn.select<{name: string, type: string}[]>(
        "PRAGMA table_info(processing_settings)"
      );
      const columnExists = columns.some((col) => col.name === 'category');
      // Add the column if it doesn't exist
      if (!columnExists) {
        console.log("Adding category column to processing_settings table");
        await dbConn.execute(
          "ALTER TABLE processing_settings ADD COLUMN category TEXT"
        );
      }
    }
    // Query the settings for this session
    const result = await dbConn.select<ProcessingSettings[]>(
      'SELECT * FROM processing_settings WHERE session_id = ?',
      [sessionId]
    );
    if (result.length === 0) {
      console.log(`No processing settings found for session ${sessionId}`);
      return null;
    }
    console.log(`Found processing settings for session ${sessionId}:`, result[0]);
    return result[0];
  } catch (error) {
    console.error(`Error fetching processing settings:`, error);
    return null;
  }
};
// Save processing settings for a specific session
export const saveProcessingSettings = async (settings: ProcessingSettings): Promise<void> => {
  const dbConn = await initDB();
  console.log(`Saving processing settings for session ${settings.session_id}:`, settings);
  try {
    // Check if settings for this session already exist
    const existing = await dbConn.select<ProcessingSettings[]>(
      'SELECT id FROM processing_settings WHERE session_id = ?',
      [settings.session_id]
    );
    if (existing.length === 0) {
      // Create new settings
      console.log(`Creating new processing settings for session ${settings.session_id}`);
      await dbConn.execute(
        'INSERT INTO processing_settings (session_id, language, language_version, framework, framework_version, library, library_version, category) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [
          settings.session_id,
          settings.language || null,
          settings.language_version || null,
          settings.framework || null,
          settings.framework_version || null,
          settings.library || null,
          settings.library_version || null,
          settings.category || null
        ]
      );
    } else {
      // Update existing settings
      console.log(`Updating processing settings for session ${settings.session_id}`);
      await dbConn.execute(
        'UPDATE processing_settings SET language = ?, language_version = ?, framework = ?, framework_version = ?, library = ?, library_version = ?, category = ? WHERE session_id = ?',
        [
          settings.language || null,
          settings.language_version || null,
          settings.framework || null,
          settings.framework_version || null,
          settings.library || null,
          settings.library_version || null,
          settings.category || null,
          settings.session_id
        ]
      );
    }
    console.log(`Successfully saved processing settings for session ${settings.session_id}`);
  } catch (error) {
    console.error(`Error saving processing settings:`, error);
    throw error;
  }
};
export const getUserSettings = async () => {
  const dbConn = await initDB();
  console.log("Fetching user settings from database");
  const result = await dbConn.select<UserSettings[]>(
    'SELECT id, openai_key, language, language_version, framework, framework_version, library, library_version FROM user_settings LIMIT 1'
  );
  console.log("Raw user settings from database:", JSON.stringify(result, null, 2));
  if (result.length === 0) {
    const defaultSettings = {
      openai_key: '',
      language: null,
      language_version: null,
      framework: null,
      framework_version: null,
      library: null,
      library_version: null
    };
    console.log("No user settings found, returning defaults:", defaultSettings);
    return defaultSettings;
  }
  // Convert explicit null values to empty strings to avoid UI issues
  const settings = {
    ...result[0],
    language: result[0].language || '',
    language_version: result[0].language_version || '',
    framework: result[0].framework || '',
    framework_version: result[0].framework_version || '',
    library: result[0].library || '',
    library_version: result[0].library_version || ''
  };
  // Log the settings for debugging
  console.log("Retrieved user settings from database:", settings);
  return settings;
};
// Documentation snippets operations
export const addDocumentationSnippet = async (snippet: DocumentationSnippet): Promise<DocumentationSnippet> => {
  const dbConn = await initDB();
  try {
    const result = await dbConn.execute(
      'INSERT INTO documentation_snippets (snippet_id, title, source_url) VALUES (?, ?, ?)',
      [snippet.snippet_id, snippet.title, snippet.source_url || '']
    );
    return {
      ...snippet,
      id: result.lastInsertId!,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error adding documentation snippet:', error);
    throw error;
  }
};
export const getDocumentationSnippet = async (snippet_id: string): Promise<DocumentationSnippet | null> => {
  const dbConn = await initDB();
  try {
    const result = await dbConn.select<DocumentationSnippet[]>(
      'SELECT * FROM documentation_snippets WHERE snippet_id = ?',
      [snippet_id]
    );
    if (result.length === 0) {
      return null;
    }
    return result[0];
  } catch (error) {
    console.error('Error getting documentation snippet:', error);
    throw error;
  }
};
export const getDocumentationSnippets = async (): Promise<DocumentationSnippet[]> => {
  const dbConn = await initDB();
  try {
    const result = await dbConn.select<DocumentationSnippet[]>(
      'SELECT * FROM documentation_snippets ORDER BY created_at DESC'
    );
    return result;
  } catch (error) {
    console.error('Error getting documentation snippets:', error);
    throw error;
  }
};
export const updateDocumentationSnippet = async (snippet: DocumentationSnippet): Promise<DocumentationSnippet> => {
  const dbConn = await initDB();
  try {
    await dbConn.execute(
      'UPDATE documentation_snippets SET title = ?, source_url = ?, updated_at = CURRENT_TIMESTAMP WHERE snippet_id = ?',
      [snippet.title, snippet.source_url || '', snippet.snippet_id]
    );
    return await getDocumentationSnippet(snippet.snippet_id) as DocumentationSnippet;
  } catch (error) {
    console.error('Error updating documentation snippet:', error);
    throw error;
  }
};
export const deleteDocumentationSnippet = async (snippet_id: string): Promise<boolean> => {
  const dbConn = await initDB();
  try {
    await dbConn.execute(
      'DELETE FROM documentation_snippets WHERE snippet_id = ?',
      [snippet_id]
    );
    return true;
  } catch (error) {
    console.error('Error deleting documentation snippet:', error);
    throw error;
  }
};
// Clean up duplicate URLs for a session, keeping only one instance of each URL (preferring non-error statuses)
export const cleanupDuplicateURLs = async (sessionId: number): Promise<number> => {
  const db = await initDB();
  try {
    // Find URLs that appear more than once
    const duplicates = await db.select<{url: string, count: number}[]>(
      `SELECT url, COUNT(*) as count 
       FROM urls 
       WHERE session_id = ? 
       GROUP BY url 
       HAVING COUNT(*) > 1`,
      [sessionId]
    );
    let deletedCount = 0;
    // For each duplicated URL, keep only the first instance
    for (const dup of duplicates) {
      // Get all instances of this URL
      const instances = await db.select<CrawlURL[]>(
        `SELECT * FROM urls WHERE session_id = ? AND url = ? ORDER BY id ASC`,
        [sessionId, dup.url]
      );
      // Keep the first one, delete the rest
      if (instances.length > 1) {
        const idsToDelete = instances.slice(1).map(u => u.id);
        const placeholders = idsToDelete.map(() => '?').join(',');
        // Delete duplicates
        await db.execute(
          `DELETE FROM urls WHERE id IN (${placeholders})`,
          [...idsToDelete]
        );
        deletedCount += idsToDelete.length;
      }
    }
    return deletedCount;
  } catch (error) {
    console.error("Error cleaning up duplicate URLs:", error);
    throw error;
  }
};
// Delete all URLs for a session
export const deleteAllURLs = async (sessionId: number): Promise<number> => {
  try {
    const dbConn = await initDB();
    const result = await dbConn.execute(
      `DELETE FROM urls WHERE session_id = $1`,
      [sessionId]
    );
    return result.rowsAffected;
  } catch (error) {
    console.error("Error deleting all URLs:", error);
    throw error;
  }
};
/**
 * Filter URLs based on anti-patterns
 * Returns the list of URLs that match the anti-patterns (to be deleted)
 */
export const getURLsMatchingAntiPatterns = async (
  sessionId: number, 
  antiPaths: string[], 
  antiKeywords: string[]
): Promise<CrawlURL[]> => {
  try {
    await initDB();
    // Get all URLs for the session (just metadata, no content needed)
    const urls = await getURLs(sessionId, false);
    // Filter URLs that match anti-patterns
    return urls.filter(url => {
      // Check if URL contains any anti-paths
      if (antiPaths.some(path => url.url.includes(path))) {
        return true;
      }
      // Check if URL contains any anti-keywords
      if (antiKeywords.some(keyword => url.url.includes(keyword))) {
        return true;
      }
      return false;
    });
  } catch (error) {
    console.error("Error getting URLs matching anti-patterns:", error);
    throw error;
  }
};
/**
 * Delete URLs that match anti-patterns
 * Returns the number of URLs deleted
 */
export const deleteURLsMatchingAntiPatterns = async (
  sessionId: number, 
  antiPaths: string[], 
  antiKeywords: string[]
): Promise<number> => {
  const db = await initDB();
  try {
    // Get the URLs that match the anti-patterns
    const urlsToDelete = await getURLsMatchingAntiPatterns(sessionId, antiPaths, antiKeywords);
    if (urlsToDelete.length === 0) {
      return 0;
    }
    // Delete the URLs
    const result = await db.execute(
      `DELETE FROM urls WHERE session_id = ? AND url IN (${urlsToDelete.map(() => '?').join(',')})`,
      [sessionId, ...urlsToDelete.map(url => url.url)]
    );
    return urlsToDelete.length;
  } catch (error) {
    console.error("Error deleting URLs matching anti-patterns:", error);
    throw error;
  }
};
/**
 * Export a session and all its associated data (URLs, settings) as a JSON object
 */
export const exportSession = async (id: number): Promise<any> => {
  await initDB();
  try {
    // Fetch all data related to this session
    const session = await getSession(id);
    if (!session) {
      throw new Error(`Session with ID ${id} not found`);
    }
    // Get settings for this session
    const settings = await getCrawlSettings(id);
    // Get URLs for this session (without HTML/markdown content)
    const urls = await getURLs(id, false);
    // Build export object
    const exportData = {
      session: {
        title: session.title,
        version: session.version,
        created_at: session.created_at
      },
      settings: settings,
      urls: urls
    };
    return exportData;
  } catch (error) {
    console.error("Error exporting session:", error);
    throw error;
  }
};
/**
 * Import a session from a JSON object
 */
export const importSession = async (importData: any): Promise<CrawlSession> => {
  await initDB();
  try {
    // Validate import data
    if (!importData.session || !importData.session.title) {
      throw new Error("Invalid import data: session title is required");
    }
    // Create new session
    const sessionData = {
      title: importData.session.title,
      version: importData.session.version
    };
    const newSession = await createSession(sessionData);
    // Create settings if available
    if (importData.settings) {
      const settingsData = {
        session_id: newSession.id!,
        prefix_path: importData.settings.prefix_path,
        anti_paths: importData.settings.anti_paths,
        anti_keywords: importData.settings.anti_keywords
      };
      await saveCrawlSettings(settingsData);
    }
    // Import URLs if available
    if (importData.urls && Array.isArray(importData.urls)) {
      for (const urlData of importData.urls) {
        await addURL({
          session_id: newSession.id!,
          url: urlData.url,
          status: urlData.status,
          html: urlData.html,
          markdown: urlData.markdown,
          cleaned_markdown: urlData.cleaned_markdown
        });
      }
    }
    return newSession;
  } catch (error) {
    console.error("Error importing session:", error);
    throw error;
  }
};
// Vector DB Settings Operations
export const saveVectorDBSettings = async (settings: VectorDBSettings) => {
  const dbConn = await initDB();
  console.log("Saving vector DB settings:", settings);
  // Check if any settings exist
  const existing = await dbConn.select<VectorDBSettings[]>('SELECT * FROM vector_db_settings LIMIT 1');
  console.log("Existing vector DB settings:", existing.length ? existing[0] : "None");
  if (existing.length === 0) {
    // Create new settings
    console.log("No existing vector DB settings found, creating new settings");
    const result = await dbConn.execute(
      'INSERT INTO vector_db_settings (pinecone_api_key, pinecone_environment, pinecone_index) VALUES (?, ?, ?)',
      [
        settings.pinecone_api_key || '', 
        settings.pinecone_environment || '',
        settings.pinecone_index || ''
      ]
    );
    console.log("Vector DB settings created with ID:", result.lastInsertId!);
    return {
      ...settings,
      id: result.lastInsertId!
    };
  }
  // Update existing settings with non-null values
  const updates = [];
  const params = [];
  if (settings.pinecone_api_key !== undefined) {
    updates.push('pinecone_api_key = ?');
    params.push(settings.pinecone_api_key);
  }
  if (settings.pinecone_environment !== undefined) {
    updates.push('pinecone_environment = ?');
    params.push(settings.pinecone_environment);
  }
  if (settings.pinecone_index !== undefined) {
    updates.push('pinecone_index = ?');
    params.push(settings.pinecone_index);
  }
  console.log("Updating vector DB settings with fields:", updates);
  console.log("Update parameters:", params);
  if (updates.length > 0) {
    params.push(existing[0].id);
    const query = `UPDATE vector_db_settings SET ${updates.join(', ')} WHERE id = ?`;
    console.log("Update query:", query);
    const result = await dbConn.execute(query, params);
    console.log("Update result:", result);
  } else {
    console.log("No fields to update");
  }
  // Get the updated settings to confirm the changes
  const updatedSettings = await getVectorDBSettings();
  console.log("Updated vector DB settings:", updatedSettings);
  return {
    ...existing[0],
    ...settings,
  };
};
export const getVectorDBSettings = async () => {
  const dbConn = await initDB();
  console.log("Fetching vector DB settings from database");
  const result = await dbConn.select<VectorDBSettings[]>(
    'SELECT id, pinecone_api_key, pinecone_environment, pinecone_index FROM vector_db_settings LIMIT 1'
  );
  console.log("Raw vector DB settings from database:", JSON.stringify(result, null, 2));
  if (result.length === 0) {
    const defaultSettings = {
      pinecone_api_key: '',
      pinecone_environment: '',
      pinecone_index: ''
    };
    console.log("No vector DB settings found, returning defaults:", defaultSettings);
    return defaultSettings;
  }
  const settings = {
    ...result[0],
    pinecone_api_key: result[0].pinecone_api_key || '',
    pinecone_environment: result[0].pinecone_environment || '',
    pinecone_index: result[0].pinecone_index || ''
  };
  console.log("Retrieved vector DB settings from database:", settings);
  return settings;
};
// Add new interfaces and functions for the new system
export interface VectorDBProvider {
  id: number;
  name: string;
  version: string;
  schema: Record<string, any>;
  created_at: string;
}
export interface SessionVectorDBMapping {
  session_id: number;
  provider_name: string;
  config_data: string;
  created_at?: string;
}
export const getVectorDBProviders = async (): Promise<VectorDBProvider[]> => {
  const dbConn = await initDB();
  try {
    const result = await dbConn.select<VectorDBProvider[]>(
      'SELECT * FROM vector_db_providers'
    );
    return result.map(provider => ({
      ...provider,
      schema: JSON.parse(provider.schema as unknown as string)
    }));
  } catch (error) {
    console.error('Error getting vector DB providers:', error);
    throw error;
  }
};
/**
 * Save the vector DB provider mapping for a session
 * @param mapping The session-vector DB mapping to save
 * @returns The saved mapping
 */
export const saveSessionVectorDBMapping = async (mapping: SessionVectorDBMapping): Promise<SessionVectorDBMapping> => {
  try {
    console.log("Saving session vector DB mapping:", mapping);
    const dbConn = await initDB();
    // Check if mapping already exists
    const existingMapping = await dbConn.select<SessionVectorDBMapping[]>(
      'SELECT * FROM session_vector_db_mappings WHERE session_id = ? AND provider_name = ?',
      [mapping.session_id, mapping.provider_name]
    );
    if (existingMapping.length > 0) {
      // Update existing mapping
      console.log("Updating existing session vector DB mapping");
      await dbConn.execute(
        'UPDATE session_vector_db_mappings SET config_data = ? WHERE session_id = ? AND provider_name = ?',
        [mapping.config_data, mapping.session_id, mapping.provider_name]
      );
    } else {
      // Create new mapping
      console.log("Creating new session vector DB mapping");
      await dbConn.execute(
        'INSERT INTO session_vector_db_mappings (session_id, provider_name, config_data) VALUES (?, ?, ?)',
        [mapping.session_id, mapping.provider_name, mapping.config_data]
      );
    }
    return mapping;
  } catch (error) {
    console.error("Error saving session vector DB mapping:", error);
    throw error;
  }
};
/**
 * Get the vector DB provider mapping for a session
 * @param sessionId The session ID
 * @returns The session-vector DB mapping or null if not found
 */
export const getSessionVectorDBMapping = async (sessionId: number): Promise<SessionVectorDBMapping | null> => {
  try {
    console.log("Getting session vector DB mapping for session:", sessionId);
    const dbConn = await initDB();
    const mappings = await dbConn.select<SessionVectorDBMapping[]>(
      'SELECT * FROM session_vector_db_mappings WHERE session_id = ?',
      [sessionId]
    );
    if (mappings.length === 0) {
      console.log("No vector DB mapping found for session:", sessionId);
      return null;
    }
    console.log("Found vector DB mapping for session:", mappings[0]);
    return mappings[0];
  } catch (error) {
    console.error("Error getting session vector DB mapping:", error);
    throw error;
  }
};
</file>

<file path="src/lib/migrations.ts">
import Database from '@tauri-apps/plugin-sql';
/**
 * Run database migrations to ensure schema is up to date
 * @param dbConn Database connection
 */
export const runMigrations = async (dbConn: Database) => {
  console.log("Running database migrations...");
  try {
    // Create migrations table if it doesn't exist
    await dbConn.execute(`
      CREATE TABLE IF NOT EXISTS migrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Clean up any removed migrations that might be in the migrations table
    await cleanupRemovedMigrations(dbConn);
    // Get list of applied migrations
    const appliedMigrations = await dbConn.select<{ name: string }[]>(
      'SELECT name FROM migrations'
    );
    const appliedMigrationNames = appliedMigrations.map(m => m.name);
    // Check for interrupted migrations and fix them
    await repairInterruptedMigrations(dbConn);
    // Define migrations
    const migrations = [
      {
        name: 'remove_chroma_path',
        up: async () => {
          console.log("Running migration: remove_chroma_path");
          try {
            // Get column info to check if chroma_path exists in crawl_sessions
            const sessionColumns = await dbConn.select<{ name: string }[]>(
              "PRAGMA table_info(crawl_sessions)"
            );
            // Get column info to check if chroma_path exists in user_settings
            const userSettingsColumns = await dbConn.select<{ name: string }[]>(
              "PRAGMA table_info(user_settings)"
            );
            const needsSessionMigration = sessionColumns.some(col => col.name === 'chroma_path');
            const needsSettingsMigration = userSettingsColumns.some(col => col.name === 'chroma_path');
            // Only start a transaction if we need to make changes
            if (needsSessionMigration || needsSettingsMigration) {
              // Use transactions for atomicity
              await dbConn.execute('BEGIN TRANSACTION');
              try {
                if (needsSessionMigration) {
                  // Create a new table without chroma_path
                  await dbConn.execute(`
                    CREATE TABLE IF NOT EXISTS crawl_sessions_new (
                      id INTEGER PRIMARY KEY AUTOINCREMENT,
                      title TEXT NOT NULL,
                      version TEXT,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                  `);
                  // Copy data excluding chroma_path
                  await dbConn.execute(`
                    INSERT INTO crawl_sessions_new (id, title, version, created_at)
                    SELECT id, title, version, created_at FROM crawl_sessions;
                  `);
                  // Drop old table and rename new one
                  await dbConn.execute(`DROP TABLE crawl_sessions;`);
                  await dbConn.execute(`ALTER TABLE crawl_sessions_new RENAME TO crawl_sessions;`);
                  console.log("Removed chroma_path from crawl_sessions");
                }
                if (needsSettingsMigration) {
                  // Create a new table without chroma_path
                  await dbConn.execute(`
                    CREATE TABLE IF NOT EXISTS user_settings_new (
                      id INTEGER PRIMARY KEY AUTOINCREMENT,
                      openai_key TEXT,
                      language TEXT,
                      language_version TEXT,
                      framework TEXT,
                      framework_version TEXT,
                      library TEXT,
                      library_version TEXT
                    );
                  `);
                  // Copy data excluding chroma_path
                  await dbConn.execute(`
                    INSERT INTO user_settings_new (id, openai_key, language, language_version, framework, framework_version, library, library_version)
                    SELECT id, openai_key, language, language_version, framework, framework_version, library, library_version FROM user_settings;
                  `);
                  // Drop old table and rename new one
                  await dbConn.execute(`DROP TABLE user_settings;`);
                  await dbConn.execute(`ALTER TABLE user_settings_new RENAME TO user_settings;`);
                  console.log("Removed chroma_path from user_settings");
                }
                // Commit transaction if all steps succeeded
                await dbConn.execute('COMMIT');
              } catch (error) {
                // Rollback transaction on error
                await dbConn.execute('ROLLBACK');
                console.error("Error in migration - rolled back:", error);
                throw error;
              }
            } else {
              console.log("No chroma_path columns found, skipping migration");
            }
          } catch (error) {
            console.error("Error in migration:", error);
            throw error;
          }
        }
      }
    ];
    // Run migrations that haven't been applied yet
    for (const migration of migrations) {
      // Skip if migration is already recorded
      if (appliedMigrationNames.includes(migration.name)) {
        console.log(`Migration ${migration.name} already applied, skipping`);
        continue;
      }
      try {
        // Run the migration
        await migration.up();
        // Check if the migration was recorded during the up() function
        const checkMigration = await dbConn.select<{ name: string }[]>(
          'SELECT name FROM migrations WHERE name = ?',
          [migration.name]
        );
        // Only record the migration if it hasn't been recorded yet
        if (checkMigration.length === 0) {
          // Record that migration has been applied
          await dbConn.execute(
            'INSERT INTO migrations (name) VALUES (?)',
            [migration.name]
          );
          console.log(`Recorded migration: ${migration.name}`);
        } else {
          console.log(`Migration ${migration.name} already recorded, skipping record`);
        }
        console.log(`Applied migration: ${migration.name}`);
      } catch (error) {
        console.error(`Error applying migration ${migration.name}:`, error);
        throw error;
      }
    }
    console.log("Database migrations completed");
  } catch (error) {
    console.error("Error running migrations:", error);
    throw error;
  }
};
/**
 * Repair any interrupted migrations by checking for temporary tables
 * and completing their migrations if needed.
 */
async function repairInterruptedMigrations(dbConn: Database) {
  try {
    // Get all tables in the database
    const tables = await dbConn.select<{ name: string }[]>(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
    `);
    const tableNames = tables.map(t => t.name);
    // Check for crawl_sessions_new
    if (tableNames.includes('crawl_sessions_new')) {
      console.log("Found interrupted migration: crawl_sessions_new exists");
      if (tableNames.includes('crawl_sessions')) {
        console.log("Both crawl_sessions and crawl_sessions_new exist - completing migration");
        await dbConn.execute('BEGIN TRANSACTION');
        try {
          // Drop the old table and rename the new one
          await dbConn.execute(`DROP TABLE crawl_sessions;`);
          await dbConn.execute(`ALTER TABLE crawl_sessions_new RENAME TO crawl_sessions;`);
          await dbConn.execute('COMMIT');
          console.log("Repaired interrupted migration for crawl_sessions");
        } catch (error) {
          await dbConn.execute('ROLLBACK');
          console.error("Error repairing crawl_sessions migration:", error);
        }
      } else {
        // Old table is gone but new table wasn't renamed
        console.log("Only crawl_sessions_new exists - renaming to crawl_sessions");
        await dbConn.execute(`ALTER TABLE crawl_sessions_new RENAME TO crawl_sessions;`);
      }
    }
    // Check for user_settings_new
    if (tableNames.includes('user_settings_new')) {
      console.log("Found interrupted migration: user_settings_new exists");
      if (tableNames.includes('user_settings')) {
        console.log("Both user_settings and user_settings_new exist - completing migration");
        await dbConn.execute('BEGIN TRANSACTION');
        try {
          // Drop the old table and rename the new one
          await dbConn.execute(`DROP TABLE user_settings;`);
          await dbConn.execute(`ALTER TABLE user_settings_new RENAME TO user_settings;`);
          await dbConn.execute('COMMIT');
          console.log("Repaired interrupted migration for user_settings");
        } catch (error) {
          await dbConn.execute('ROLLBACK');
          console.error("Error repairing user_settings migration:", error);
        }
      } else {
        // Old table is gone but new table wasn't renamed
        console.log("Only user_settings_new exists - renaming to user_settings");
        await dbConn.execute(`ALTER TABLE user_settings_new RENAME TO user_settings;`);
      }
    }
  } catch (error) {
    console.error("Error checking for interrupted migrations:", error);
  }
}
/**
 * Clean up any migrations that have been removed from the code but might
 * still be in the migrations table
 */
async function cleanupRemovedMigrations(dbConn: Database) {
  try {
    // Check if the add_vector_db_settings migration exists in the table
    const migrationExists = await dbConn.select<{ name: string }[]>(
      'SELECT name FROM migrations WHERE name = ?',
      ['add_vector_db_settings']
    );
    if (migrationExists.length > 0) {
      console.log("Removing obsolete migration record: add_vector_db_settings");
      await dbConn.execute(
        'DELETE FROM migrations WHERE name = ?',
        ['add_vector_db_settings']
      );
    }
  } catch (error) {
    console.error("Error cleaning up removed migrations:", error);
  }
}
</file>

<file path="src/lib/openai.ts">
import OpenAI from "openai";
import { toast } from "sonner";
/**
 * Initialize OpenAI client with API key
 */
export const initializeOpenAI = (apiKey: string): OpenAI => {
  return new OpenAI({
    apiKey,
    dangerouslyAllowBrowser: true // Required for frontend usage
  });
};
/**
 * Count tokens in text using Rust implementation
 */
export const countTokens = async (text: string, model: "gpt-4o-mini" | "text-embedding-3-large" = "gpt-4o-mini"): Promise<number> => {
  try {
    // Use the Rust implementation via Tauri command
    const { invoke } = await import('@tauri-apps/api/core');
    // Map model names to tokenizer types
    const tokenizerType = model === "gpt-4o-mini" ? "o200k_base" : "cl100k_base";
    const count = await invoke('count_tokens', { text, modelType: tokenizerType }) as number;
    return count;
  } catch (error) {
    // Fallback to simple approximation if Rust implementation fails
    console.warn("Rust token counting failed, using fallback:", error);
    return Math.ceil(text.length / 4);
  }
};
/**
 * Token count cache to avoid repeated token counting operations
 */
const tokenCountCache = new Map<string, number>();
/**
 * Count tokens with caching to avoid repeated token counting operations
 */
export const cachedCountTokens = async (text: string, model: "gpt-4o-mini" | "text-embedding-3-large" = "gpt-4o-mini"): Promise<number> => {
  // For very short strings, don't bother with cache
  if (text.length < 50) return await countTokens(text, model);
  // Generate cache key
  const cacheKey = `${text.substring(0, 100)}:${text.length}:${model}`;
  if (tokenCountCache.has(cacheKey)) {
    return tokenCountCache.get(cacheKey)!;
  }
  const count = await countTokens(text, model);
  tokenCountCache.set(cacheKey, count);
  // Keep cache size manageable
  if (tokenCountCache.size > 1000) {
    // Delete oldest entries (first 200)
    const keysToDelete = Array.from(tokenCountCache.keys()).slice(0, 200);
    keysToDelete.forEach(key => tokenCountCache.delete(key));
  }
  return count;
};
/**
 * Advanced text chunking function using Rust backend for optimal performance
 * 
 * Default values:
 * - For AI text completion (chat): Use ~128k tokens to leverage the full gpt-4o-mini context window
 * - For embeddings: Use ~8k tokens which is the optimal chunking size for embedding models
 * 
 * The function automatically detects content type (text, markdown, code) and uses the appropriate splitter
 */
export const chunkTextByTokens = async (
  text: string,
  maxTokens: number = 0, // 0 means use model-specific defaults (8k for embeddings, 128k for gpt-4o)
  model: "gpt-4o-mini" | "text-embedding-3-large" = "gpt-4o-mini",
  chunkOverlap: number = 200,
  contentType?: "text" | "markdown" | "code" // Optional content type hint
): Promise<string[]> => {
  try {
    console.log(`Splitting text using Rust implementation (model: ${model}, maxTokens: ${maxTokens || "default"})`);
    // Use the Rust implementation via Tauri command
    const { invoke } = await import('@tauri-apps/api/core');
    // Map model names to tokenizer types
    const tokenizerType = model === "gpt-4o-mini" ? "o200k_base" : "cl100k_base";
    // Call Rust function with enhanced parameters
    const chunks = await invoke('split_text_by_tokens', { 
      text, 
      modelType: tokenizerType,
      chunkSize: maxTokens, // 0 will use model default (8k or 128k)
      chunkOverlap,
      contentType // Pass optional content type hint
    }) as string[];
    console.log(`✅ Split text into ${chunks.length} chunks using Rust implementation`);
    return chunks;
  } catch (error) {
    console.warn("Rust text splitting failed, falling back to JS implementation:", error);
    return fallbackChunkText(text, maxTokens || (model === "gpt-4o-mini" ? 128000 : 8000));
  }
};
/**
 * Legacy text chunking implementation for fallback
 * Only used if the Rust implementation fails
 */
export const fallbackChunkText = (
  text: string,
  maxTokens: number = 120000, // Default optimized for GPT-4o-mini's context window  
): string[] => {
  // Simple fallback implementation - split by paragraphs
  const paragraphs = text.split(/\n\s*\n/);
  const chunks: string[] = [];
  let currentChunk = "";
  let estimatedTokens = 0;
  for (const paragraph of paragraphs) {
    // Skip empty paragraphs
    if (!paragraph.trim()) continue;
    // Estimate tokens (simple 1:4 character ratio)
    const estimatedParagraphTokens = Math.ceil(paragraph.length / 4);
    if (estimatedTokens + estimatedParagraphTokens <= maxTokens) {
      // Paragraph fits in current chunk
      currentChunk += (currentChunk ? "\n\n" : "") + paragraph;
      estimatedTokens += estimatedParagraphTokens;
    } else {
      // Paragraph doesn't fit, start a new chunk
      if (currentChunk) {
        chunks.push(currentChunk);
      }
      // If paragraph itself is too large, just add it as its own chunk
      currentChunk = paragraph;
      estimatedTokens = estimatedParagraphTokens;
    }
  }
  // Add the last chunk
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  return chunks;
};
// For backwards compatibility
export const chunkTextRecursively = chunkTextByTokens;
/**
 * Process markdown with GPT-4o-mini for cleanup
 */
export const processMarkdownWithAI = async (
  markdown: string,
  apiKey: string,
  params?: {
    model?: string;
    maxTokens?: number;
    temperature?: number;
  }
): Promise<string> => {
  if (!markdown || markdown.trim() === "") {
    return "";
  }
  // Apply default parameters if not provided
  const model = params?.model || "gpt-4o-mini";
  const maxTokens = params?.maxTokens || 120000; // Default optimized for GPT-4o-mini
  const temperature = params?.temperature !== undefined ? params?.temperature : 0.2;
  // Declare the chunks variable at the top level so it's accessible in both try and catch blocks
  let chunks: string[] = [];
  try {
    console.log("Initializing OpenAI client for markdown processing");
    // Create a new OpenAI client for this processing operation
    const openai = initializeOpenAI(apiKey);
    // Count tokens to see if we need to chunk
    const tokenCount = await cachedCountTokens(markdown, "gpt-4o-mini");
    console.log(`Markdown is approximately ${tokenCount} tokens`);
    if (tokenCount <= maxTokens) {
      // If we're within token limits, just process the whole thing
      console.log("Processing entire markdown with OpenAI (no chunking needed)");
      const startTime = performance.now();
      // Add progress notification
      toast.loading("Processing markdown with AI...", {
        id: "markdown-processing",
        duration: Infinity, // Don't auto-dismiss
      });
      try {
        // Use the OpenAI API directly
        const completion = await openai.beta.chat.completions.parse({
          model: model,
          messages: [
            {
              role: "system",
              content: `You are an expert documentation assistant. Your task is to clean up and reformat Markdown documentation. Follow these rules:
              1. Fix formatting issues like broken tables, code blocks, or mismatched Markdown syntax
              2. Remove any headers that seem to be navigation or UI elements (sidebars, top bars, etc.)
              3. Fix any text that appears to be cut off or truncated
              4. Preserve all code examples and technical details exactly
              5. Keep all URLs intact
              6. Maintain the original structure and hierarchy of the document
              7. Do not modify the actual technical content or explanations
              8. Do not add commentary or your own insights
              9. Do not remove any technical content
              10. Do not omit any sections
              Return only the cleaned Markdown with no explanations or other text.`
            },
            {
              role: "user",
              content: markdown
            }
          ],
          temperature: temperature,
        });
        // Access the content from the response
        const result = completion.choices?.[0]?.message?.content || "";
        // Success - dismiss the toast
        toast.dismiss("markdown-processing");
        const endTime = performance.now();
        console.log(`✅ OpenAI processing completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);
        return result;
      } catch (error) {
        // Dismiss the toast in case of error
        toast.dismiss("markdown-processing");
        console.error("❌ Error processing markdown with OpenAI:", error);
        throw error;
      }
    }
    // We need to chunk the markdown
    console.log("Markdown exceeds token limit, chunking...");
    // Use nearly the full context window - GPT-4o-mini has 128k input tokens separate from output tokens
    chunks = await chunkTextByTokens(markdown, 127000, "gpt-4o-mini", 0, "markdown");
    console.log(`Markdown split into ${chunks.length} chunks`);
    // Process chunks in parallel with a concurrency limit
    const MAX_CONCURRENT = 3; // Process 3 chunks at a time
    let cleanedChunks: string[] = new Array(chunks.length);
    console.log(`Processing chunks with OpenAI (max ${MAX_CONCURRENT} concurrent requests):`);
    // Process chunks with limited concurrency
    for (let i = 0; i < chunks.length; i += MAX_CONCURRENT) {
      const currentBatch = chunks.slice(i, i + MAX_CONCURRENT);
      const batchStartIndices = Array.from({length: currentBatch.length}, (_, idx) => i + idx);
      const batchStartTime = performance.now();
      console.log(`Processing batch of ${currentBatch.length} chunks (${i+1}-${i+currentBatch.length}/${chunks.length})`);
      // Create an array of promises for this batch
      const batchPromises = currentBatch.map((chunk, batchIndex) => {
        const chunkIndex = i + batchIndex + 1;
        const toastId = `chunk-${chunkIndex}`;
        // Create a toast for each chunk in the batch
        toast.loading(`Processing chunk ${chunkIndex}/${chunks.length}...`, {
          id: toastId,
          duration: 60000, // Auto-dismiss after 60 seconds as a fallback
        });
        return (async () => {
          try {
            const chunkStartTime = performance.now();
            // Use the OpenAI API
            const completionResult = await openai.beta.chat.completions.parse({
              model: model,
              messages: [
                {
                  role: "system",
                  content: `You are an expert documentation assistant. Your task is to clean up and reformat a PORTION of Markdown documentation. Follow these rules:
                  1. Fix formatting issues like broken tables, code blocks, or mismatched Markdown syntax
                  2. Remove any headers that seem to be navigation or UI elements (sidebars, top bars, etc.)
                  3. Fix any text that appears to be cut off or truncated
                  4. Preserve all code examples and technical details exactly
                  5. Keep all URLs intact
                  6. Maintain the original structure and hierarchy of the document portion
                  7. Do not modify the actual technical content or explanations
                  8. Do not add commentary or your own insights
                  9. Do not remove any technical content
                  10. Do not omit any sections
                  11. This is part of a larger document, so avoid adding conclusions or summaries
                  Return only the cleaned Markdown portion with no explanations or other text.`
                },
                {
                  role: "user",
                  content: chunk
                }
              ],
              temperature: temperature,
            });
            // Get the result
            const cleanedChunk = completionResult.choices?.[0]?.message?.content || "";
            // Update toast and log results
            toast.dismiss(toastId);
            if (!cleanedChunk) {
              console.error(`Error processing chunk ${chunkIndex}/${chunks.length}: No content returned`);
              toast.error(`Error processing chunk ${chunkIndex}/${chunks.length}: No content returned`, {
                duration: 3000,
              });
              return { index: batchStartIndices[batchIndex], content: chunk }; // Return original as fallback
            } else {
              const chunkEndTime = performance.now();
              console.log(`✅ Chunk ${chunkIndex}/${chunks.length} processed in ${((chunkEndTime - chunkStartTime) / 1000).toFixed(2)}s`);
              return { index: batchStartIndices[batchIndex], content: cleanedChunk };
            }
          } catch (chunkError) {
            // Handle error
            toast.dismiss(toastId);
            console.error(`❌ Error processing chunk ${chunkIndex}/${chunks.length}:`, chunkError);
            return { index: batchStartIndices[batchIndex], content: chunk }; // Return original as fallback
          }
        })();
      });
      // Wait for all promises in the current batch to resolve
      const batchResults = await Promise.all(batchPromises);
      // Store results in the correct order
      batchResults.forEach(result => {
        cleanedChunks[result.index] = result.content;
      });
      const batchEndTime = performance.now();
      console.log(`✅ Batch ${i/MAX_CONCURRENT + 1} processed in ${((batchEndTime - batchStartTime) / 1000).toFixed(2)}s`);
    }
    // Join the chunks back together
    const result = cleanedChunks.join("\n\n");
    return result;
  } catch (error) {
    console.error("❌ Fatal error in processMarkdownWithAI:", error);
    // Dismiss any lingering toasts
    toast.dismiss("markdown-processing");
    // Just in case - try to dismiss any lingering chunk toasts
    for (let i = 1; i <= Math.min(100, chunks?.length || 20); i++) {
      toast.dismiss(`chunk-${i}`);
    }
    throw error;
  }
};
/**
 * Generate embeddings for text using OpenAI API
 */
export const generateEmbedding = async (
  text: string,
  apiKey: string,
  model: string = "text-embedding-3-large",
  dimensions: number = 3072 // Default to 3072 dimensions to match MCP server
): Promise<number[]> => {
  try {
    // Check if API key is provided
    if (!apiKey || apiKey.trim() === "") {
      const error = new Error("OpenAI API key is missing. Please add your API key in Settings.");
      console.error("Error generating embedding: Missing API key");
      toast.error("OpenAI API key is missing. Please add your API key in Settings.", {
        id: "missing-api-key-embedding",
        duration: 5000,
      });
      throw error;
    }
    // Log the first and last few characters of the API key for debugging
    console.log(`Using API key for embedding: ${apiKey.substring(0, 5)}...${apiKey.substring(apiKey.length - 4)}`);
    const openai = initializeOpenAI(apiKey);
    const response = await openai.embeddings.create({
      model: model,
      input: text,
      dimensions: dimensions, // Use 3072 dimensions by default
      encoding_format: "float"
    });
    return response.data[0].embedding;
  } catch (error) {
    console.error("Error generating embedding:", error);
    // Check if it's an authentication error
    if (error instanceof Error && error.message.includes("401")) {
      toast.error("Invalid OpenAI API key. Please check your API key in Settings.", {
        id: "invalid-api-key-embedding",
        duration: 5000,
      });
    }
    throw error;
  }
};
/**
 * Process a document for embedding by generating an embedding for the text
 * Note: This uses different chunking settings from text completion - 8k is optimal for embeddings
 */
export const processDocumentForEmbedding = async (
  document: string,
  apiKey: string,
  dimensions: number = 3072 // Default to 3072 dimensions to match MCP server
): Promise<number[]> => {
  // Chunk text using our Rust implementation with optimal settings for embeddings
  // Let the function use default size (8191) for embedding model with no overlap (we rely on semantic chunking)
  const chunks = await chunkTextByTokens(document, 0, "text-embedding-3-large", 0);
  // Get embeddings for each chunk
  const chunkEmbeddings: number[][] = [];
  for (const chunk of chunks) {
    const embedding = await generateEmbedding(chunk, apiKey, "text-embedding-3-large", dimensions);
    chunkEmbeddings.push(embedding);
  }
  // If only one chunk, return its embedding
  if (chunkEmbeddings.length === 1) {
    return chunkEmbeddings[0];
  }
  // Otherwise compute mean embedding
  const dimensions_count = chunkEmbeddings[0].length;
  const meanEmbedding = new Array(dimensions_count).fill(0);
  for (const embedding of chunkEmbeddings) {
    for (let i = 0; i < dimensions_count; i++) {
      meanEmbedding[i] += embedding[i] / chunkEmbeddings.length;
    }
  }
  // Normalize the mean embedding to unit length
  const norm = Math.sqrt(meanEmbedding.reduce((sum, val) => sum + val * val, 0));
  const normalizedEmbedding = meanEmbedding.map(val => val / norm);
  return normalizedEmbedding;
};
</file>

<file path="src/lib/pipeline.ts">
import { toast } from 'sonner';
import { FullDocumentationSnippet, DocumentationCategory, updateURLCleanedMarkdown, updateURLStatus } from './db';
import { convertToMarkdown } from './crawler';
import { processMarkdownWithAI } from './openai';
import { processMarkdownIntoSnippets } from './processor';
/**
 * Pipeline interfaces
 */
export interface DocumentSource {
  url: string;
  markdown: string;
  id?: number; // Add optional id field to allow database updates
}
export interface ProcessingOptions {
  cleanupModel: string;
  temperature: number;
  maxTokens: number;
  extractConcepts: boolean;
  maxConcurrency?: number; // Optional parameter for controlling max parallel processing
}
// Add new interface for vector DB operations
export interface VectorDBOperations {
  addDocuments: (documents: any[]) => Promise<void>;
  isInitialized: boolean;
}
export interface TechDetails {
  category: DocumentationCategory;
  language?: string;
  languageVersion?: string;
  framework?: string;
  frameworkVersion?: string;
  library?: string;
  libraryVersion?: string;
}
/**
 * Processing pipeline status
 */
export enum ProcessingStatus {
  IDLE = 'idle',
  CONVERTING = 'converting',
  CLEANING = 'cleaning',
  CHUNKING = 'chunking',
  EMBEDDING = 'embedding',
  COMPLETE = 'complete',
  ERROR = 'error'
}
/**
 * Full processing pipeline for a single document with non-blocking UI updates
 */
export async function processDocument(
  source: DocumentSource,
  techDetails: TechDetails,
  apiKey: string,
  vectorDBOps: VectorDBOperations,
  options: ProcessingOptions,
  onStatusChange: (status: ProcessingStatus, progress?: number) => void,
  urlId?: number
): Promise<FullDocumentationSnippet[]> {
  try {
    // We skip the HTML conversion step entirely - only work with markdown
    // Go directly to cleaning up the markdown with AI
    onStatusChange(ProcessingStatus.CLEANING);
    console.log("Starting AI cleanup of Markdown");
    try {
      // Use the AI processing directly - no need for additional timeout
      const cleanedMarkdown = await processMarkdownWithAI(source.markdown, apiKey, {
        model: options.cleanupModel,
        maxTokens: options.maxTokens,
        temperature: options.temperature
      });
      console.log("Finished AI cleanup of Markdown");
      // Store cleaned markdown in the database if we have a URL ID
      if (urlId) {
        console.log(`Updating cleaned markdown for URL ID ${urlId} in database`);
        await updateURLCleanedMarkdown(urlId, cleanedMarkdown);
        console.log(`Successfully saved cleaned markdown for URL ID ${urlId}`);
      } else {
        console.log("No URL ID provided, skipping database update for cleaned markdown");
      }
      // Step 3: Process into snippets with concepts
      onStatusChange(ProcessingStatus.CHUNKING);
      console.log("Processing Markdown into snippets");
      const snippets = await processMarkdownIntoSnippets(
        cleanedMarkdown,
        apiKey,
        source.url,
        techDetails.category,
        {
          language: techDetails.language,
          language_version: techDetails.languageVersion,
          framework: techDetails.framework,
          framework_version: techDetails.frameworkVersion,
          library: techDetails.library,
          library_version: techDetails.libraryVersion
        }
      );
      console.log(`Created ${snippets.length} snippets`);
      // Step 4: Store all snippets in VectorDB in a single batch operation
      onStatusChange(ProcessingStatus.EMBEDDING);
      console.log("Starting to store snippets in VectorDB");
      console.log(`Attempting to store ${snippets.length} snippets for URL: ${source.url}`);
      try {
        await vectorDBOps.addDocuments(snippets);
        console.log(`Successfully stored ${snippets.length} snippets in vector DB for ${source.url}`);
      } catch (storageError) {
        console.error(`Failed to store snippets in vector DB for ${source.url}:`, storageError);
        throw storageError;
      }
      onStatusChange(ProcessingStatus.COMPLETE);
      console.log("Document processing complete");
      return snippets;
    } catch (cleanupError) {
      console.error("Error during markdown cleanup:", cleanupError);
      toast.error(`Markdown cleanup failed: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`);
      // Continue with the original markdown if cleanup fails
      console.log("Using original markdown as fallback after cleanup failure");
      // Step 3: Process into snippets with concepts (using original markdown)
      onStatusChange(ProcessingStatus.CHUNKING);
      console.log("Processing original Markdown into snippets");
      const snippets = await processMarkdownIntoSnippets(
        source.markdown,  // Use original markdown as fallback
        apiKey,
        source.url,
        techDetails.category,
        {
          language: techDetails.language,
          language_version: techDetails.languageVersion,
          framework: techDetails.framework,
          framework_version: techDetails.frameworkVersion,
          library: techDetails.library,
          library_version: techDetails.libraryVersion
        }
      );
      // Step 4: Store all snippets in VectorDB in a single batch operation
      onStatusChange(ProcessingStatus.EMBEDDING);
      console.log("Starting to store snippets in VectorDB");
      // Use the optimized batch method to store all snippets at once
      await vectorDBOps.addDocuments(snippets);
      // Report 100% progress when complete
      onStatusChange(ProcessingStatus.EMBEDDING, 100);
      console.log(`Processed ${snippets.length}/${snippets.length} snippets (100%)`);
      onStatusChange(ProcessingStatus.COMPLETE);
      console.log("Document processing complete");
      return snippets;
    }
  } catch (error) {
    console.error("Error processing document:", error);
    onStatusChange(ProcessingStatus.ERROR);
    throw error;
  }
}
/**
 * Process multiple documents in parallel with batched execution for optimized performance
 */
export async function processBatch(
  sources: DocumentSource[],
  techDetails: TechDetails,
  apiKey: string,
  vectorDBOps: VectorDBOperations,
  options: ProcessingOptions,
  onStatusChange: (url: string, status: ProcessingStatus, progress?: number, overallProgress?: number) => void,
  onComplete: (results: { url: string, snippets: FullDocumentationSnippet[], success: boolean, error?: string }[]) => void
): Promise<void> {
  if (!vectorDBOps.isInitialized) {
    throw new Error("Vector database is not available");
  }
  // Initialize results array with correct size to maintain order
  const results: ({ url: string, snippets: FullDocumentationSnippet[], success: boolean, error?: string } | undefined)[] = Array(sources.length).fill(undefined);
  // Track overall progress
  let completedCount = 0;
  const totalCount = sources.length;
  const updateOverallProgress = () => {
    const overallProgress = completedCount / totalCount;
    // Update all listeners with new overall progress
    console.log(`Overall progress: ${Math.round(overallProgress * 100)}% (${completedCount}/${totalCount})`);
    return overallProgress;
  };
  // Process documents in parallel with concurrency control
  const processBatchInParallel = async () => {
    // Use user-specified concurrency or default to 4
    const MAX_CONCURRENT = options.maxConcurrency || 4;
    console.log(`Using max concurrency: ${MAX_CONCURRENT}`);
    // Track processing URLs to persist state between batches
    const processedUrls = new Set<string>();
    for (let i = 0; i < sources.length; i += MAX_CONCURRENT) {
      const batch = sources.slice(i, i + MAX_CONCURRENT);
      console.log(`Processing batch ${i/MAX_CONCURRENT + 1}: ${batch.length} URLs (${i+1}-${Math.min(i+batch.length, sources.length)} of ${sources.length})`);
      const batchPromises = batch.map(async (source, batchIdx) => {
        const sourceIndex = i + batchIdx;
        // Skip if already processed (can happen if the user restarted processing)
        if (processedUrls.has(source.url)) {
          console.log(`Skipping ${source.url} as it was already processed`);
          return { url: source.url, snippets: [], success: true, index: sourceIndex };
        }
        // Notify status change at the beginning with overall progress
        const initialOverallProgress = updateOverallProgress();
        onStatusChange(source.url, ProcessingStatus.CONVERTING, 0, initialOverallProgress);
        try {
          // Each document has its own progress through several phases
          // Phase weights as percentages of document processing
          const PHASE_WEIGHTS: Record<ProcessingStatus, number> = {
            [ProcessingStatus.CONVERTING]: 0.1,  // 10% for HTML conversion
            [ProcessingStatus.CLEANING]: 0.3,    // 30% for AI cleaning 
            [ProcessingStatus.CHUNKING]: 0.2,    // 20% for chunking
            [ProcessingStatus.EMBEDDING]: 0.4,   // 40% for embedding
            [ProcessingStatus.IDLE]: 0,
            [ProcessingStatus.COMPLETE]: 1.0,
            [ProcessingStatus.ERROR]: 0
          };
          let currentPhase = ProcessingStatus.IDLE;
          // Calculate weighted progress across all phases
          const calculateDocumentProgress = (status: ProcessingStatus, phaseProgress = 1.0) => {
            // Calculate progress up to previous phases
            let progress = 0;
            for (const phase of [ProcessingStatus.CONVERTING, ProcessingStatus.CLEANING, 
                               ProcessingStatus.CHUNKING, ProcessingStatus.EMBEDDING]) {
              // Add completed prior phases
              if (phase === status) {
                // For current phase, multiply by phase progress
                progress += PHASE_WEIGHTS[phase] * phaseProgress;
                break;
              } else {
                // Add 100% of previous phases
                progress += PHASE_WEIGHTS[phase];
              }
            }
            return Math.min(progress, 1.0); // Cap at 100%
          };
          // Create a wrapper for the status change callback to match signatures
          const statusChangeWrapper = (status: ProcessingStatus, phaseProgress?: number) => {
            // Track current phase
            currentPhase = status;
            // Calculate document-level progress
            const documentProgress = calculateDocumentProgress(status, phaseProgress);
            // Update overall progress
            const overallProgress = updateOverallProgress();
            // Update the status for UI
            onStatusChange(source.url, status, documentProgress, overallProgress);
          };
          const snippets = await processDocument(
            source,
            techDetails,
            apiKey,
            vectorDBOps,
            options,
            statusChangeWrapper,
            source.id
          );
          // Mark this URL as processed
          processedUrls.add(source.url);
          // Update database to mark URL as processed immediately upon completion
          if (source.id) {
            try {
              await updateURLStatus(source.id, "processed");
              console.log(`✅ Marked URL ${source.url} as processed in database`);
            } catch (dbError) {
              console.error(`Failed to update URL status in database for ${source.url}:`, dbError);
            }
          } else {
            console.log(`No ID available for URL ${source.url}, skipping database status update`);
          }
          return { url: source.url, snippets, success: true, error: undefined, index: sourceIndex };
        } catch (error) {
          console.error(`Error processing document ${source.url}:`, error);
          return { url: source.url, snippets: [], success: false, error: error instanceof Error ? error.message : String(error), index: sourceIndex };
        }
      });
      const batchResults = await Promise.all(batchPromises);
      batchResults.forEach((result) => {
        if (result.success) {
          results[result.index] = {
            url: result.url,
            snippets: result.snippets,
            success: result.success,
            error: result.error
          };
        } else {
          console.error(`Error processing document ${result.url}:`, result.error);
        }
      });
      // Update overall progress
      completedCount += batch.length;
      updateOverallProgress();
    }
  };
  await processBatchInParallel();
  // Filter out undefined results
  const filteredResults = results
    .filter((result): result is { url: string, snippets: FullDocumentationSnippet[], success: boolean, error?: string } => 
      result !== undefined
    );
  // Call onComplete with filtered results
  onComplete(filteredResults);
}
</file>

<file path="src/lib/processor.ts">
import { z } from 'zod';
import { chunkTextRecursively, initializeOpenAI } from './openai';
import { FullDocumentationSnippet, DocumentationCategory } from './db';
import { zodResponseFormat } from 'openai/helpers/zod';
/**
 * Schema for a documentation snippet from structured output
 */
const DocumentSnippetSchema = z.object({
  title: z.string().describe("The title of the documentation snippet"),
  description: z.string().describe("A brief summary of what this snippet covers"),
  content: z.string().describe("The actual documentation content"),
  concepts: z.array(z.string()).describe("Key concepts covered in this snippet")
});
/**
 * Schema for the full processor output
 */
const ProcessorOutputSchema = z.object({
  snippets: z.array(DocumentSnippetSchema),
});
/**
 * Schema for concept extraction
 */
const ConceptsSchema = z.object({
  concepts: z.array(z.string()).describe("Key technical concepts extracted from the text")
});
export type DocumentSnippet = z.infer<typeof DocumentSnippetSchema>;
export type ProcessorOutput = z.infer<typeof ProcessorOutputSchema>;
/**
 * Process cleaned markdown into documentation snippets using GPT-4o-mini
 */
export async function processMarkdownIntoSnippets(
  markdown: string,
  apiKey: string,
  sourceUrl: string,
  category: DocumentationCategory,
  technicalInfo: {
    language?: string;
    language_version?: string;
    framework?: string;
    framework_version?: string;
    library?: string;
    library_version?: string;
  }
): Promise<FullDocumentationSnippet[]> {
  console.log("================================");
  console.log("PROCESSING MARKDOWN INTO SNIPPETS");
  console.log("================================");
  console.log(`Source URL: ${sourceUrl}`);
  console.log(`Category: ${category}`);
  console.log(`Technical info:`, technicalInfo);
  console.log(`Input markdown length: ${markdown.length} characters`);
  const startTime = performance.now();
  try {
    // Initialize OpenAI client
    console.log("Initializing OpenAI client");
    const openai = initializeOpenAI(apiKey);
    // First chunk the markdown to ensure it fits within token limits
    console.log("Chunking markdown for processing");
    // Set chunk size to 100,000 to better utilize GPT-4o-mini's 128k context window, no overlap needed with semantic chunking
    // First ensure markdown is a proper string
    if (!markdown || typeof markdown !== 'string') {
      console.error("Invalid markdown received:", markdown);
      throw new Error("Invalid markdown format: not a string");
    }
    const chunks = await chunkTextRecursively(markdown, 120000, "gpt-4o-mini", 500, "markdown");
    console.log(`Markdown split into ${chunks.length} chunks`);
    const allSnippets: FullDocumentationSnippet[] = [];
    // Process chunks in parallel with concurrency control
    const MAX_CONCURRENT = 3; // Process 3 chunks at a time
    for (let i = 0; i < chunks.length; i += MAX_CONCURRENT) {
      const batchChunks = chunks.slice(i, i + MAX_CONCURRENT);
      const batchStartTime = performance.now();
      console.log(`Processing batch of ${batchChunks.length} chunks (${i+1}-${i+Math.min(i+MAX_CONCURRENT, chunks.length)}/${chunks.length})`);
      // Create an array of promises for processing each chunk
      const chunkPromises = batchChunks.map((chunk, batchIndex) => {
        const chunkIndex = i + batchIndex;
        const chunkHeader = `Part ${chunkIndex+1}/${chunks.length}: `;
        return (async () => {
          console.log(`Processing chunk ${chunkIndex+1}/${chunks.length} (${chunk.length} characters)`);
          const chunkStartTime = performance.now();
          try {
            // Use OpenAI SDK with Zod schema for structured output
            const completion = await openai.beta.chat.completions.parse({
              model: "gpt-4o-mini",
              messages: [
                {
                  role: "system",
                  content: "You are a technical documentation processor that extracts comprehensive, self-contained documentation snippets from markdown content. Your goal is to create meaningful, substantial snippets that each contain a complete explanation of a concept or feature. Follow these guidelines:\n\n1. Focus on educational content and actual documentation, not metadata or navigation elements\n2. Combine related small sections into larger, more useful snippets\n3. Remove irrelevant links, navigation references, and unnecessary formatting\n4. Make sure each snippet is substantial enough to be useful on its own\n5. Snippets should be at least several paragraphs long when possible\n6. Never include URLs, navigation breadcrumbs, or revision history"
                },
                {
                  role: "user",
                  content: `${chunkHeader}Process this documentation markdown into substantial, comprehensive snippets. Create larger, more complete sections rather than tiny fragments. Remove unnecessary links, URLs, and navigation elements.\n\nFor each snippet, provide:\n- A clear, descriptive title\n- A brief summary (1-2 sentences)\n- Comprehensive content (combine related sections)\n- Key technical concepts covered\n\nFocus on creating useful, educational content:\n\n${chunk}`
                }
              ],
              temperature: 0.2,
              response_format: zodResponseFormat(ProcessorOutputSchema, "processor_output"),
            });
            // Get the parsed snippets directly from the parsed response
            const validatedOutput = completion.choices[0].message.parsed;
            if (!validatedOutput || !validatedOutput.snippets) {
              console.error(`❌ Chunk ${chunkIndex+1}/${chunks.length}: Invalid or empty response from OpenAI`);
              return [];
            }
            console.log(`✅ Chunk ${chunkIndex+1}/${chunks.length}: Received ${validatedOutput.snippets.length} snippets from OpenAI`);
            // Convert to our internal DocumentationSnippet format
            const snippets = validatedOutput.snippets.map((snippet, snippetIndex) => {
              // Create a unique ID for each snippet
              const snippetId = `${sourceUrl.replace(/[^a-zA-Z0-9]/g, '_')}_${chunkIndex}_${snippetIndex}`;
              if (!snippet.title || !snippet.description || !snippet.content) {
                console.error(`❌ Snippet ${chunkIndex}_${snippetIndex} has missing required fields`);
                return null;
              }
              return {
                category,
                language: technicalInfo.language,
                language_version: technicalInfo.language_version,
                framework: technicalInfo.framework,
                framework_version: technicalInfo.framework_version,
                library: technicalInfo.library,
                library_version: technicalInfo.library_version,
                snippet_id: snippetId,
                source_url: sourceUrl,
                title: snippet.title,
                description: snippet.description,
                content: snippet.content,
                concepts: snippet.concepts || []
              };
            }).filter((snippet): snippet is any => snippet !== null);
            const chunkEndTime = performance.now();
            console.log(`✅ Processed chunk ${chunkIndex+1}/${chunks.length} in ${((chunkEndTime - chunkStartTime) / 1000).toFixed(2)}s`);
            return snippets;
          } catch (error) {
            console.error(`❌ Error processing chunk ${chunkIndex+1}/${chunks.length}:`, error);
            return [];
          }
        })();
      });
      // Wait for all promises in this batch to complete
      const batchResults = await Promise.all(chunkPromises);
      // Flatten and add all snippets from this batch
      const batchSnippets = batchResults.flat();
      allSnippets.push(...batchSnippets);
      const batchEndTime = performance.now();
      console.log(`✅ Processed batch ${Math.floor(i/MAX_CONCURRENT) + 1} in ${((batchEndTime - batchStartTime) / 1000).toFixed(2)}s, got ${batchSnippets.length} snippets`);
    }
    const endTime = performance.now();
    console.log(`✅ Processed all ${chunks.length} chunks in ${((endTime - startTime) / 1000).toFixed(2)}s`);
    console.log(`Total snippets created: ${allSnippets.length}`);
    if (allSnippets.length === 0) {
      console.error("❌ No snippets were created");
      throw new Error("No snippets were created from the markdown content");
    }
    return allSnippets;
  } catch (error) {
    const endTime = performance.now();
    console.error(`❌ Error processing markdown into snippets in ${((endTime - startTime) / 1000).toFixed(2)}ms:`, error);
    throw error;
  }
}
/**
 * Extract key concepts from a given text
 */
export async function extractConcepts(
  text: string,
  apiKey: string
): Promise<string[]> {
  try {
    // Initialize OpenAI client
    const openai = initializeOpenAI(apiKey);
    // Use OpenAI SDK with Zod schema for structured output
    const completion = await openai.beta.chat.completions.parse({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You extract key technical concepts from documentation text. Return only a list of strings, with each string being a concept mentioned in the text."
        },
        {
          role: "user",
          content: `Extract all the key technical concepts from this text:\n\n${text}`
        }
      ],
      temperature: 0.2,
      response_format: zodResponseFormat(ConceptsSchema, "concepts_extraction"),
    });
    // Get concepts directly from the parsed response
    if (!completion.choices[0]?.message?.parsed) {
      console.warn("Invalid or empty response from OpenAI");
      return [];
    }
    return completion.choices[0].message.parsed.concepts || [];
  } catch (error) {
    console.error("Error extracting concepts:", error);
    return [];
  }
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/types/forms.ts">
import { z } from "zod";
/**
 * Setup form schema - No longer requires ChromaDB path
 */
export const setupFormSchema = z.object({});
export type SetupFormValues = z.infer<typeof setupFormSchema>;
/**
 * Session form schema
 */
export const sessionFormSchema = z.object({
  title: z.string().min(1, "Title is required"),
  version: z.string().optional(),
});
export type SessionFormValues = z.infer<typeof sessionFormSchema>;
/**
 * API settings form schema
 */
export const apiSettingsFormSchema = z.object({
  openai_key: z.string().optional(),
});
export type ApiSettingsValues = z.infer<typeof apiSettingsFormSchema>;
/**
 * Crawler settings form schema
 */
export const crawlerSettingsFormSchema = z.object({
  prefix_path: z.string().min(1, "Prefix path is required").url("Must be a valid URL"),
  anti_paths: z.string().optional(),
  anti_keywords: z.string().optional(),
});
export type CrawlerSettingsValues = z.infer<typeof crawlerSettingsFormSchema>;
/**
 * Crawler URL form schema
 */
export const urlFormSchema = z.object({
  url: z.string().url("Must be a valid URL")
});
export type UrlFormValues = z.infer<typeof urlFormSchema>;
/**
 * Markdown cleanup form schema
 */
export const markdownCleanupFormSchema = z.object({
  model: z.enum(["gpt-4o-mini"]).default("gpt-4o-mini"),
  temperature: z.number().min(0).max(1).default(0.2),
  maxTokens: z.number().min(1).max(120000).default(120000),
});
export type MarkdownCleanupValues = z.infer<typeof markdownCleanupFormSchema>;
</file>

<file path="src/App.css">
@import "tailwindcss";
@custom-variant dark (&:is(.dark *));
@plugin "tailwindcss-animate";
@plugin "@tailwindcss/typography";
@config "../tailwind.config.js";
:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}
.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.145 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.145 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.985 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.269 0 0);
  --input: oklch(0.269 0 0);
  --ring: oklch(0.439 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(0.269 0 0);
  --sidebar-ring: oklch(0.439 0 0);
}
@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;
  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}
@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
    min-height: 100vh;
    margin: 0;
    padding: 0;
  }
  /* Hide scrollbar but keep functionality */
  .no-scrollbar {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }
  .no-scrollbar::-webkit-scrollbar {
    display: none; /* Chrome, Safari and Opera */
  }
}
</file>

<file path="src/App.tsx">
import { useEffect, useState } from "react";
import { toast } from "sonner";
// Import fs plugin dynamically to prevent CORS issues during development
// import { exists } from "@tauri-apps/plugin-fs";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { getUserSettings, getSessions } from "./lib/db";
import { BookmarkIcon, StopCircle } from "lucide-react";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useVectorDB } from "./hooks/useVectorDB";
import SessionsPage from "./components/sessions/SessionsPage";
import SettingsPage from "./components/settings/SettingsPage";
import { CrawlSession, CrawlSettings } from "./lib/db";
import CrawlerForm from "./components/crawler/CrawlerForm";
import UrlInput from "./components/crawler/UrlInput";
import URLList from "./components/crawler/URLList";
import AiProcessing from "./components/crawler/AiProcessing";
import KnowledgeBase from "./components/knowledge/KnowledgeBase";
// Crawler page component
const CrawlerPage = ({ sessionId }: { sessionId: number | null }) => {
  const [settings, setSettings] = useState<CrawlSettings | null>(null);
  const [loading, setLoading] = useState(false);
  const [crawling, setCrawling] = useState(false);
  const [activeCrawlUrls, setActiveCrawlUrls] = useState<string[]>([]);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  // Fetch crawler settings when the component loads or sessionId changes
  useEffect(() => {
    if (sessionId === null) return;
    const loadSettings = async () => {
      try {
        setLoading(true);
        // Import and use getCrawlSettings
        const { getCrawlSettings } = await import("./lib/db");
        const settings = await getCrawlSettings(sessionId);
        console.log("Loaded crawler settings:", settings);
        setSettings(settings);
      } catch (error) {
        console.error("Failed to load crawler settings:", error);
      } finally {
        setLoading(false);
      }
    };
    loadSettings();
  }, [sessionId]);
  // Poll for active crawling status
  useEffect(() => {
    if (!crawling) return;
    const intervalId = setInterval(async () => {
      try {
        const { getCrawlingStatus } = await import("./lib/crawler");
        const status = getCrawlingStatus();
        // Update UI with current crawling status
        setCrawling(status.isCrawling);
        setActiveCrawlUrls(status.activeCrawlUrls);
        // If crawling is no longer active, trigger URL refresh
        if (!status.isCrawling && crawling) {
          setRefreshTrigger(prev => prev + 1);
          toast.success("Crawling completed!");
        }
      } catch (error) {
        console.error("Error checking crawler status:", error);
      }
    }, 1000);
    return () => clearInterval(intervalId);
  }, [crawling]);
  const handleStartCrawling = async (selectedUrls: string[]) => {
    if (!settings) {
      toast.error("Crawler settings not loaded. Please save settings first.");
      return;
    }
    if (selectedUrls.length === 0) {
      toast.error("No URLs selected for crawling.");
      return;
    }
    try {
      setCrawling(true);
      toast.info(`Starting crawler for ${selectedUrls.length} URLs...`);
      // Import the required functions
      const { startCrawler, resetCrawlerState } = await import("./lib/crawler");
      // Reset crawler state before starting
      resetCrawlerState();
      // Start crawling for each selected URL
      for (const url of selectedUrls) {
        await startCrawler({
          startUrl: url,
          prefixPath: settings.prefix_path || url.split('/').slice(0, 3).join('/'),
          antiPaths: settings.anti_paths ? settings.anti_paths.split(',').map(p => p.trim()) : [],
          antiKeywords: settings.anti_keywords ? settings.anti_keywords.split(',').map(k => k.trim()) : [],
          sessionId: sessionId as number,
          maxConcurrentRequests: settings.max_concurrent_requests,
          unlimitedParallelism: !!settings.unlimited_parallelism
        });
      }
    } catch (error) {
      console.error("Error during crawling:", error);
      toast.error("An error occurred during crawling. Check console for details.");
      setCrawling(false);
    }
  };
  const handleStopCrawling = async () => {
    try {
      const { stopCrawling } = await import("./lib/crawler");
      stopCrawling();
      toast.info("Stopping crawler. Currently processing URLs will complete...");
    } catch (error) {
      console.error("Error stopping crawler:", error);
      toast.error("Failed to stop crawler");
    }
  };
  const handleUrlAdded = async (url: string) => {
    if (!sessionId) return;
    try {
      // Add URL to the database
      const { addURL } = await import("./lib/db");
      await addURL({
        session_id: sessionId,
        url,
        status: 'pending'
      });
      // Signal refresh - use a smaller value for incremental refresh
      setRefreshTrigger(prev => prev + 0.1);
      toast.success("URL added successfully");
    } catch (error) {
      console.error("Error adding URL:", error);
      toast.error("Failed to add URL. Please try again.");
    }
  };
  if (sessionId === null) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Web Crawler</CardTitle>
          <CardDescription>Configure and start web crawling.</CardDescription>
        </CardHeader>
        <CardContent>
          <p>Select a session first to configure the crawler.</p>
        </CardContent>
      </Card>
    );
  }
  const handleSettingsSaved = (newSettings: CrawlSettings) => {
    console.log("Settings saved:", newSettings);
    setSettings(newSettings);
    toast.success("Crawler settings saved successfully");
  };
  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Web Crawler</CardTitle>
          <CardDescription>Loading crawler settings...</CardDescription>
        </CardHeader>
        <CardContent className="flex justify-center py-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </CardContent>
      </Card>
    );
  }
  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle>Web Crawler</CardTitle>
          <CardDescription>Configure and start web crawling for session #{sessionId}.</CardDescription>
        </CardHeader>
        <CardContent>
          <CrawlerForm 
            sessionId={sessionId} 
            existingSettings={settings || undefined}
            onSettingsSaved={handleSettingsSaved}
          />
        </CardContent>
      </Card>
      {settings && (
        <>
          {crawling && (
            <Card className="bg-amber-50 dark:bg-amber-950 border-amber-200 dark:border-amber-900">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>Crawling in Progress</span>
                  <Button 
                    variant="destructive" 
                    onClick={handleStopCrawling}
                    className="ml-2"
                  >
                    Stop Crawling
                  </Button>
                </CardTitle>
                <CardDescription>
                  {activeCrawlUrls.length > 0 
                    ? `Currently crawling: ${activeCrawlUrls.join(', ')}` 
                    : 'Processing...'
                  }
                </CardDescription>
              </CardHeader>
            </Card>
          )}
          <Card>
            <CardHeader>
              <CardTitle>Add Starting URL</CardTitle>
              <CardDescription>Add a URL to start crawling from</CardDescription>
            </CardHeader>
            <CardContent>
              <UrlInput 
                sessionId={sessionId as number}
                prefixPath={settings.prefix_path}
                antiPaths={(settings.anti_paths || "").split(",").filter(Boolean).map(path => path.trim())}
                antiKeywords={(settings.anti_keywords || "").split(",").filter(Boolean).map(keyword => keyword.trim())}
                onUrlAdded={handleUrlAdded}
                disabled={crawling}
              />
            </CardContent>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle>URL Management</CardTitle>
              <CardDescription>Manage and start crawling URLs</CardDescription>
            </CardHeader>
            <CardContent>
              <URLList 
                sessionId={sessionId as number}
                onStartCrawling={handleStartCrawling}
                refreshTrigger={refreshTrigger}
                isCrawling={crawling}
              />
            </CardContent>
          </Card>
        </>
      )}
    </div>
  );
};
// Main application component
const MainApp = () => {
  const [sessions, setSessions] = useState<CrawlSession[]>([]);
  const [activeSession, setActiveSession] = useState<CrawlSession | null>(null);
  const [activeTab, setActiveTab] = useState("crawler");
  const [apiKey, setApiKey] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [apiKeyLoaded, setApiKeyLoaded] = useState(false);
  // Load OpenAI API key
  useEffect(() => {
    const loadApiKey = async () => {
      try {
        console.log("Loading API key from multiple sources...");
        let key = "";
        // First try from database
        try {
          console.log("Checking database for API key...");
          const settings = await getUserSettings();
          console.log("Retrieved settings:", settings);
          if (settings?.openai_key) {
            const keyLength = settings.openai_key.length;
            console.log(`Found API key in database settings (length: ${keyLength}, starts with: ${settings.openai_key.substring(0, 5)}..., ends with: ...${settings.openai_key.substring(keyLength - 4)})`);
            key = settings.openai_key;
          } else {
            console.log("No API key found in database settings");
          }
        } catch (dbError) {
          console.error("Error accessing database for API key:", dbError);
        }
        // If no key from database, try environment variable
        if (!key) {
          console.log("Checking environment for API key...");
          const envKey = import.meta.env.VITE_OPENAI_API_KEY;
          if (envKey) {
            const keyLength = envKey.length;
            console.log(`Found API key in environment (length: ${keyLength}, starts with: ${envKey.substring(0, 5)}..., ends with: ...${envKey.substring(keyLength - 4)})`);
            key = envKey;
          } else {
            console.log("No API key found in environment");
          }
        }
        // Set the API key state if we found one
        if (key) {
          console.log("Setting API key in state");
          setApiKey(key);
        } else {
          console.log("No API key found in any source");
          setApiKey("");
          // Show a toast notification if no API key is found
          toast.error("OpenAI API key is missing. Please add your API key in Settings.", {
            id: "missing-api-key-app",
            duration: 5000,
          });
        }
      } catch (error) {
        console.error("Error loading API key:", error);
        setApiKey("");
      } finally {
        setApiKeyLoaded(true);
        setLoading(false);
      }
    };
    loadApiKey();
  }, []); // Empty dependency array means this runs once on mount
  // Load sessions
  useEffect(() => {
    const loadSessions = async () => {
      try {
        const result = await getSessions();
        setSessions(result);
        setLoading(false);
      } catch (error) {
        console.error("Error loading sessions:", error);
        toast.error("Failed to load sessions");
        setLoading(false);
      }
    };
    loadSessions();
  }, []);
  // Add crawling status state
  const [isCrawling, setIsCrawling] = useState(false);
  // Function to check crawling status periodically
  useEffect(() => {
    let interval: ReturnType<typeof setInterval>;
    const checkCrawlingStatus = async () => {
      try {
        const { getCrawlingStatus } = await import("./lib/crawler");
        const status = getCrawlingStatus();
        setIsCrawling(status.isCrawling);
      } catch (error) {
        console.error("Error checking crawler status:", error);
      }
    };
    // Check immediately and then every 3 seconds
    checkCrawlingStatus();
    interval = setInterval(checkCrawlingStatus, 3000);
    return () => {
      clearInterval(interval);
    };
  }, []);
  // Function to stop crawling
  const handleGlobalStopCrawling = async () => {
    try {
      const { stopCrawling } = await import("./lib/crawler");
      stopCrawling();
      toast.info("Stopping crawler. Currently processing URLs will complete...");
      // Reset crawler state after a short delay
      setTimeout(async () => {
        try {
          const { resetCrawlerState } = await import("./lib/crawler");
          resetCrawlerState();
          console.log("Crawler state has been reset");
        } catch (error) {
          console.error("Error resetting crawler state:", error);
        }
      }, 5000); // Wait 5 seconds to ensure all processes have finished
    } catch (error) {
      console.error("Error stopping crawler:", error);
      toast.error("Failed to stop crawler");
    }
  };
  // Persistent states for tabs
  const [urlsLoaded, setUrlsLoaded] = useState(false); // Track if URLs were already loaded
  // Function to change active tab
  const handleTabChange = (value: string) => {
    // Store previous tab for reference
    const prevTab = activeTab;
    // Update active tab
    setActiveTab(value);
    // Track what data has been loaded for smoother transitions
    if (value === "processing") {
      // Mark URLs as needing reload only if we haven't loaded them yet or coming from sessions tab
      // This prevents duplicate loading when switching between tabs
      if (!urlsLoaded || prevTab === "sessions") {
        setUrlsLoaded(true);
      }
    }
    // Log when switching to knowledge tab to help debug vector DB initialization
    if (value === "knowledge" && activeSession) {
      console.log(`App: Switched to knowledge tab with session ${activeSession.id}, ensuring vector DB is initialized`);
    }
  };
  // Initialize vector DB when a session is selected
  const { isInitialized: vectorDBInitialized, loading: vectorDBLoading, error: vectorDBError } = 
    useVectorDB(activeSession?.id ?? -1);
  // Log vector DB initialization status when it changes
  useEffect(() => {
    if (activeSession?.id) {
      console.log(`App: Vector DB status for session ${activeSession.id}: initialized=${vectorDBInitialized}, loading=${vectorDBLoading}, error=${vectorDBError ? 'yes' : 'no'}`);
    }
  }, [activeSession?.id, vectorDBInitialized, vectorDBLoading, vectorDBError]);
  const handleSelectSession = (session: CrawlSession) => {
    // When selecting a new session, we need to reset our loaded states
    if (activeSession?.id !== session.id) {
      setUrlsLoaded(false);
      // Log session selection for debugging
      console.log(`App: Selected session ${session.id}`);
    }
    setActiveSession(session);
    setActiveTab("crawler");
  };
  return (
    <TooltipProvider>
      <div className="flex flex-col h-screen">
        {/* Main navigation */}
        <div className="border-b bg-background">
          <div className="flex h-14 items-center px-4 justify-between">
            <div className="flex items-center">
              <BookmarkIcon className="h-6 w-6 text-primary" />
              <h1 className="ml-2 text-lg font-semibold">Anchoring</h1>
            </div>
            {/* Add global stop crawling button */}
            {isCrawling && (
              <Button 
                variant="destructive" 
                onClick={handleGlobalStopCrawling}
                className="mr-4"
                size="sm"
              >
                <StopCircle className="h-4 w-4 mr-2" />
                Stop All Crawling
              </Button>
            )}
            <div className="flex items-center gap-4">
              <div className="text-sm text-muted-foreground">
                {activeSession ? `Session: ${activeSession.title}${activeSession.version ? ` V${activeSession.version}` : ""}` : "No active session"}
              </div>
            </div>
          </div>
        </div>
        <div className="container mx-auto py-4 space-y-4">
          <Tabs 
            defaultValue="sessions" 
            value={activeTab} 
            onValueChange={handleTabChange} 
            className="space-y-4"
          >
            <TabsList className="grid grid-cols-5">
              <TabsTrigger value="sessions">Sessions</TabsTrigger>
              <TabsTrigger value="crawler">Crawler</TabsTrigger>
              <TabsTrigger value="processing">AI Processing</TabsTrigger>
              <TabsTrigger value="knowledge">Knowledge Base</TabsTrigger>
              <TabsTrigger value="settings">Settings</TabsTrigger>
            </TabsList>
            <TabsContent value="sessions">
              <SessionsPage 
                onSelectSession={handleSelectSession}
              />
            </TabsContent>
            <TabsContent value="crawler">
              <CrawlerPage sessionId={activeSession?.id || null} />
            </TabsContent>
            <TabsContent value="processing">
              {loading ? (
                <div className="flex items-center justify-center p-8">
                  <span className="loading loading-spinner loading-lg"></span>
                </div>
              ) : (
                <AiProcessing 
                  sessionId={activeSession?.id || 0} 
                  apiKey={apiKey}
                />
              )}
            </TabsContent>
            <TabsContent value="knowledge">
              <KnowledgeBase sessionId={activeSession?.id ?? -1} />
            </TabsContent>
            <TabsContent value="settings">
              <SettingsPage />
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </TooltipProvider>
  );
};
function App() {
  const [loading, setLoading] = useState(true);
  // Initialize the database and application
  useEffect(() => {
    const initializeApp = async () => {
      try {
        setLoading(true);
        // Initialize the database
        const { initDB } = await import("./lib/db");
        await initDB();
        console.log("Database initialized successfully");
      } catch (error) {
        console.error("Error initializing application:", error);
        toast.error("Failed to initialize application. Please check the console for details.");
      } finally {
        setLoading(false);
      }
    };
    initializeApp();
  }, []);
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-background">
        <div className="text-center space-y-4">
          <h2 className="text-xl font-medium">Loading Anchoring...</h2>
          <Progress value={50} className="w-[300px]" />
        </div>
      </div>
    );
  }
  return <MainApp />;
}
export default App;
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import { Toaster } from "./components/ui/sonner";
import { ThemeProvider } from "./components/settings/theme-provider"; 
import "./App.css";
import App from "./App";
ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <ThemeProvider defaultTheme="system" storageKey="ui-theme">
      <App />
      <Toaster position="top-right" />
    </ThemeProvider>
  </React.StrictMode>,
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": [
    "main"
  ],
  "permissions": [
    "core:default",
    "opener:default",
    "sql:default",
    "sql:allow-execute",
    "sql:allow-close",
    "sql:allow-load",
    "sql:allow-select",
    "http:default",
    "fs:default",
    "fs:write-all",
    "fs:read-all",
    "http:allow-fetch",
    "http:allow-fetch-send",
    "http:allow-fetch-read-body",
    "http:allow-fetch-cancel",
    "cors-fetch:default",
    {
      "identifier": "fs:scope",
      "allow": [
        { "path": "$HOME/**" },
        { "path": "/Users/woof/GauntletAI/anchoring/.chroma" },
        { "path": "/Users/woof/GauntletAI/anchoring/.chroma/**" }
      ]
    },
    {
      "identifier": "http:default",
      "allow": [{"url": "http://*:*"}, {"url": "https://*:*"}, {"url": "http://*"}, {"url": "https://*"}]
    }
  ]
}
</file>

<file path="src-tauri/src/lib.rs">
// Fetch proxies from the remote URL
#[tauri::command]
async fn fetch_proxies() -> Result<Vec<String>, String> {
    use reqwest::Client;
    let url = "https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/http.txt";
    let client = Client::new();
    let response = client
        .get(url)
        .send()
        .await
        .map_err(|e| e.to_string())?;
    let body = response.text().await.map_err(|e| e.to_string())?;
    // Split by newlines and filter out empty lines
    let proxies: Vec<String> = body
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| line.trim().to_string())
        .collect();
    Ok(proxies)
}
/// Fetch a URL using headless Chrome with full JavaScript rendering
#[tauri::command]
async fn fetch_with_headless_browser(url: String) -> Result<String, String> {
    use headless_chrome::{Browser, LaunchOptions};
    use tokio::task;
    use std::path::Path;
    println!("Fetching URL with headless Chrome: {}", url);
    // Check if Chrome is installed before proceeding
    // This function now runs its own tokio runtime internally
    match ensure_chrome_installed() {
        Ok(_) => println!("Chrome is installed and ready"),
        Err(e) => return Err(format!("Failed to ensure Chrome is installed: {}", e)),
    }
    // Find Chrome executable path
    let chrome_executable = find_chrome_path().ok_or_else(|| 
        "Could not find Chrome executable path".to_string()
    )?;
    println!("Using Chrome at: {}", chrome_executable);
    // Create a clone of url for the spawn_blocking closure
    let url_clone = url.clone();
    let chrome_path = chrome_executable.clone();
    // Use tokio blocking task for headless_chrome operations which are not async-compatible
    let html = task::spawn_blocking(move || -> Result<String, String> {
        // Configure browser options for optimal web scraping
        let launch_options = LaunchOptions::default_builder()
            .headless(true)
            .path(Some(Path::new(&chrome_path).to_path_buf()))
            .sandbox(false)
            .window_size(Some((1920, 1080)))
            .build()
            .map_err(|e| format!("Failed to build launch options: {}", e))?;
        // Launch browser with our options
        let browser = match Browser::new(launch_options) {
            Ok(browser) => browser,
            Err(e) => return Err(format!("Failed to launch browser: {}", e)),
        };
        // Create a new tab
        let tab = match browser.new_tab() {
            Ok(tab) => tab,
            Err(e) => return Err(format!("Failed to create new tab: {}", e)),
        };
        // Navigate to URL
        match tab.navigate_to(&url_clone) {
            Ok(_) => (),
            Err(e) => return Err(format!("Failed to navigate to {}: {}", url_clone, e)),
        }
        // Wait for page to load
        match tab.wait_until_navigated() {
            Ok(_) => println!("Initial page load complete"),
            Err(e) => return Err(format!("Failed to wait for navigation: {}", e)),
        }
        // Wait for document to be ready
        match wait_for_document_ready(&tab) {
            Ok(_) => println!("Document ready state complete"),
            Err(e) => println!("Warning: Could not confirm document ready state: {}", e),
        }
        // Scroll through the page to load lazy content
        match scroll_page_for_lazy_loading(&tab) {
            Ok(_) => println!("Page scrolled to load lazy content"),
            Err(e) => println!("Warning: Could not scroll page: {}", e),
        }
        // Get the final HTML content
        let html = match tab.get_content() {
            Ok(content) => content,
            Err(e) => return Err(format!("Failed to get page content: {}", e)),
        };
        println!("Successfully fetched content ({} bytes)", html.len());
        Ok(html)
    }).await.map_err(|e| format!("Task execution error: {}", e))?;
    html
}
/// Helper function to wait for document ready state
fn wait_for_document_ready(tab: &headless_chrome::Tab) -> Result<(), String> {
    let script = r#"
    new Promise((resolve) => {
        if (document.readyState === 'complete') {
            resolve(true);
            return;
        }
        document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
                resolve(true);
            }
        });
    })
    "#;
    match tab.evaluate(script, true) {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("Document ready check failed: {}", e)),
    }
}
/// Helper function to scroll through page to trigger lazy loading
fn scroll_page_for_lazy_loading(tab: &headless_chrome::Tab) -> Result<(), String> {
    let script = r#"
    new Promise((resolve) => {
        const maxHeight = Math.max(
            document.body.scrollHeight, 
            document.documentElement.scrollHeight
        );
        // Faster scrolling - directly jump to several positions to trigger lazy loading
        // This is more efficient than the previous incremental approach
        const positions = [
            0,                    // Top
            maxHeight * 0.25,     // 25% down
            maxHeight * 0.5,      // 50% down 
            maxHeight * 0.75,     // 75% down
            maxHeight,            // Bottom
            0                     // Back to top
        ];
        // Execute all scrolls immediately without timeouts
        positions.forEach(pos => window.scrollTo(0, pos));
        // Resolve immediately after scrolling is complete
        resolve(true);
    })
    "#;
    match tab.evaluate(script, true) {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("Scroll operation failed: {}", e)),
    }
}
/// Find Chrome or Chromium executable path
fn find_chrome_path() -> Option<String> {
    use std::path::Path;
    // Define possible Chrome paths based on OS
    #[cfg(target_os = "windows")]
    let chrome_paths = vec![
        r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files\Google\Chrome Beta\Application\chrome.exe",
        r"C:\Program Files\Google\Chrome Dev\Application\chrome.exe",
        r"C:\Program Files\Google\Chrome Canary\Application\chrome.exe",
        r"C:\Program Files\Chromium\Application\chrome.exe",
    ];
    #[cfg(target_os = "macos")]
    let chrome_paths = vec![
        "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
        "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
        "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
        "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
        "/Applications/Chromium.app/Contents/MacOS/Chromium",
        "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
        "/Applications/Brave Browser.app/Contents/MacOS/Brave Browser",
        "/usr/local/bin/chromium",
    ];
    #[cfg(target_os = "linux")]
    let chrome_paths = vec![
        "/usr/bin/google-chrome",
        "/usr/bin/google-chrome-stable",
        "/usr/bin/google-chrome-beta",
        "/usr/bin/google-chrome-dev",
        "/usr/bin/chromium",
        "/usr/bin/chromium-browser",
        "/snap/bin/chromium",
    ];
    // Check each path and return the first one that exists
    for path in chrome_paths {
        if Path::new(path).exists() {
            return Some(path.to_string());
        }
    }
    None
}
/// Sets up Chrome environment for headless browsing
fn ensure_chrome_installed() -> Result<(), String> {
    // Find Chrome executable
    match find_chrome_path() {
        Some(path) => {
            println!("Found Chrome/Chromium at: {}", path);
            Ok(())
        },
        None => {
            Err("Chrome or Chromium is not installed in standard locations. Please install Chrome/Chromium browser.".to_string())
        }
    }
}
/// Convert HTML content to Markdown format
/// 
/// This command provides a Rust implementation of the HTML to Markdown conversion
/// that was previously done in JavaScript. It uses the html2md crate to perform
/// the conversion efficiently, especially for large HTML documents.
#[tauri::command]
fn convert_html_to_markdown(html: String) -> Result<String, String> {
    use std::time::Instant;
    println!("Converting HTML to Markdown using Rust implementation");
    println!("HTML content length: {} characters", html.len());
    println!("HTML content preview: {}", &html[..std::cmp::min(100, html.len())]);
    let start = Instant::now();
    // Perform the conversion using html2md
    let result = match std::panic::catch_unwind(|| {
        html2md::parse_html(&html)
    }) {
        Ok(markdown) => markdown,
        Err(e) => return Err(format!("Failed to convert HTML to Markdown: {:?}", e)),
    };
    let duration = start.elapsed();
    println!("✅ HTML to Markdown conversion completed in {}ms", duration.as_millis());
    println!("Markdown length: {} characters", result.len());
    println!("Markdown preview: {}", &result[..std::cmp::min(100, result.len())]);
    Ok(result)
}
/// Chunk text using semantic boundaries and token counts
/// 
/// This function splits text into optimized chunks for language models,
/// using semantic boundaries (paragraphs, sentences, headings, code blocks)
/// and respecting token limits for different models:
/// - cl100k_base for text-embedding-3-large (8,191 tokens max)
/// - o200k_base for gpt-4o-mini (128,000 tokens max)
///
/// It automatically detects content type (markdown, code) and applies
/// the appropriate splitting strategy.
#[tauri::command]
fn split_text_by_tokens(
    text: String, 
    model_type: String, 
    chunk_size: usize, 
    chunk_overlap: usize,
    content_type: Option<String>
) -> Result<Vec<String>, String> {
    use std::time::Instant;
    use text_splitter::{TextSplitter, ChunkConfig, MarkdownSplitter};
    use tiktoken_rs::{cl100k_base, o200k_base};
    println!("Splitting text using Rust implementation");
    println!("Text length: {} characters", text.len());
    println!("Model type: {}, Chunk size: {}, Overlap: {}", model_type, chunk_size, chunk_overlap);
    let start = Instant::now();
    // Define model-specific parameters
    let (model_name, max_tokens) = match model_type.as_str() {
        "cl100k_base" | "text-embedding-3-large" => ("cl100k_base", 8191),
        "o200k_base" | "gpt-4o-mini" => ("o200k_base", 128000),
        _ => return Err(format!("Unsupported model type: {}. Use 'cl100k_base'/'text-embedding-3-large' or 'o200k_base'/'gpt-4o-mini'", model_type)),
    };
    // Use provided chunk size or default to model's max tokens
    let actual_chunk_size = if chunk_size == 0 { max_tokens } else { chunk_size };
    // Define chunk range with overlap
    let chunk_range = (actual_chunk_size - chunk_overlap)..actual_chunk_size;
    // Detect content type if not explicitly provided
    let is_markdown = match content_type {
        Some(ctype) => ctype.to_lowercase() == "markdown",
        None => {
            // Simple detection logic for markdown
            text.contains("```") || text.contains("##") || (text.contains("#") && text.contains("\n"))
        }
    };
    // Process based on model and content type (markdown or plain text)
    let result: Vec<String> = if model_name == "cl100k_base" {
        let tokenizer = cl100k_base().map_err(|e| format!("Failed to initialize cl100k tokenizer: {}", e))?;
        if is_markdown {
            println!("Using Markdown splitter with cl100k tokenizer");
            let config = ChunkConfig::new(chunk_range).with_sizer(tokenizer);
            let splitter = MarkdownSplitter::new(config);
            splitter.chunks(&text).map(|s| s.to_string()).collect()
        } else {
            println!("Using Text splitter with cl100k tokenizer");
            let config = ChunkConfig::new(chunk_range).with_sizer(tokenizer);
            let splitter = TextSplitter::new(config);
            splitter.chunks(&text).map(|s| s.to_string()).collect()
        }
    } else {
        let tokenizer = o200k_base().map_err(|e| format!("Failed to initialize o200k tokenizer: {}", e))?;
        if is_markdown {
            println!("Using Markdown splitter with o200k tokenizer");
            let config = ChunkConfig::new(chunk_range).with_sizer(tokenizer);
            let splitter = MarkdownSplitter::new(config);
            splitter.chunks(&text).map(|s| s.to_string()).collect()
        } else {
            println!("Using Text splitter with o200k tokenizer");
            let config = ChunkConfig::new(chunk_range).with_sizer(tokenizer);
            let splitter = TextSplitter::new(config);
            splitter.chunks(&text).map(|s| s.to_string()).collect()
        }
    };
    let duration = start.elapsed();
    println!("✅ Text splitting completed in {}ms", duration.as_millis());
    println!("Created {} chunks", result.len());
    Ok(result)
}
// Code splitter functionality removed as not needed
/// Count tokens in a text string using different tokenizers
///
/// This function counts tokens in text using the specified tokenizer model:
/// - cl100k_base for text-embedding-3-large
/// - o200k_base for gpt-4o-mini
#[tauri::command]
fn count_tokens(text: String, model_type: String) -> Result<usize, String> {
    use tiktoken_rs::{cl100k_base, o200k_base};
    let token_count = match model_type.as_str() {
        "cl100k_base" | "text-embedding-3-large" => {
            let tokenizer = cl100k_base().map_err(|e| format!("Failed to initialize cl100k tokenizer: {}", e))?;
            tokenizer.encode_with_special_tokens(&text).len()
        },
        "o200k_base" | "gpt-4o-mini" => {
            let tokenizer = o200k_base().map_err(|e| format!("Failed to initialize o200k tokenizer: {}", e))?;
            tokenizer.encode_with_special_tokens(&text).len()
        },
        _ => return Err(format!("Unsupported model type: {}. Use 'cl100k_base' or 'o200k_base'", model_type)),
    };
    Ok(token_count)
}
/// Perform a vector search on processed content
/// 
/// This function searches through vector embeddings of processed content
/// using a query string and returns the most semantically similar results.
#[tauri::command]
async fn vector_search(query: String, session_id: Option<u64>, limit: Option<u32>) -> Result<Vec<SearchResult>, String> {
    use std::time::Instant;
    println!("Performing vector search with query: {}", query);
    let start = Instant::now();
    let search_limit = limit.unwrap_or(10);
    let _session_filter = session_id.map(|id| format!("session_id = {}", id));
    // For now, return a mock response
    // In a real implementation, this would:
    // 1. Convert the query to an embedding using the same model as during processing
    // 2. Perform a vector similarity search in the database
    // 3. Return the closest matches with their metadata
    let duration = start.elapsed();
    println!("✅ Vector search completed in {}ms", duration.as_millis());
    // Mock response for now
    let results = mock_vector_search_results(&query, search_limit as usize);
    Ok(results)
}
/// Mock search results structure
#[derive(serde::Serialize, serde::Deserialize)]
struct SearchResult {
    id: String,
    score: f32,
    snippet: DocSnippet,
}
/// Doc snippet structure
#[derive(serde::Serialize, serde::Deserialize)]
struct DocSnippet {
    id: String,
    title: String,
    content: String,
    source: String,
    category: String,
    name: String,
    version: Option<String>,
}
/// Generate mock vector search results
fn mock_vector_search_results(query: &str, limit: usize) -> Vec<SearchResult> {
    let mut results = Vec::new();
    // Sample results
    if query.to_lowercase().contains("react") {
        results.push(SearchResult {
            id: "mock-1".to_string(),
            score: 0.95,
            snippet: DocSnippet {
                id: "snippet-1".to_string(),
                title: "React Hooks Usage".to_string(),
                content: "
```jsx
import React, { useState, useEffect } from 'react';
function Example() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  }, [count]);
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```
                ".to_string(),
                source: "https://reactjs.org/docs/hooks-overview.html".to_string(),
                category: "library".to_string(),
                name: "react".to_string(),
                version: Some("18.3.0".to_string()),
            }
        });
    }
    if query.to_lowercase().contains("tauri") {
        results.push(SearchResult {
            id: "mock-2".to_string(),
            score: 0.92,
            snippet: DocSnippet {
                id: "snippet-2".to_string(),
                title: "Tauri Commands".to_string(),
                content: "
```rust
#[tauri::command]
fn greet(name: &str) -> String {
  format!(\"Hello, {}!\", name)
}
#[tauri::command]
async fn perform_request(url: String) -> Result<String, String> {
  let response = reqwest::get(&url)
    .await
    .map_err(|e| e.to_string())?
    .text()
    .await
    .map_err(|e| e.to_string())?;
  Ok(response)
}
fn main() {
  tauri::Builder::default()
    .invoke_handler(tauri::generate_handler![greet, perform_request])
    .run(tauri::generate_context!())
    .expect(\"failed to run app\");
}
```
                ".to_string(),
                source: "https://tauri.app/v2/guides/features/command/".to_string(),
                category: "framework".to_string(),
                name: "Tauri".to_string(),
                version: Some("2.3.1".to_string()),
            }
        });
    }
    // Add some generic results if we don't have specific matches
    if results.len() < limit {
        results.push(SearchResult {
            id: "mock-generic-1".to_string(),
            score: 0.82,
            snippet: DocSnippet {
                id: "snippet-generic-1".to_string(),
                title: "TypeScript Interfaces vs Types".to_string(),
                content: "
```typescript
// Interface
interface User {
  id: number;
  name: string;
  email?: string;
}
// Type
type User = {
  id: number;
  name: string;
  email?: string;
};
// Extending an interface
interface Animal {
  name: string;
}
interface Dog extends Animal {
  breed: string;
}
// Extending a type
type Animal = {
  name: string;
};
type Dog = Animal & {
  breed: string;
};
```
                ".to_string(),
                source: "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html".to_string(),
                category: "language".to_string(),
                name: "TypeScript".to_string(),
                version: Some("5.6.2".to_string()),
            }
        });
    }
    // Limit results
    if results.len() > limit {
        results.truncate(limit);
    }
    results
}
mod pinecone;
use pinecone::{PineconeConfig, Document, PineconeService};
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use tauri_plugin_cors_fetch;
// Global state for Pinecone sessions
lazy_static::lazy_static! {
    static ref PINECONE_SESSIONS: Arc<Mutex<HashMap<u64, Arc<PineconeService>>>> = Arc::new(Mutex::new(HashMap::new()));
}
#[derive(Debug, Serialize, Deserialize)]
struct PineconeSearchResult {
    id: String,
    values: Vec<f32>,
    metadata: Option<serde_json::Value>,
}
#[tauri::command]
async fn initialize_vector_db(session_id: u64, config: PineconeConfig) -> Result<(), String> {
    println!("🚨 [Tauri Command] initialize_vector_db ENTRY POINT - session_id: {}", session_id);
    println!("🚨 [Tauri Command] Using index name: {}", config.index_name);
    println!("🚨 [Tauri Command] API key (first 5 chars): {}", &config.api_key[..5.min(config.api_key.len())]);
    let service = match PineconeService::new(config).await {
        Ok(service) => {
            println!("✅ [Tauri Command] Successfully created PineconeService");
            service
        },
        Err(e) => {
            println!("❌ [Tauri Command] Failed to initialize Pinecone: {}", e);
            return Err(format!("Failed to initialize Pinecone: {}", e));
        }
    };
    let mut sessions = PINECONE_SESSIONS.lock().await;
    sessions.insert(session_id, Arc::new(service));
    println!("✅ [Tauri Command] Successfully initialized vector DB for session: {}", session_id);
    Ok(())
}
#[tauri::command]
async fn add_documents(session_id: u64, documents: Vec<Document>) -> Result<(), String> {
    println!("🚨 [Tauri Command] add_documents ENTRY POINT - session_id: {}, document count: {}", 
             session_id, documents.len());
    // Log first document details immediately
    if !documents.is_empty() {
        let first_doc = &documents[0];
        println!("🚨 [Tauri Command] First document - ID: {}, content length: {}, embedding length: {}", 
                 first_doc.id, first_doc.content.len(), first_doc.embedding.len());
    }
    let sessions = PINECONE_SESSIONS.lock().await;
    let service = match sessions.get(&session_id) {
        Some(service) => {
            println!("✅ [Tauri Command] Found Pinecone service for session: {}", session_id);
            service
        },
        None => {
            println!("❌ [Tauri Command] Vector DB not initialized for session: {}", session_id);
            return Err("Vector DB not initialized for this session".to_string());
        }
    };
    println!("🔍 [Tauri Command] Forwarding {} documents to PineconeService", documents.len());
    match service.add_documents(documents).await {
        Ok(_) => {
            println!("✅ [Tauri Command] Successfully added documents for session: {}", session_id);
            Ok(())
        },
        Err(e) => {
            println!("❌ [Tauri Command] Failed to add documents: {}", e);
            Err(format!("Failed to add documents: {}", e))
        }
    }
}
#[tauri::command]
async fn search_documents(
    session_id: u64,
    embedding: Vec<f32>,
    filter: Option<serde_json::Value>,
    limit: Option<usize>,
) -> Result<Vec<PineconeSearchResult>, String> {
    println!("🔍 [Tauri Command] search_documents called with embedding length: {}", embedding.len());
    let sessions = PINECONE_SESSIONS.lock().await;
    let service = match sessions.get(&session_id) {
        Some(service) => service,
        None => {
            println!("❌ [Tauri Command] Vector DB not initialized for session: {}", session_id);
            return Err("Vector DB not initialized for this session".to_string());
        }
    };
    // Search for vectors
    let vectors = match service.search(embedding, filter, limit.unwrap_or(10)).await {
        Ok(vectors) => vectors,
        Err(e) => {
            println!("❌ [Tauri Command] Failed to search documents: {}", e);
            return Err(format!("Failed to search documents: {}", e));
        }
    };
    // Convert vectors to results
    let mut results = Vec::new();
    for v in vectors {
        // Convert Pinecone metadata to serde_json::Value if present
        let metadata = v.metadata.map(|md| {
            let mut map = serde_json::Map::new();
            for (key, value) in md.fields {
                if let Some(kind) = value.kind {
                    let json_value = match kind {
                        pinecone_sdk::models::Kind::StringValue(s) => serde_json::Value::String(s),
                        pinecone_sdk::models::Kind::NumberValue(n) => {
                            if let Some(num) = serde_json::Number::from_f64(n) {
                                serde_json::Value::Number(num)
                            } else {
                                serde_json::Value::Null
                            }
                        },
                        pinecone_sdk::models::Kind::BoolValue(b) => serde_json::Value::Bool(b),
                        _ => serde_json::Value::Null,
                    };
                    map.insert(key, json_value);
                }
            }
            serde_json::Value::Object(map)
        });
        results.push(PineconeSearchResult {
            id: v.id,
            values: v.values,
            metadata,
        });
    }
    println!("✅ [Tauri Command] Search returned {} results", results.len());
    Ok(results)
}
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_sql::Builder::default().build())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_http::init())
        .plugin(tauri_plugin_cors_fetch::init())
        .invoke_handler(tauri::generate_handler![
            fetch_proxies,
            fetch_with_headless_browser,
            convert_html_to_markdown,
            split_text_by_tokens,
            count_tokens,
            vector_search,
            // Add new Pinecone commands
            initialize_vector_db,
            add_documents,
            search_documents,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
fn main() {
    anchoring_lib::run()
}
</file>

<file path="src-tauri/src/pinecone.rs">
use pinecone_sdk::pinecone::{PineconeClient, PineconeClientConfig};
use pinecone_sdk::models::{Vector, Namespace, Metadata, Value, Kind};
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::collections::BTreeMap;
#[derive(Debug, Serialize, Deserialize)]
pub struct PineconeConfig {
    pub api_key: String,
    pub index_name: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Document {
    pub id: String,
    pub content: String,
    pub embedding: Vec<f32>,
    pub metadata: serde_json::Value,
}
pub struct PineconeService {
    client: PineconeClient,
    index_name: String,
    index_host: String,
}
impl PineconeService {
    pub async fn new(config: PineconeConfig) -> Result<Self, Box<dyn Error>> {
        println!("🔍 [Pinecone] Initializing PineconeService with index: {}", config.index_name);
        println!("🔍 [Pinecone] API key (first 5 chars): {}", &config.api_key[..5.min(config.api_key.len())]);
        // Create client config with API key
        let client_config = PineconeClientConfig {
            api_key: Some(config.api_key.clone()),
            ..Default::default()
        };
        println!("🔍 [Pinecone] Creating Pinecone client with config");
        // Initialize the client
        let client = match client_config.client() {
            Ok(client) => {
                println!("✅ [Pinecone] Successfully created Pinecone client");
                client
            },
            Err(e) => {
                println!("❌ [Pinecone] Failed to create Pinecone client: {}", e);
                return Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to create Pinecone client: {}", e))));
            }
        };
        // IMPORTANT: First describe the index to get its host
        println!("🔍 [Pinecone] Describing index to get host: {}", config.index_name);
        let index_description = match client.describe_index(&config.index_name).await {
            Ok(desc) => {
                println!("✅ [Pinecone] Successfully described index: {}", config.index_name);
                println!("🔍 [Pinecone] Index host: {}", desc.host);
                println!("🔍 [Pinecone] Index status: {:?}", desc.status);
                println!("🔍 [Pinecone] Index dimension: {}", desc.dimension);
                desc
            },
            Err(e) => {
                println!("❌ [Pinecone] Failed to describe index: {}", e);
                return Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to describe index: {}", e))));
            }
        };
        Ok(Self {
            client,
            index_name: config.index_name,
            index_host: index_description.host,
        })
    }
    pub async fn add_documents(&self, documents: Vec<Document>) -> Result<(), Box<dyn Error>> {
        println!("🔍 [Pinecone] Adding {} documents to index: {}", documents.len(), self.index_name);
        // Log sample document (first one)
        if !documents.is_empty() {
            let sample = &documents[0];
            println!("🔍 [Pinecone] Sample document ID: {}", sample.id);
            println!("🔍 [Pinecone] Sample embedding length: {}", sample.embedding.len());
            println!("🔍 [Pinecone] Sample metadata: {}", serde_json::to_string(&sample.metadata).unwrap_or_else(|_| "Could not serialize".to_string()));
        }
        // Connect to the index using the HOST, not the name
        println!("🔍 [Pinecone] Connecting to index using host: {}", self.index_host);
        let mut index = match self.client.index(&self.index_host).await {
            Ok(index) => {
                println!("✅ [Pinecone] Successfully connected to index");
                index
            },
            Err(e) => {
                println!("❌ [Pinecone] Failed to connect to index: {}", e);
                return Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to connect to index: {}", e))));
            }
        };
        // Convert documents to vectors
        println!("🔍 [Pinecone] Converting documents to Pinecone vectors");
        let vectors: Vec<Vector> = documents
            .into_iter()
            .map(|doc| {
                // Convert serde_json::Value to Pinecone Metadata format
                let metadata = convert_json_to_metadata(doc.metadata.clone());
                println!("🔍 [Pinecone] Processing document ID: {}, embedding length: {}", 
                         doc.id, doc.embedding.len());
                Vector {
                    id: doc.id,
                    values: doc.embedding,
                    sparse_values: None,
                    metadata: Some(metadata),
                }
            })
            .collect();
        println!("🔍 [Pinecone] Upserting {} vectors to index", vectors.len());
        // Upsert vectors to the index - use default namespace
        match index.upsert(&vectors, &Namespace::default()).await {
            Ok(response) => {
                println!("✅ [Pinecone] Successfully upserted vectors. Upserted count: {}", response.upserted_count);
                Ok(())
            },
            Err(e) => {
                println!("❌ [Pinecone] Failed to upsert vectors: {}", e);
                Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to upsert vectors: {}", e))))
            }
        }
    }
    pub async fn search(
        &self,
        embedding: Vec<f32>,
        filter: Option<serde_json::Value>,
        limit: usize,
    ) -> Result<Vec<Vector>, Box<dyn Error>> {
        println!("🔍 [Pinecone] Searching index with embedding length: {}", embedding.len());
        // Connect to the index using the HOST, not the name
        let mut index = match self.client.index(&self.index_host).await {
            Ok(index) => {
                println!("✅ [Pinecone] Successfully connected to index");
                index
            },
            Err(e) => {
                println!("❌ [Pinecone] Failed to connect to index: {}", e);
                return Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to connect to index: {}", e))));
            }
        };
        // Convert filter if provided
        let metadata_filter = filter.map(convert_json_to_metadata);
        // Query the index - use default namespace
        match index.query_by_value(
            embedding,
            None, // No sparse values
            limit as u32,
            &Namespace::default(),
            metadata_filter,
            None, // Include values
            None, // Include metadata
        ).await {
            Ok(response) => {
                println!("✅ [Pinecone] Search successful. Got {} matches", response.matches.len());
                // Convert matches to Vector objects
                let vectors = response.matches
                    .into_iter()
                    .map(|m| Vector {
                        id: m.id,
                        values: m.values,
                        sparse_values: m.sparse_values,
                        metadata: m.metadata,
                    })
                    .collect();
                Ok(vectors)
            },
            Err(e) => {
                println!("❌ [Pinecone] Search failed: {}", e);
                Err(Box::new(std::io::Error::new(std::io::ErrorKind::Other, 
                    format!("Failed to search: {}", e))))
            }
        }
    }
}
// Helper function to convert serde_json::Value to Pinecone Metadata
fn convert_json_to_metadata(json: serde_json::Value) -> Metadata {
    let mut fields = BTreeMap::new();
    if let serde_json::Value::Object(map) = json {
        for (key, value) in map {
            let kind = match value {
                serde_json::Value::String(s) => Some(Kind::StringValue(s)),
                serde_json::Value::Number(n) => {
                    if let Some(i) = n.as_i64() {
                        Some(Kind::NumberValue(i as f64))
                    } else if let Some(f) = n.as_f64() {
                        Some(Kind::NumberValue(f))
                    } else {
                        None
                    }
                },
                serde_json::Value::Bool(b) => Some(Kind::BoolValue(b)),
                serde_json::Value::Array(arr) => {
                    // Convert array to string to preserve the data
                    Some(Kind::StringValue(serde_json::to_string(&arr).unwrap_or_default()))
                },
                serde_json::Value::Object(obj) => {
                    // Convert nested object to string to preserve the data
                    Some(Kind::StringValue(serde_json::to_string(&obj).unwrap_or_default()))
                },
                _ => None,
            };
            if let Some(k) = kind {
                fields.insert(key, Value { kind: Some(k) });
            }
        }
    }
    Metadata { fields }
}
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "anchoring"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "anchoring_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tauri-plugin-sql = { version = "2", features = ["sqlite"] }
tauri-plugin-http = { version = "2", features = ["dangerous-settings"] }
tauri-plugin-fs = "2"
reqwest = { version = "0.12.12", features = ["json"] }
tauri-plugin-cors-fetch = "3.1.0"
headless_chrome = "1.0.2"
chromedriver-update = "1.0.2"
tokio = {version = "1.43.0", features = ["full"] }
tiktoken-rs = "0.6.0"
text-splitter = { version = "0.24.1", features = ["tiktoken-rs", "markdown"] }
html2md = "0.2"
pinecone-sdk = "0.1.2"
lazy_static = "1.4.0"
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "anchoring",
  "version": "0.1.0",
  "identifier": "com.gawntlet.anchoring",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "anchoring",
        "width": 800,
        "height": 600
      }
    ],
    "withGlobalTauri": true,
    "security": {
      "csp": "default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; connect-src * ipc: http://ipc.localhost; img-src * data: blob: asset: http://asset.localhost; style-src * 'unsafe-inline'; font-src * data:; script-src * 'unsafe-inline' 'unsafe-eval';",
      "dangerousDisableAssetCspModification": true
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}
</file>

<file path=".gitignore">
!src/lib/**
!.env.example
t2v.md
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/App.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "anchoring",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "@hookform/resolvers": "^4.1.3",
    "@pinecone-database/pinecone": "^5.1.1",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-aspect-ratio": "^1.1.2",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.6",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-hover-card": "^1.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-navigation-menu": "^1.2.5",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toggle": "^1.1.2",
    "@radix-ui/react-toggle-group": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tailwindcss/vite": "^4.0.9",
    "@tauri-apps/plugin-fs": "^2.2.0",
    "@tauri-apps/plugin-http": "^2.3.0",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-sql": "^2.2.0",
    "@xenova/transformers": "^2.17.2",
    "cheerio": "^1.0.0",
    "chromadb": "^1.10.5",
    "chromadb-default-embed": "^2.14.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.5.2",
    "input-otp": "^1.4.2",
    "js-tiktoken": "^1.0.19",
    "lucide-react": "^0.477.0",
    "next-themes": "^0.4.4",
    "openai": "^4.86.2",
    "playwright": "^1.51.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "react-resizable-panels": "^2.1.7",
    "react-virtualized": "^9.22.6",
    "recharts": "^2.15.1",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss": "^4.0.9",
    "tailwindcss-animate": "^1.0.7",
    "turndown": "^7.2.0",
    "vaul": "^1.1.2",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.16",
    "@tauri-apps/api": "^2.3.0",
    "@tauri-apps/cli": "^2",
    "@types/node": "^22.13.9",
    "@types/react": "^18.3.1",
    "@types/react-dom": "^18.3.1",
    "@types/turndown": "^5.0.5",
    "@vitejs/plugin-react": "^4.3.4",
    "typescript": "~5.6.2",
    "vite": "^6.0.3"
  }
}
</file>

<file path="README.md">
# Anchoring Desktop Application

This is the desktop application for the Anchoring project, built with Tauri, React and TypeScript.

## Prerequisites

- [Node.js](https://nodejs.org/) - LTS version recommended
- [Rust](https://www.rust-lang.org/tools/install) - Required for Tauri
- MCP Server - Automatically set up by the startup scripts (see main README.md)
- ChromaDB - Automatically started by the startup scripts (see main README.md)

For the easiest setup, use the startup scripts in the root directory (`start.sh` for macOS/Linux or `start.bat` for Windows).

## Setup Instructions

1. Install dependencies:

```bash
npm install
```

2. Configure environment (optional):
   - Copy `.env.EXAMPLE` to `.env` to customize ChromaDB connection:
   ```bash
   cp .env.EXAMPLE .env
   ```
   - Adjust `CHROMA_HOST` and `CHROMA_PORT` as needed

3. Verify the MCP server and ChromaDB are running:
   - Check if ChromaDB container is up: `docker ps`
   - Ensure MCP server is installed with Claude: `mcp list`

4. Run the development environment:

```bash
npm run tauri dev
```

## Usage Guide

For a comprehensive tutorial and walkthrough of the Anchoring Desktop Application, check out this guide:
[Anchoring Desktop Tutorial](https://x.com/mrmidwit/status/1898570762128183730?s=46)

## Building the Application

To create a production build:

```bash
npm run tauri build
```

This will create platform-specific binaries in the `src-tauri/target/release` directory.

## Development Notes

- The application uses ShadCN UI components for the interface
- State management is handled through React hooks
- The Tauri app communicates with the MCP server for document processing and retrieval

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class", '.dark *'],
  theme: {
    extend: {
      typography: {
        DEFAULT: {
          css: {
            '--tw-prose-body': 'var(--foreground)',
            '--tw-prose-headings': 'var(--foreground)',
            '--tw-prose-lead': 'var(--muted-foreground)',
            '--tw-prose-links': 'var(--primary)',
            '--tw-prose-bold': 'var(--foreground)',
            '--tw-prose-counters': 'var(--muted-foreground)',
            '--tw-prose-bullets': 'var(--muted-foreground)',
            '--tw-prose-hr': 'var(--border)',
            '--tw-prose-quotes': 'var(--foreground)',
            '--tw-prose-quote-borders': 'var(--border)',
            '--tw-prose-captions': 'var(--muted-foreground)',
            '--tw-prose-code': 'var(--foreground)',
            '--tw-prose-pre-code': 'var(--foreground)',
            '--tw-prose-pre-bg': 'var(--muted)',
            '--tw-prose-th-borders': 'var(--border)',
            '--tw-prose-td-borders': 'var(--border)',
            // Dark mode
            '--tw-prose-invert-body': 'var(--foreground)',
            '--tw-prose-invert-headings': 'var(--foreground)',
            '--tw-prose-invert-lead': 'var(--muted-foreground)',
            '--tw-prose-invert-links': 'var(--primary)',
            '--tw-prose-invert-bold': 'var(--foreground)',
            '--tw-prose-invert-counters': 'var(--muted-foreground)',
            '--tw-prose-invert-bullets': 'var(--muted-foreground)',
            '--tw-prose-invert-hr': 'var(--border)',
            '--tw-prose-invert-quotes': 'var(--foreground)',
            '--tw-prose-invert-quote-borders': 'var(--border)',
            '--tw-prose-invert-captions': 'var(--muted-foreground)',
            '--tw-prose-invert-code': 'var(--foreground)',
            '--tw-prose-invert-pre-code': 'var(--foreground)',
            '--tw-prose-invert-pre-bg': 'var(--muted)',
            '--tw-prose-invert-th-borders': 'var(--border)',
            '--tw-prose-invert-td-borders': 'var(--border)',
            // Base styles
            maxWidth: 'none',
            a: {
              color: 'var(--primary)',
              textDecoration: 'none',
              fontWeight: '500',
              '&:hover': {
                textDecoration: 'underline',
              },
            },
            p: {
              color: 'var(--muted-foreground)',
              lineHeight: '1.75',
            },
            h1: {
              color: 'var(--foreground)',
              fontWeight: '600',
            },
            h2: {
              color: 'var(--foreground)',
              fontWeight: '600',
            },
            h3: {
              color: 'var(--foreground)',
              fontWeight: '600',
            },
            h4: {
              color: 'var(--foreground)',
              fontWeight: '600',
            },
            code: {
              color: 'var(--foreground)',
              backgroundColor: 'var(--muted)',
              borderRadius: '0.25rem',
              paddingLeft: '0.25rem',
              paddingRight: '0.25rem',
              paddingTop: '0.125rem',
              paddingBottom: '0.125rem',
              fontWeight: '400',
            },
            'code::before': {
              content: '""',
            },
            'code::after': {
              content: '""',
            },
            pre: {
              backgroundColor: 'var(--muted)',
              borderRadius: '0.375rem',
              padding: '1rem',
              overflow: 'auto',
            },
            'pre code': {
              backgroundColor: 'transparent',
              padding: '0',
            },
            blockquote: {
              color: 'var(--muted-foreground)',
              borderLeftColor: 'var(--border)',
            },
            hr: {
              borderColor: 'var(--border)',
            },
            thead: {
              borderBottomColor: 'var(--border)',
            },
            'tbody tr': {
              borderBottomColor: 'var(--border)',
            },
            img: {
              borderRadius: '0.375rem',
            }
          }
        }
      }
    }
  },
  plugins: [
    require('@tailwindcss/typography'),
  ]
};
</file>

<file path="TODO.md">
# Anchoring Desktop - TODO List

## Frontend Implementation

### Setup & Configuration
- [x] Implement ChromaDB path validation (using fs-extra plugin)
- [x] Create database initialization on the frontend
- [x] Add persistent settings storage (remember ChromaDB path)
- [x] Add dark/light theme toggle using ShadCN's ThemeProvider
- [x] Fix React ref warnings in ShadCN components

### Session Management
- [x] Implement session creation form
- [x] Implement session listing UI
- [x] Add session selection capability
- [x] Add session deletion functionality
- [x] Add session duplication functionality
- [x] Implement session export/import

### Crawler UI
- [x] Create basic crawler configuration form
- [x] Implement URL management interface
- [x] Create URL discovery progress indicators
- [x] Add real-time URL filtering capabilities
- [x] Implement batch URL operations (select all matching filter)
- [x] Create detailed URL view modal
- [x] Add error handling and retry mechanisms
- [ ] Implement crawl history and logs

### Proxy Management
- [x] Implement proxy fetching from remote source
- [x] Create proxy listing UI
- [x] Add proxy status indicators (working/failed)
- [ ] Implement proxy usage statistics

### Processing Pipeline
- [x] Implement OpenAI API key management
- [x] Create HTML to Markdown conversion using Turndown
- [ ] Build markdown preview functionality
- [x] Implement GPT-4o-mini cleanup integration
- [x] Add chunking controls and preview
- [x] Implement ChromaDB integration
- [x] Create embedding progress indicators
- [x] Add error handling for API failures

### Documentation Management
- [x] Implement documentation snippet viewing
- [ ] Create tech stack filtering (language/framework/library)
- [ ] Add documentation search functionality
- [ ] Implement documentation export/import
- [ ] Create version comparison tools

## Backend Implementation

### Tauri Commands
- [x] Implement proxy fetching
- [x] Implement file system operations for ChromaDB

## Documentation
- [ ] Update README with installation instructions
- [ ] Create user documentation
- [ ] Add developer documentation
- [ ] Document API endpoints and data structures
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "path";
const host = process.env.TAURI_DEV_HOST;
const mobile = process.env.TAURI_PLATFORM === "android" || process.env.TAURI_PLATFORM === "ios";
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  // Environment variables starting with VITE_ or TAURI_ENV_* will be exposed
  envPrefix: ['VITE_', 'TAURI_ENV_*'],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src")
    }
  },
  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
    // 4. Add CORS settings for better plugin handling
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",
      "Access-Control-Allow-Headers": "X-Requested-With, Content-Type, Authorization"
    }
  },
  // 5. Properly handle source maps for plugins
  build: {
    // Tauri uses Chromium on Windows and WebKit on macOS and Linux
    target: process.env.TAURI_PLATFORM == "windows" ? "chrome105" : "safari13",
    // Don't minify for debug builds
    minify: !process.env.TAURI_DEBUG ? "esbuild" : false,
    // Produce sourcemaps for debug builds
    sourcemap: !!process.env.TAURI_DEBUG,
  }
});
</file>

</files>
